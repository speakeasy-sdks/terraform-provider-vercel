// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/boolvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/numbervalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/numberplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	speakeasy_mapplanmodifier "github.com/speakeasy/terraform-provider-terraform/internal/planmodifiers/mapplanmodifier"
	speakeasy_numberplanmodifier "github.com/speakeasy/terraform-provider-terraform/internal/planmodifiers/numberplanmodifier"
	speakeasy_objectplanmodifier "github.com/speakeasy/terraform-provider-terraform/internal/planmodifiers/objectplanmodifier"
	speakeasy_stringplanmodifier "github.com/speakeasy/terraform-provider-terraform/internal/planmodifiers/stringplanmodifier"
	tfTypes "github.com/speakeasy/terraform-provider-terraform/internal/provider/types"
	"github.com/speakeasy/terraform-provider-terraform/internal/sdk"
	"github.com/speakeasy/terraform-provider-terraform/internal/sdk/models/operations"
	"github.com/speakeasy/terraform-provider-terraform/internal/validators"
	speakeasy_objectvalidators "github.com/speakeasy/terraform-provider-terraform/internal/validators/objectvalidators"
	speakeasy_stringvalidators "github.com/speakeasy/terraform-provider-terraform/internal/validators/stringvalidators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &DeploymentResource{}
var _ resource.ResourceWithImportState = &DeploymentResource{}

func NewDeploymentResource() resource.Resource {
	return &DeploymentResource{}
}

// DeploymentResource defines the resource implementation.
type DeploymentResource struct {
	client *sdk.SDK
}

// DeploymentResourceModel describes the resource data model.
type DeploymentResourceModel struct {
	Alias                         []types.String                            `tfsdk:"alias"`
	AliasAssigned                 types.Bool                                `tfsdk:"alias_assigned"`
	AliasAssignedAt               *tfTypes.AliasAssignedAt                  `tfsdk:"alias_assigned_at"`
	AliasError                    *tfTypes.AliasError                       `tfsdk:"alias_error"`
	AliasFinal                    types.String                              `tfsdk:"alias_final"`
	AliasWarning                  *tfTypes.AliasWarning                     `tfsdk:"alias_warning"`
	AutoAssignCustomDomains       types.Bool                                `tfsdk:"auto_assign_custom_domains"`
	AutomaticAliases              []types.String                            `tfsdk:"automatic_aliases"`
	BootedAt                      types.Number                              `tfsdk:"booted_at"`
	Build                         tfTypes.Build                             `tfsdk:"build"`
	BuildErrorAt                  types.Number                              `tfsdk:"build_error_at"`
	BuildingAt                    types.Number                              `tfsdk:"building_at"`
	CanceledAt                    types.Number                              `tfsdk:"canceled_at"`
	ChecksConclusion              types.String                              `tfsdk:"checks_conclusion"`
	ChecksState                   types.String                              `tfsdk:"checks_state"`
	ConnectBuildsEnabled          types.Bool                                `tfsdk:"connect_builds_enabled"`
	ConnectConfigurationID        types.String                              `tfsdk:"connect_configuration_id"`
	CreatedAt                     types.Number                              `tfsdk:"created_at"`
	CreatedIn                     types.String                              `tfsdk:"created_in"`
	Creator                       tfTypes.Creator                           `tfsdk:"creator"`
	Crons                         []tfTypes.CreateDeploymentCrons           `tfsdk:"crons"`
	CustomEnvironmentSlugOrID     types.String                              `tfsdk:"custom_environment_slug_or_id"`
	DeploymentID                  types.String                              `tfsdk:"deployment_id"`
	Env                           []types.String                            `tfsdk:"env"`
	ErrorCode                     types.String                              `tfsdk:"error_code"`
	ErrorLink                     types.String                              `tfsdk:"error_link"`
	ErrorMessage                  types.String                              `tfsdk:"error_message"`
	ErrorStep                     types.String                              `tfsdk:"error_step"`
	Files                         []tfTypes.Files                           `tfsdk:"files"`
	ForceNew                      types.String                              `tfsdk:"force_new"`
	Functions                     map[string]tfTypes.Functions              `tfsdk:"functions"`
	GitMetadata                   *tfTypes.GitMetadata                      `tfsdk:"git_metadata"`
	GitRepo                       *tfTypes.GitRepo                          `tfsdk:"git_repo"`
	GitSource                     *tfTypes.GitSource                        `tfsdk:"git_source"`
	ID                            types.String                              `tfsdk:"id"`
	InspectorURL                  types.String                              `tfsdk:"inspector_url"`
	IsInConcurrentBuildsQueue     types.Bool                                `tfsdk:"is_in_concurrent_builds_queue"`
	Lambdas                       []tfTypes.Lambdas                         `tfsdk:"lambdas"`
	Meta                          map[string]types.String                   `tfsdk:"meta"`
	MonorepoManager               types.String                              `tfsdk:"monorepo_manager"`
	Name                          types.String                              `tfsdk:"name"`
	One                           *tfTypes.GetDeploymentResponseBody1       `tfsdk:"one" tfPlanOnly:"true"`
	OwnerID                       types.String                              `tfsdk:"owner_id"`
	PassiveConnectConfigurationID types.String                              `tfsdk:"passive_connect_configuration_id"`
	PassiveRegions                []types.String                            `tfsdk:"passive_regions"`
	Plan                          types.String                              `tfsdk:"plan"`
	PreviewCommentsEnabled        types.Bool                                `tfsdk:"preview_comments_enabled"`
	Project                       types.String                              `tfsdk:"project"`
	ProjectID                     types.String                              `tfsdk:"project_id"`
	ProjectObj                    *tfTypes.GetDeploymentResponseBodyProject `tfsdk:"project_obj"`
	ProjectSettings               *tfTypes.ProjectSettings                  `tfsdk:"project_settings"`
	Public                        types.Bool                                `tfsdk:"public"`
	ReadyState                    types.String                              `tfsdk:"ready_state"`
	ReadySubstate                 types.String                              `tfsdk:"ready_substate"`
	Regions                       []types.String                            `tfsdk:"regions"`
	Routes                        []tfTypes.ResponseBodyRoutes              `tfsdk:"routes"`
	SkipAutoDetectionConfirmation types.String                              `tfsdk:"skip_auto_detection_confirmation"`
	Slug                          types.String                              `tfsdk:"slug"`
	Source                        types.String                              `tfsdk:"source"`
	Target                        types.String                              `tfsdk:"target"`
	Team                          *tfTypes.GetDeploymentResponseBodyTeam    `tfsdk:"team"`
	TeamID                        types.String                              `tfsdk:"team_id"`
	Two                           *tfTypes.GetDeploymentResponseBody2       `tfsdk:"two" tfPlanOnly:"true"`
	Type                          types.String                              `tfsdk:"type"`
	URL                           types.String                              `tfsdk:"url"`
	UserAliases                   []types.String                            `tfsdk:"user_aliases"`
	Version                       types.Number                              `tfsdk:"version"`
	WithLatestCommit              types.Bool                                `tfsdk:"with_latest_commit"`
}

func (r *DeploymentResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_deployment"
}

func (r *DeploymentResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Deployment Resource",
		Attributes: map[string]schema.Attribute{
			"alias": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: `A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation`,
			},
			"alias_assigned": schema.BoolAttribute{
				Computed:    true,
				Description: `A boolean that will be true when the aliases from the alias property were assigned successfully`,
			},
			"alias_assigned_at": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"number": schema.NumberAttribute{
						Computed: true,
						Validators: []validator.Number{
							numbervalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("boolean"),
							}...),
						},
					},
					"boolean": schema.BoolAttribute{
						Computed: true,
						Validators: []validator.Bool{
							boolvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("number"),
							}...),
						},
					},
				},
				Validators: []validator.Object{
					validators.ExactlyOneChild(),
				},
			},
			"alias_error": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"code": schema.StringAttribute{
						Computed: true,
					},
					"message": schema.StringAttribute{
						Computed: true,
					},
				},
				Description: `An object that will contain a ` + "`" + `code` + "`" + ` and a ` + "`" + `message` + "`" + ` when the aliasing fails, otherwise the value will be ` + "`" + `null` + "`" + ``,
			},
			"alias_final": schema.StringAttribute{
				Computed: true,
			},
			"alias_warning": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"action": schema.StringAttribute{
						Computed: true,
					},
					"code": schema.StringAttribute{
						Computed: true,
					},
					"link": schema.StringAttribute{
						Computed: true,
					},
					"message": schema.StringAttribute{
						Computed: true,
					},
				},
			},
			"auto_assign_custom_domains": schema.BoolAttribute{
				Computed: true,
			},
			"automatic_aliases": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
			},
			"booted_at": schema.NumberAttribute{
				Computed: true,
			},
			"build": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"env": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `The keys of the environment variables that were assigned during the build phase.`,
					},
				},
			},
			"build_error_at": schema.NumberAttribute{
				Computed: true,
			},
			"building_at": schema.NumberAttribute{
				Computed: true,
			},
			"canceled_at": schema.NumberAttribute{
				Computed: true,
			},
			"checks_conclusion": schema.StringAttribute{
				Computed:    true,
				Description: `must be one of ["succeeded", "failed", "skipped", "canceled"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"succeeded",
						"failed",
						"skipped",
						"canceled",
					),
				},
			},
			"checks_state": schema.StringAttribute{
				Computed:    true,
				Description: `must be one of ["registered", "running", "completed"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"registered",
						"running",
						"completed",
					),
				},
			},
			"connect_builds_enabled": schema.BoolAttribute{
				Computed:    true,
				Description: `The flag saying if Vercel Connect configuration is used for builds`,
			},
			"connect_configuration_id": schema.StringAttribute{
				Computed:    true,
				Description: `The ID of Vercel Connect configuration used for this deployment`,
			},
			"created_at": schema.NumberAttribute{
				Computed:    true,
				Description: `A number containing the date when the deployment was created in milliseconds`,
			},
			"created_in": schema.StringAttribute{
				Computed:    true,
				Description: `The region where the deployment was first created`,
			},
			"creator": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"avatar": schema.StringAttribute{
						Computed:    true,
						Description: `The avatar of the user that created the deployment`,
					},
					"uid": schema.StringAttribute{
						Computed:    true,
						Description: `The ID of the user that created the deployment`,
					},
					"username": schema.StringAttribute{
						Computed:    true,
						Description: `The username of the user that created the deployment`,
					},
				},
				Description: `Information about the deployment creator`,
			},
			"crons": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"path": schema.StringAttribute{
							Computed: true,
						},
						"schedule": schema.StringAttribute{
							Computed: true,
						},
					},
				},
				Description: `The cron jobs associated with this deployment. Note that preview deployments are also allowed to have this property, but only production deployments create cron jobs. If a preview deployment is promoted to production, only then they'll take effect.`,
			},
			"custom_environment_slug_or_id": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional:    true,
				Description: `Deploy to a custom environment, which will override the default environment. Requires replacement if changed. `,
			},
			"deployment_id": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional:    true,
				Description: `An deployment id for an existing deployment to redeploy. Requires replacement if changed. `,
			},
			"env": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: `The keys of the environment variables that were assigned during runtime`,
			},
			"error_code": schema.StringAttribute{
				Computed: true,
			},
			"error_link": schema.StringAttribute{
				Computed: true,
			},
			"error_message": schema.StringAttribute{
				Computed: true,
			},
			"error_step": schema.StringAttribute{
				Computed: true,
			},
			"files": schema.ListNestedAttribute{
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"inlined_file": schema.SingleNestedAttribute{
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
							},
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"data": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Required:    true,
									Description: `The file content, it could be either a ` + "`" + `base64` + "`" + ` (useful for images, etc.) of the files or the plain content for source code. Requires replacement if changed. `,
								},
								"encoding": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code. Requires replacement if changed. ; must be one of ["base64", "utf-8"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"base64",
											"utf-8",
										),
									},
								},
								"file": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Required:    true,
									Description: `The file name including the whole path. Requires replacement if changed. `,
								},
							},
							Description: `Used in the case you want to inline a file inside the request. Requires replacement if changed. `,
							Validators: []validator.Object{
								objectvalidator.ConflictsWith(path.Expressions{
									path.MatchRelative().AtParent().AtName("uploaded_file"),
								}...),
							},
						},
						"uploaded_file": schema.SingleNestedAttribute{
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplaceIfConfigured(),
							},
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"file": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Required:    true,
									Description: `The file path relative to the project root. Requires replacement if changed. `,
								},
								"sha": schema.StringAttribute{
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The file contents hashed with SHA1, used to check the integrity. Requires replacement if changed. `,
								},
								"size": schema.Int64Attribute{
									PlanModifiers: []planmodifier.Int64{
										int64planmodifier.RequiresReplaceIfConfigured(),
									},
									Optional:    true,
									Description: `The file size in bytes. Requires replacement if changed. `,
								},
							},
							Description: `Used in the case you want to reference a file that was already uploaded. Requires replacement if changed. `,
							Validators: []validator.Object{
								objectvalidator.ConflictsWith(path.Expressions{
									path.MatchRelative().AtParent().AtName("inlined_file"),
								}...),
							},
						},
					},
					Validators: []validator.Object{
						validators.ExactlyOneChild(),
					},
				},
				Description: `A list of objects with the files to be deployed. Requires replacement if changed. `,
			},
			"force_new": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional:    true,
				Description: `Forces a new deployment even if there is a previous similar deployment. Requires replacement if changed. ; must be one of ["0", "1"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"0",
						"1",
					),
				},
			},
			"functions": schema.MapNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"exclude_files": schema.StringAttribute{
							Computed: true,
						},
						"include_files": schema.StringAttribute{
							Computed: true,
						},
						"max_duration": schema.NumberAttribute{
							Computed: true,
						},
						"memory": schema.NumberAttribute{
							Computed: true,
						},
						"runtime": schema.StringAttribute{
							Computed: true,
						},
					},
				},
				Description: `An object used to configure your Serverless Functions`,
			},
			"git_metadata": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"commit_author_name": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `The name of the author of the commit. Requires replacement if changed. `,
					},
					"commit_message": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `The commit message. Requires replacement if changed. `,
					},
					"commit_ref": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `The branch on which the commit was made. Requires replacement if changed. `,
					},
					"commit_sha": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `The hash of the commit. Requires replacement if changed. `,
					},
					"dirty": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Whether or not there have been modifications to the working tree since the latest commit. Requires replacement if changed. `,
					},
					"remote_url": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `The git repository's remote origin url. Requires replacement if changed. `,
					},
				},
				Description: `Populates initial git metadata for different git providers. Requires replacement if changed. `,
			},
			"git_repo": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"one": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"default_branch": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"namespace": schema.StringAttribute{
								Computed: true,
							},
							"owner_type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["user", "team"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"user",
										"team",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed: true,
							},
							"private": schema.BoolAttribute{
								Computed: true,
							},
							"project_id": schema.NumberAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["gitlab"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"gitlab",
									),
								},
							},
							"url": schema.StringAttribute{
								Computed: true,
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("two"),
								path.MatchRelative().AtParent().AtName("three"),
							}...),
						},
					},
					"two": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"default_branch": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"org": schema.StringAttribute{
								Computed: true,
							},
							"owner_type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["user", "team"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"user",
										"team",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed: true,
							},
							"private": schema.BoolAttribute{
								Computed: true,
							},
							"repo": schema.StringAttribute{
								Computed: true,
							},
							"repo_id": schema.NumberAttribute{
								Computed: true,
							},
							"repo_owner_id": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["github"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"github",
									),
								},
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
								path.MatchRelative().AtParent().AtName("three"),
							}...),
						},
					},
					"three": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"default_branch": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"owner": schema.StringAttribute{
								Computed: true,
							},
							"owner_type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["user", "team"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"user",
										"team",
									),
								},
							},
							"path": schema.StringAttribute{
								Computed: true,
							},
							"private": schema.BoolAttribute{
								Computed: true,
							},
							"repo_uuid": schema.StringAttribute{
								Computed: true,
							},
							"slug": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["bitbucket"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"bitbucket",
									),
								},
							},
							"workspace_uuid": schema.StringAttribute{
								Computed: true,
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
								path.MatchRelative().AtParent().AtName("two"),
							}...),
						},
					},
				},
				Validators: []validator.Object{
					validators.ExactlyOneChild(),
				},
			},
			"git_source": schema.SingleNestedAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"one": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"pr_id": schema.NumberAttribute{
								Computed: true,
							},
							"ref": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"repo_id": schema.SingleNestedAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"number": schema.NumberAttribute{
										Computed: true,
										PlanModifiers: []planmodifier.Number{
											numberplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
										},
										Optional:    true,
										Description: `Requires replacement if changed. `,
										Validators: []validator.Number{
											numbervalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("str"),
											}...),
										},
									},
									"str": schema.StringAttribute{
										Computed: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Optional:    true,
										Description: `Requires replacement if changed. `,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("number"),
											}...),
										},
									},
								},
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.Object{
									speakeasy_objectvalidators.NotNull(),
									validators.ExactlyOneChild(),
								},
							},
							"sha": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["github"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"github",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("two"),
								path.MatchRelative().AtParent().AtName("three"),
								path.MatchRelative().AtParent().AtName("four"),
								path.MatchRelative().AtParent().AtName("five"),
								path.MatchRelative().AtParent().AtName("six"),
								path.MatchRelative().AtParent().AtName("seven"),
								path.MatchRelative().AtParent().AtName("eight"),
								path.MatchRelative().AtParent().AtName("nine"),
							}...),
						},
					},
					"two": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"org": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"pr_id": schema.NumberAttribute{
								Computed: true,
							},
							"ref": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"repo": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"sha": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["github"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"github",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
								path.MatchRelative().AtParent().AtName("three"),
								path.MatchRelative().AtParent().AtName("four"),
								path.MatchRelative().AtParent().AtName("five"),
								path.MatchRelative().AtParent().AtName("six"),
								path.MatchRelative().AtParent().AtName("seven"),
								path.MatchRelative().AtParent().AtName("eight"),
								path.MatchRelative().AtParent().AtName("nine"),
							}...),
						},
					},
					"three": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"pr_id": schema.NumberAttribute{
								Computed: true,
							},
							"project_id": schema.SingleNestedAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"number": schema.NumberAttribute{
										Computed: true,
										PlanModifiers: []planmodifier.Number{
											numberplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_numberplanmodifier.SuppressDiff(speakeasy_numberplanmodifier.ExplicitSuppress),
										},
										Optional:    true,
										Description: `Requires replacement if changed. `,
										Validators: []validator.Number{
											numbervalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("str"),
											}...),
										},
									},
									"str": schema.StringAttribute{
										Computed: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Optional:    true,
										Description: `Requires replacement if changed. `,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("number"),
											}...),
										},
									},
								},
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.Object{
									speakeasy_objectvalidators.NotNull(),
									validators.ExactlyOneChild(),
								},
							},
							"ref": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"sha": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["gitlab"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"gitlab",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
								path.MatchRelative().AtParent().AtName("two"),
								path.MatchRelative().AtParent().AtName("four"),
								path.MatchRelative().AtParent().AtName("five"),
								path.MatchRelative().AtParent().AtName("six"),
								path.MatchRelative().AtParent().AtName("seven"),
								path.MatchRelative().AtParent().AtName("eight"),
								path.MatchRelative().AtParent().AtName("nine"),
							}...),
						},
					},
					"four": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"pr_id": schema.NumberAttribute{
								Computed: true,
							},
							"ref": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"repo_uuid": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"sha": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["bitbucket"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"bitbucket",
									),
								},
							},
							"workspace_uuid": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. `,
							},
						},
						Description: `Requires replacement if changed. `,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
								path.MatchRelative().AtParent().AtName("two"),
								path.MatchRelative().AtParent().AtName("three"),
								path.MatchRelative().AtParent().AtName("five"),
								path.MatchRelative().AtParent().AtName("six"),
								path.MatchRelative().AtParent().AtName("seven"),
								path.MatchRelative().AtParent().AtName("eight"),
								path.MatchRelative().AtParent().AtName("nine"),
							}...),
						},
					},
					"five": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"owner": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"pr_id": schema.NumberAttribute{
								Computed: true,
							},
							"ref": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"sha": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. `,
							},
							"slug": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `Requires replacement if changed. ; Not Null; must be one of ["bitbucket"]`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"bitbucket",
									),
								},
							},
						},
						Description: `Requires replacement if changed. `,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
								path.MatchRelative().AtParent().AtName("two"),
								path.MatchRelative().AtParent().AtName("three"),
								path.MatchRelative().AtParent().AtName("four"),
								path.MatchRelative().AtParent().AtName("six"),
								path.MatchRelative().AtParent().AtName("seven"),
								path.MatchRelative().AtParent().AtName("eight"),
								path.MatchRelative().AtParent().AtName("nine"),
							}...),
						},
					},
					"six": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"git_url": schema.StringAttribute{
								Computed: true,
							},
							"ref": schema.StringAttribute{
								Computed: true,
							},
							"sha": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["custom"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"custom",
									),
								},
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
								path.MatchRelative().AtParent().AtName("two"),
								path.MatchRelative().AtParent().AtName("three"),
								path.MatchRelative().AtParent().AtName("four"),
								path.MatchRelative().AtParent().AtName("five"),
								path.MatchRelative().AtParent().AtName("seven"),
								path.MatchRelative().AtParent().AtName("eight"),
								path.MatchRelative().AtParent().AtName("nine"),
							}...),
						},
					},
					"seven": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"org": schema.StringAttribute{
								Computed: true,
							},
							"ref": schema.StringAttribute{
								Computed: true,
							},
							"repo": schema.StringAttribute{
								Computed: true,
							},
							"repo_id": schema.NumberAttribute{
								Computed: true,
							},
							"sha": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["github"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"github",
									),
								},
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
								path.MatchRelative().AtParent().AtName("two"),
								path.MatchRelative().AtParent().AtName("three"),
								path.MatchRelative().AtParent().AtName("four"),
								path.MatchRelative().AtParent().AtName("five"),
								path.MatchRelative().AtParent().AtName("six"),
								path.MatchRelative().AtParent().AtName("eight"),
								path.MatchRelative().AtParent().AtName("nine"),
							}...),
						},
					},
					"eight": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"project_id": schema.NumberAttribute{
								Computed: true,
							},
							"ref": schema.StringAttribute{
								Computed: true,
							},
							"sha": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["gitlab"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"gitlab",
									),
								},
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
								path.MatchRelative().AtParent().AtName("two"),
								path.MatchRelative().AtParent().AtName("three"),
								path.MatchRelative().AtParent().AtName("four"),
								path.MatchRelative().AtParent().AtName("five"),
								path.MatchRelative().AtParent().AtName("six"),
								path.MatchRelative().AtParent().AtName("seven"),
								path.MatchRelative().AtParent().AtName("nine"),
							}...),
						},
					},
					"nine": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"owner": schema.StringAttribute{
								Computed: true,
							},
							"ref": schema.StringAttribute{
								Computed: true,
							},
							"repo_uuid": schema.StringAttribute{
								Computed: true,
							},
							"sha": schema.StringAttribute{
								Computed: true,
							},
							"slug": schema.StringAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["bitbucket"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"bitbucket",
									),
								},
							},
							"workspace_uuid": schema.StringAttribute{
								Computed: true,
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
								path.MatchRelative().AtParent().AtName("two"),
								path.MatchRelative().AtParent().AtName("three"),
								path.MatchRelative().AtParent().AtName("four"),
								path.MatchRelative().AtParent().AtName("five"),
								path.MatchRelative().AtParent().AtName("six"),
								path.MatchRelative().AtParent().AtName("seven"),
								path.MatchRelative().AtParent().AtName("eight"),
							}...),
						},
					},
				},
				Description: `Defines the Git Repository source to be deployed. This property can not be used in combination with ` + "`" + `files` + "`" + `. Requires replacement if changed. `,
				Validators: []validator.Object{
					validators.ExactlyOneChild(),
				},
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `A string holding the unique ID of the deployment`,
			},
			"inspector_url": schema.StringAttribute{
				Computed:    true,
				Description: `Vercel URL to inspect the deployment.`,
			},
			"is_in_concurrent_builds_queue": schema.BoolAttribute{
				Computed:    true,
				Description: `Is the deployment currently queued waiting for a Concurrent Build Slot to be available`,
			},
			"lambdas": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created_at": schema.NumberAttribute{
							Computed: true,
						},
						"entrypoint": schema.StringAttribute{
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"output": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"function_name": schema.StringAttribute{
										Computed: true,
									},
									"path": schema.StringAttribute{
										Computed: true,
									},
								},
							},
						},
						"ready_state": schema.StringAttribute{
							Computed:    true,
							Description: `must be one of ["ERROR", "BUILDING", "INITIALIZING", "READY"]`,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"ERROR",
									"BUILDING",
									"INITIALIZING",
									"READY",
								),
							},
						},
						"ready_state_at": schema.NumberAttribute{
							Computed: true,
						},
					},
				},
			},
			"meta": schema.MapAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Map{
					mapplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_mapplanmodifier.SuppressDiff(speakeasy_mapplanmodifier.ExplicitSuppress),
				},
				Optional:    true,
				ElementType: types.StringType,
				Description: `An object containing the deployment's metadata. Multiple key-value pairs can be attached to a deployment. Requires replacement if changed. `,
			},
			"monorepo_manager": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Optional:    true,
				Description: `The monorepo manager that is being used for this deployment. When ` + "`" + `null` + "`" + ` is used no monorepo manager is selected. Requires replacement if changed. `,
			},
			"name": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Required:    true,
				Description: `A string with the project name used in the deployment URL. Requires replacement if changed. `,
			},
			"one": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"build": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"env": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `The keys of the environment variables that were assigned during the build phase.`,
							},
						},
					},
					"connect_builds_enabled": schema.BoolAttribute{
						Computed:    true,
						Description: `The flag saying if Vercel Connect configuration is used for builds`,
					},
					"connect_configuration_id": schema.StringAttribute{
						Computed:    true,
						Description: `The ID of Vercel Connect configuration used for this deployment`,
					},
					"created_in": schema.StringAttribute{
						Computed:    true,
						Description: `The region where the deployment was first created`,
					},
					"crons": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"schedule": schema.StringAttribute{
									Computed: true,
								},
								"path": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						Description: `The cron jobs associated with this deployment. Note that preview deployments are also allowed to have this property, but only production deployments create cron jobs. If a preview deployment is promoted to production, only then they'll take effect.`,
					},
					"env": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `The keys of the environment variables that were assigned during runtime`,
					},
					"functions": schema.MapNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"memory": schema.NumberAttribute{
									Computed: true,
								},
								"max_duration": schema.NumberAttribute{
									Computed: true,
								},
								"runtime": schema.StringAttribute{
									Computed: true,
								},
								"include_files": schema.StringAttribute{
									Computed: true,
								},
								"exclude_files": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						Description: `An object used to configure your Serverless Functions`,
					},
					"inspector_url": schema.StringAttribute{
						Computed:    true,
						Description: `Vercel URL to inspect the deployment.`,
					},
					"is_in_concurrent_builds_queue": schema.BoolAttribute{
						Computed:    true,
						Description: `Is the deployment currently queued waiting for a Concurrent Build Slot to be available`,
					},
					"meta": schema.MapAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `An object containing the deployment's metadata`,
					},
					"monorepo_manager": schema.StringAttribute{
						Computed:    true,
						Description: `An monorepo manager that was used for the deployment`,
					},
					"name": schema.StringAttribute{
						Computed:    true,
						Description: `The name of the project associated with the deployment at the time that the deployment was created`,
					},
					"owner_id": schema.StringAttribute{
						Computed:    true,
						Description: `The unique ID of the user or team the deployment belongs to`,
					},
					"passive_connect_configuration_id": schema.StringAttribute{
						Computed:    true,
						Description: `The connect configuration ID used to deploy passive lambdas into for secure compute enabled deployments.`,
					},
					"plan": schema.StringAttribute{
						Computed:    true,
						Description: `The pricing plan the deployment was made under. must be one of ["pro", "enterprise", "hobby"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"pro",
								"enterprise",
								"hobby",
							),
						},
					},
					"project_id": schema.StringAttribute{
						Computed:    true,
						Description: `The ID of the project the deployment is associated with`,
					},
					"routes": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"one": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"src": schema.StringAttribute{
											Computed: true,
										},
										"dest": schema.StringAttribute{
											Computed: true,
										},
										"headers": schema.MapAttribute{
											Computed:    true,
											ElementType: types.StringType,
										},
										"methods": schema.ListAttribute{
											Computed:    true,
											ElementType: types.StringType,
										},
										"continue": schema.BoolAttribute{
											Computed: true,
										},
										"override": schema.BoolAttribute{
											Computed: true,
										},
										"case_sensitive": schema.BoolAttribute{
											Computed: true,
										},
										"check": schema.BoolAttribute{
											Computed: true,
										},
										"important": schema.BoolAttribute{
											Computed: true,
										},
										"status": schema.NumberAttribute{
											Computed: true,
										},
										"has": schema.ListNestedAttribute{
											Computed: true,
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"one": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"type": schema.StringAttribute{
																Computed:    true,
																Description: `must be one of ["host"]`,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"host",
																	),
																},
															},
															"value": schema.StringAttribute{
																Computed: true,
															},
														},
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("two"),
															}...),
														},
													},
													"two": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"type": schema.StringAttribute{
																Computed:    true,
																Description: `must be one of ["header", "cookie", "query"]`,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"header",
																		"cookie",
																		"query",
																	),
																},
															},
															"key": schema.StringAttribute{
																Computed: true,
															},
															"value": schema.StringAttribute{
																Computed: true,
															},
														},
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("one"),
															}...),
														},
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
										},
										"missing": schema.ListNestedAttribute{
											Computed: true,
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"one": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"type": schema.StringAttribute{
																Computed:    true,
																Description: `must be one of ["host"]`,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"host",
																	),
																},
															},
															"value": schema.StringAttribute{
																Computed: true,
															},
														},
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("two"),
															}...),
														},
													},
													"two": schema.SingleNestedAttribute{
														Computed: true,
														Attributes: map[string]schema.Attribute{
															"type": schema.StringAttribute{
																Computed:    true,
																Description: `must be one of ["header", "cookie", "query"]`,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"header",
																		"cookie",
																		"query",
																	),
																},
															},
															"key": schema.StringAttribute{
																Computed: true,
															},
															"value": schema.StringAttribute{
																Computed: true,
															},
														},
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("one"),
															}...),
														},
													},
												},
												Validators: []validator.Object{
													validators.ExactlyOneChild(),
												},
											},
										},
										"locale": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"redirect": schema.MapAttribute{
													Computed:    true,
													ElementType: types.StringType,
												},
												"cookie": schema.StringAttribute{
													Computed: true,
												},
											},
										},
										"middleware_path": schema.StringAttribute{
											Computed:    true,
											Description: `A middleware key within the ` + "`" + `output` + "`" + ` key under the build result. Overrides a ` + "`" + `middleware` + "`" + ` definition.`,
										},
										"middleware_raw_src": schema.ListAttribute{
											Computed:    true,
											ElementType: types.StringType,
											Description: `The original middleware matchers.`,
										},
										"middleware": schema.NumberAttribute{
											Computed:    true,
											Description: `A middleware index in the ` + "`" + `middleware` + "`" + ` key under the build result`,
										},
									},
									Description: `A list of routes objects used to rewrite paths to point towards other internal or external paths`,
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
										}...),
									},
								},
								"two": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"handle": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["error", "filesystem", "hit", "miss", "rewrite", "resource"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"error",
													"filesystem",
													"hit",
													"miss",
													"rewrite",
													"resource",
												),
											},
										},
										"src": schema.StringAttribute{
											Computed: true,
										},
										"dest": schema.StringAttribute{
											Computed: true,
										},
										"status": schema.NumberAttribute{
											Computed: true,
										},
									},
									Description: `A list of routes objects used to rewrite paths to point towards other internal or external paths`,
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("three"),
										}...),
									},
								},
								"three": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"src": schema.StringAttribute{
											Computed: true,
										},
										"continue": schema.BoolAttribute{
											Computed: true,
										},
										"middleware": schema.NumberAttribute{
											Computed: true,
										},
									},
									Description: `A list of routes objects used to rewrite paths to point towards other internal or external paths`,
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("two"),
										}...),
									},
								},
							},
							Validators: []validator.Object{
								validators.ExactlyOneChild(),
							},
						},
						Description: `A list of routes objects used to rewrite paths to point towards other internal or external paths`,
					},
					"git_repo": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"one": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"namespace": schema.StringAttribute{
										Computed: true,
									},
									"project_id": schema.NumberAttribute{
										Computed: true,
									},
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["gitlab"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"gitlab",
											),
										},
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
									"path": schema.StringAttribute{
										Computed: true,
									},
									"default_branch": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"private": schema.BoolAttribute{
										Computed: true,
									},
									"owner_type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["team", "user"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"team",
												"user",
											),
										},
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
									}...),
								},
							},
							"two": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"org": schema.StringAttribute{
										Computed: true,
									},
									"repo": schema.StringAttribute{
										Computed: true,
									},
									"repo_id": schema.NumberAttribute{
										Computed: true,
									},
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["github"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"github",
											),
										},
									},
									"repo_owner_id": schema.StringAttribute{
										Computed: true,
									},
									"path": schema.StringAttribute{
										Computed: true,
									},
									"default_branch": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"private": schema.BoolAttribute{
										Computed: true,
									},
									"owner_type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["team", "user"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"team",
												"user",
											),
										},
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("three"),
									}...),
								},
							},
							"three": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"owner": schema.StringAttribute{
										Computed: true,
									},
									"repo_uuid": schema.StringAttribute{
										Computed: true,
									},
									"slug": schema.StringAttribute{
										Computed: true,
									},
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["bitbucket"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"bitbucket",
											),
										},
									},
									"workspace_uuid": schema.StringAttribute{
										Computed: true,
									},
									"path": schema.StringAttribute{
										Computed: true,
									},
									"default_branch": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"private": schema.BoolAttribute{
										Computed: true,
									},
									"owner_type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["team", "user"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"team",
												"user",
											),
										},
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
									}...),
								},
							},
						},
						Validators: []validator.Object{
							validators.ExactlyOneChild(),
						},
					},
					"alias_assigned_at": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"number": schema.NumberAttribute{
								Computed: true,
								Validators: []validator.Number{
									numbervalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("boolean"),
									}...),
								},
							},
							"boolean": schema.BoolAttribute{
								Computed: true,
								Validators: []validator.Bool{
									boolvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("number"),
									}...),
								},
							},
						},
						Validators: []validator.Object{
							validators.ExactlyOneChild(),
						},
					},
					"lambdas": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Computed: true,
								},
								"created_at": schema.NumberAttribute{
									Computed: true,
								},
								"entrypoint": schema.StringAttribute{
									Computed: true,
								},
								"ready_state": schema.StringAttribute{
									Computed:    true,
									Description: `must be one of ["BUILDING", "ERROR", "INITIALIZING", "READY"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"BUILDING",
											"ERROR",
											"INITIALIZING",
											"READY",
										),
									},
								},
								"ready_state_at": schema.NumberAttribute{
									Computed: true,
								},
								"output": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"path": schema.StringAttribute{
												Computed: true,
											},
											"function_name": schema.StringAttribute{
												Computed: true,
											},
										},
									},
								},
							},
						},
					},
					"project": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"framework": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The public project information associated with the deployment.`,
					},
					"public": schema.BoolAttribute{
						Computed:    true,
						Description: `A boolean representing if the deployment is public or not. By default this is ` + "`" + `false` + "`" + ``,
					},
					"ready_state": schema.StringAttribute{
						Computed:    true,
						Description: `The state of the deployment depending on the process of deploying, or if it is ready or in an error state. must be one of ["QUEUED", "BUILDING", "ERROR", "INITIALIZING", "READY", "CANCELED"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"QUEUED",
								"BUILDING",
								"ERROR",
								"INITIALIZING",
								"READY",
								"CANCELED",
							),
						},
					},
					"ready_substate": schema.StringAttribute{
						Computed:    true,
						Description: `The substate of the deployment when the state is "READY". must be one of ["STAGED", "PROMOTED"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"STAGED",
								"PROMOTED",
							),
						},
					},
					"regions": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `The regions the deployment exists in`,
					},
					"source": schema.StringAttribute{
						Computed:    true,
						Description: `Where was the deployment created from. must be one of ["api-trigger-git-deploy", "cli", "clone/repo", "git", "import", "import/repo"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"api-trigger-git-deploy",
								"cli",
								"clone/repo",
								"git",
								"import",
								"import/repo",
							),
						},
					},
					"target": schema.StringAttribute{
						Computed:    true,
						Description: `If defined, either ` + "`" + `staging` + "`" + ` if a staging alias in the format ` + "`" + `<project>.<team>.now.sh` + "`" + ` was assigned upon creation, or ` + "`" + `production` + "`" + ` if the aliases from ` + "`" + `alias` + "`" + ` were assigned. must be one of ["staging", "production"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"staging",
								"production",
							),
						},
					},
					"team": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `The ID of the team owner`,
							},
							"name": schema.StringAttribute{
								Computed:    true,
								Description: `The name of the team owner`,
							},
							"slug": schema.StringAttribute{
								Computed:    true,
								Description: `The slug of the team owner`,
							},
							"avatar": schema.StringAttribute{
								Computed:    true,
								Description: `The avatar of the team owner`,
							},
						},
						Description: `The team that owns the deployment if any`,
					},
					"type": schema.StringAttribute{
						Computed:    true,
						Description: `must be one of ["LAMBDAS"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"LAMBDAS",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed:    true,
						Description: `A string with the unique URL of the deployment`,
					},
					"user_aliases": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `An array of domains that were provided by the user when creating the Deployment.`,
					},
					"version": schema.NumberAttribute{
						Computed:    true,
						Description: `The platform version that was used to create the deployment.`,
					},
					"preview_comments_enabled": schema.BoolAttribute{
						Computed:    true,
						Description: `Whether or not preview comments are enabled for the deployment`,
					},
					"alias": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation`,
					},
					"alias_assigned": schema.BoolAttribute{
						Computed:    true,
						Description: `A boolean that will be true when the aliases from the alias property were assigned successfully`,
					},
					"alias_error": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"code": schema.StringAttribute{
								Computed: true,
							},
							"message": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `An object that will contain a ` + "`" + `code` + "`" + ` and a ` + "`" + `message` + "`" + ` when the aliasing fails, otherwise the value will be ` + "`" + `null` + "`" + ``,
					},
					"alias_final": schema.StringAttribute{
						Computed: true,
					},
					"alias_warning": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"code": schema.StringAttribute{
								Computed: true,
							},
							"message": schema.StringAttribute{
								Computed: true,
							},
							"link": schema.StringAttribute{
								Computed: true,
							},
							"action": schema.StringAttribute{
								Computed: true,
							},
						},
					},
					"auto_assign_custom_domains": schema.BoolAttribute{
						Computed: true,
					},
					"automatic_aliases": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"booted_at": schema.NumberAttribute{
						Computed: true,
					},
					"build_error_at": schema.NumberAttribute{
						Computed: true,
					},
					"building_at": schema.NumberAttribute{
						Computed: true,
					},
					"canceled_at": schema.NumberAttribute{
						Computed: true,
					},
					"checks_state": schema.StringAttribute{
						Computed:    true,
						Description: `must be one of ["registered", "running", "completed"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"registered",
								"running",
								"completed",
							),
						},
					},
					"checks_conclusion": schema.StringAttribute{
						Computed:    true,
						Description: `must be one of ["succeeded", "failed", "skipped", "canceled"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"succeeded",
								"failed",
								"skipped",
								"canceled",
							),
						},
					},
					"created_at": schema.NumberAttribute{
						Computed:    true,
						Description: `A number containing the date when the deployment was created in milliseconds`,
					},
					"creator": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"uid": schema.StringAttribute{
								Computed:    true,
								Description: `The ID of the user that created the deployment`,
							},
							"username": schema.StringAttribute{
								Computed:    true,
								Description: `The username of the user that created the deployment`,
							},
							"avatar": schema.StringAttribute{
								Computed:    true,
								Description: `The avatar of the user that created the deployment`,
							},
						},
						Description: `Information about the deployment creator`,
					},
					"error_code": schema.StringAttribute{
						Computed: true,
					},
					"error_link": schema.StringAttribute{
						Computed: true,
					},
					"error_message": schema.StringAttribute{
						Computed: true,
					},
					"error_step": schema.StringAttribute{
						Computed: true,
					},
					"passive_regions": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"git_source": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"one": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["github"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"github",
											),
										},
									},
									"repo_id": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"str": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("number"),
													}...),
												},
											},
											"number": schema.NumberAttribute{
												Computed: true,
												Validators: []validator.Number{
													numbervalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("str"),
													}...),
												},
											},
										},
										Validators: []validator.Object{
											validators.ExactlyOneChild(),
										},
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"pr_id": schema.NumberAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"two": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["github"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"github",
											),
										},
									},
									"org": schema.StringAttribute{
										Computed: true,
									},
									"repo": schema.StringAttribute{
										Computed: true,
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"pr_id": schema.NumberAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"three": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["gitlab"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"gitlab",
											),
										},
									},
									"project_id": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"str": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("number"),
													}...),
												},
											},
											"number": schema.NumberAttribute{
												Computed: true,
												Validators: []validator.Number{
													numbervalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("str"),
													}...),
												},
											},
										},
										Validators: []validator.Object{
											validators.ExactlyOneChild(),
										},
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"pr_id": schema.NumberAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"four": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["bitbucket"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"bitbucket",
											),
										},
									},
									"workspace_uuid": schema.StringAttribute{
										Computed: true,
									},
									"repo_uuid": schema.StringAttribute{
										Computed: true,
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"pr_id": schema.NumberAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"five": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["bitbucket"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"bitbucket",
											),
										},
									},
									"owner": schema.StringAttribute{
										Computed: true,
									},
									"slug": schema.StringAttribute{
										Computed: true,
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"pr_id": schema.NumberAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"six": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["custom"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"custom",
											),
										},
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"git_url": schema.StringAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"seven": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["github"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"github",
											),
										},
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"repo_id": schema.NumberAttribute{
										Computed: true,
									},
									"org": schema.StringAttribute{
										Computed: true,
									},
									"repo": schema.StringAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"eight": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["gitlab"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"gitlab",
											),
										},
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"project_id": schema.NumberAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"nine": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["bitbucket"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"bitbucket",
											),
										},
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"owner": schema.StringAttribute{
										Computed: true,
									},
									"slug": schema.StringAttribute{
										Computed: true,
									},
									"workspace_uuid": schema.StringAttribute{
										Computed: true,
									},
									"repo_uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
									}...),
								},
							},
						},
						Validators: []validator.Object{
							validators.ExactlyOneChild(),
						},
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Description: `A string holding the unique ID of the deployment`,
					},
				},
				Description: `The deployment including both public and private information`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("two"),
					}...),
				},
			},
			"owner_id": schema.StringAttribute{
				Computed:    true,
				Description: `The unique ID of the user or team the deployment belongs to`,
			},
			"passive_connect_configuration_id": schema.StringAttribute{
				Computed:    true,
				Description: `The connect configuration ID used to deploy passive lambdas into for secure compute enabled deployments.`,
			},
			"passive_regions": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
			},
			"plan": schema.StringAttribute{
				Computed:    true,
				Description: `The pricing plan the deployment was made under. must be one of ["pro", "enterprise", "hobby"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"pro",
						"enterprise",
						"hobby",
					),
				},
			},
			"preview_comments_enabled": schema.BoolAttribute{
				Computed:    true,
				Description: `Whether or not preview comments are enabled for the deployment`,
			},
			"project": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional:    true,
				Description: `The target project identifier in which the deployment will be created. When defined, this parameter overrides name. Requires replacement if changed. `,
			},
			"project_id": schema.StringAttribute{
				Computed:    true,
				Description: `The ID of the project the deployment is associated with`,
			},
			"project_obj": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"framework": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
				},
				Description: `The public project information associated with the deployment.`,
			},
			"project_settings": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"build_command": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `The build command for this project. When ` + "`" + `null` + "`" + ` is used this value will be automatically detected. Requires replacement if changed. `,
					},
					"command_for_ignoring_build_step": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Requires replacement if changed. `,
					},
					"dev_command": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `The dev command for this project. When ` + "`" + `null` + "`" + ` is used this value will be automatically detected. Requires replacement if changed. `,
					},
					"framework": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `The framework that is being used for this project. When ` + "`" + `null` + "`" + ` is used no framework is selected. Requires replacement if changed. ; must be one of ["blitzjs", "nextjs", "gatsby", "remix", "astro", "hexo", "eleventy", "docusaurus-2", "docusaurus", "preact", "solidstart-1", "solidstart", "dojo", "ember", "vue", "scully", "ionic-angular", "angular", "polymer", "svelte", "sveltekit", "sveltekit-1", "ionic-react", "create-react-app", "gridsome", "umijs", "sapper", "saber", "stencil", "nuxtjs", "redwoodjs", "hugo", "jekyll", "brunch", "middleman", "zola", "hydrogen", "vite", "vitepress", "vuepress", "parcel", "sanity", "storybook"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"blitzjs",
								"nextjs",
								"gatsby",
								"remix",
								"astro",
								"hexo",
								"eleventy",
								"docusaurus-2",
								"docusaurus",
								"preact",
								"solidstart-1",
								"solidstart",
								"dojo",
								"ember",
								"vue",
								"scully",
								"ionic-angular",
								"angular",
								"polymer",
								"svelte",
								"sveltekit",
								"sveltekit-1",
								"ionic-react",
								"create-react-app",
								"gridsome",
								"umijs",
								"sapper",
								"saber",
								"stencil",
								"nuxtjs",
								"redwoodjs",
								"hugo",
								"jekyll",
								"brunch",
								"middleman",
								"zola",
								"hydrogen",
								"vite",
								"vitepress",
								"vuepress",
								"parcel",
								"sanity",
								"storybook",
							),
						},
					},
					"install_command": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `The install command for this project. When ` + "`" + `null` + "`" + ` is used this value will be automatically detected. Requires replacement if changed. `,
					},
					"node_version": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Override the Node.js version that should be used for this deployment. Requires replacement if changed. ; must be one of ["20.x", "18.x", "16.x"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"20.x",
								"18.x",
								"16.x",
							),
						},
					},
					"output_directory": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `The output directory of the project. When ` + "`" + `null` + "`" + ` is used this value will be automatically detected. Requires replacement if changed. `,
					},
					"root_directory": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `The name of a directory or relative path to the source code of your project. When ` + "`" + `null` + "`" + ` is used it will default to the project root. Requires replacement if changed. `,
					},
					"serverless_function_region": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `The region to deploy Serverless Functions in this project. Requires replacement if changed. `,
					},
					"skip_git_connect_during_link": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Opts-out of the message prompting a CLI user to connect a Git repository in ` + "`" + `vercel link` + "`" + `. Requires replacement if changed. `,
					},
					"source_files_outside_root_directory": schema.BoolAttribute{
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
						},
						Optional:    true,
						Description: `Indicates if there are source files outside of the root directory, typically used for monorepos. Requires replacement if changed. `,
					},
				},
				Description: `Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments. Requires replacement if changed. `,
			},
			"public": schema.BoolAttribute{
				Computed:    true,
				Description: `A boolean representing if the deployment is public or not. By default this is ` + "`" + `false` + "`" + ``,
			},
			"ready_state": schema.StringAttribute{
				Computed:    true,
				Description: `The state of the deployment depending on the process of deploying, or if it is ready or in an error state. must be one of ["CANCELED", "ERROR", "QUEUED", "BUILDING", "INITIALIZING", "READY"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"CANCELED",
						"ERROR",
						"QUEUED",
						"BUILDING",
						"INITIALIZING",
						"READY",
					),
				},
			},
			"ready_substate": schema.StringAttribute{
				Computed:    true,
				Description: `The substate of the deployment when the state is "READY". must be one of ["STAGED", "PROMOTED"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"STAGED",
						"PROMOTED",
					),
				},
			},
			"regions": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: `The regions the deployment exists in`,
			},
			"routes": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"one": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"case_sensitive": schema.BoolAttribute{
									Computed: true,
								},
								"check": schema.BoolAttribute{
									Computed: true,
								},
								"continue": schema.BoolAttribute{
									Computed: true,
								},
								"dest": schema.StringAttribute{
									Computed: true,
								},
								"has": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"one": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"type": schema.StringAttribute{
														Computed:    true,
														Description: `must be one of ["host"]`,
														Validators: []validator.String{
															stringvalidator.OneOf(
																"host",
															),
														},
													},
													"value": schema.StringAttribute{
														Computed: true,
													},
												},
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("two"),
													}...),
												},
											},
											"two": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"key": schema.StringAttribute{
														Computed: true,
													},
													"type": schema.StringAttribute{
														Computed:    true,
														Description: `must be one of ["header", "cookie", "query"]`,
														Validators: []validator.String{
															stringvalidator.OneOf(
																"header",
																"cookie",
																"query",
															),
														},
													},
													"value": schema.StringAttribute{
														Computed: true,
													},
												},
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("one"),
													}...),
												},
											},
										},
										Validators: []validator.Object{
											validators.ExactlyOneChild(),
										},
									},
								},
								"headers": schema.MapAttribute{
									Computed:    true,
									ElementType: types.StringType,
								},
								"important": schema.BoolAttribute{
									Computed: true,
								},
								"locale": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"cookie": schema.StringAttribute{
											Computed: true,
										},
										"redirect": schema.MapAttribute{
											Computed:    true,
											ElementType: types.StringType,
										},
									},
								},
								"methods": schema.ListAttribute{
									Computed:    true,
									ElementType: types.StringType,
								},
								"middleware": schema.NumberAttribute{
									Computed:    true,
									Description: `A middleware index in the ` + "`" + `middleware` + "`" + ` key under the build result`,
								},
								"middleware_path": schema.StringAttribute{
									Computed:    true,
									Description: `A middleware key within the ` + "`" + `output` + "`" + ` key under the build result. Overrides a ` + "`" + `middleware` + "`" + ` definition.`,
								},
								"middleware_raw_src": schema.ListAttribute{
									Computed:    true,
									ElementType: types.StringType,
									Description: `The original middleware matchers.`,
								},
								"missing": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"one": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"type": schema.StringAttribute{
														Computed:    true,
														Description: `must be one of ["host"]`,
														Validators: []validator.String{
															stringvalidator.OneOf(
																"host",
															),
														},
													},
													"value": schema.StringAttribute{
														Computed: true,
													},
												},
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("two"),
													}...),
												},
											},
											"two": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"key": schema.StringAttribute{
														Computed: true,
													},
													"type": schema.StringAttribute{
														Computed:    true,
														Description: `must be one of ["header", "cookie", "query"]`,
														Validators: []validator.String{
															stringvalidator.OneOf(
																"header",
																"cookie",
																"query",
															),
														},
													},
													"value": schema.StringAttribute{
														Computed: true,
													},
												},
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("one"),
													}...),
												},
											},
										},
										Validators: []validator.Object{
											validators.ExactlyOneChild(),
										},
									},
								},
								"override": schema.BoolAttribute{
									Computed: true,
								},
								"src": schema.StringAttribute{
									Computed: true,
								},
								"status": schema.NumberAttribute{
									Computed: true,
								},
							},
							Description: `A list of routes objects used to rewrite paths to point towards other internal or external paths`,
							Validators: []validator.Object{
								objectvalidator.ConflictsWith(path.Expressions{
									path.MatchRelative().AtParent().AtName("two"),
									path.MatchRelative().AtParent().AtName("three"),
								}...),
							},
						},
						"two": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"dest": schema.StringAttribute{
									Computed: true,
								},
								"handle": schema.StringAttribute{
									Computed:    true,
									Description: `must be one of ["error", "filesystem", "hit", "miss", "resource", "rewrite"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"error",
											"filesystem",
											"hit",
											"miss",
											"resource",
											"rewrite",
										),
									},
								},
								"src": schema.StringAttribute{
									Computed: true,
								},
								"status": schema.NumberAttribute{
									Computed: true,
								},
							},
							Description: `A list of routes objects used to rewrite paths to point towards other internal or external paths`,
							Validators: []validator.Object{
								objectvalidator.ConflictsWith(path.Expressions{
									path.MatchRelative().AtParent().AtName("one"),
									path.MatchRelative().AtParent().AtName("three"),
								}...),
							},
						},
						"three": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"continue": schema.BoolAttribute{
									Computed: true,
								},
								"middleware": schema.NumberAttribute{
									Computed: true,
								},
								"src": schema.StringAttribute{
									Computed: true,
								},
							},
							Description: `A list of routes objects used to rewrite paths to point towards other internal or external paths`,
							Validators: []validator.Object{
								objectvalidator.ConflictsWith(path.Expressions{
									path.MatchRelative().AtParent().AtName("one"),
									path.MatchRelative().AtParent().AtName("two"),
								}...),
							},
						},
					},
					Validators: []validator.Object{
						validators.ExactlyOneChild(),
					},
				},
				Description: `A list of routes objects used to rewrite paths to point towards other internal or external paths`,
			},
			"skip_auto_detection_confirmation": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional:    true,
				Description: `Allows to skip framework detection so the API would not fail to ask for confirmation. Requires replacement if changed. ; must be one of ["0", "1"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"0",
						"1",
					),
				},
			},
			"slug": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional:    true,
				Description: `The Team slug to perform the request on behalf of. Requires replacement if changed. `,
			},
			"source": schema.StringAttribute{
				Computed:    true,
				Description: `Where was the deployment created from. must be one of ["cli", "git", "import", "import/repo", "clone/repo", "api-trigger-git-deploy"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"cli",
						"git",
						"import",
						"import/repo",
						"clone/repo",
						"api-trigger-git-deploy",
					),
				},
			},
			"target": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Optional:    true,
				Description: `Either not defined, ` + "`" + `staging` + "`" + `, or ` + "`" + `production` + "`" + `. If ` + "`" + `staging` + "`" + `, a staging alias in the format ` + "`" + `<project>-<team>.vercel.app` + "`" + ` will be assigned. If ` + "`" + `production` + "`" + `, any aliases defined in ` + "`" + `alias` + "`" + ` will be assigned. If omitted, the target will be ` + "`" + `preview` + "`" + `. Requires replacement if changed. ; must be one of ["staging", "production"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"staging",
						"production",
					),
				},
			},
			"team": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"avatar": schema.StringAttribute{
						Computed:    true,
						Description: `The avatar of the team owner`,
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Description: `The ID of the team owner`,
					},
					"name": schema.StringAttribute{
						Computed:    true,
						Description: `The name of the team owner`,
					},
					"slug": schema.StringAttribute{
						Computed:    true,
						Description: `The slug of the team owner`,
					},
				},
				Description: `The team that owns the deployment if any`,
			},
			"team_id": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional:    true,
				Description: `The Team identifier to perform the request on behalf of. Requires replacement if changed. `,
			},
			"two": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"lambdas": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Computed: true,
								},
								"created_at": schema.NumberAttribute{
									Computed: true,
								},
								"entrypoint": schema.StringAttribute{
									Computed: true,
								},
								"ready_state": schema.StringAttribute{
									Computed:    true,
									Description: `must be one of ["BUILDING", "ERROR", "INITIALIZING", "READY"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"BUILDING",
											"ERROR",
											"INITIALIZING",
											"READY",
										),
									},
								},
								"ready_state_at": schema.NumberAttribute{
									Computed: true,
								},
								"output": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"path": schema.StringAttribute{
												Computed: true,
											},
											"function_name": schema.StringAttribute{
												Computed: true,
											},
										},
									},
								},
							},
						},
					},
					"name": schema.StringAttribute{
						Computed:    true,
						Description: `The name of the project associated with the deployment at the time that the deployment was created`,
					},
					"meta": schema.MapAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `An object containing the deployment's metadata`,
					},
					"project": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"framework": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `The public project information associated with the deployment.`,
					},
					"public": schema.BoolAttribute{
						Computed:    true,
						Description: `A boolean representing if the deployment is public or not. By default this is ` + "`" + `false` + "`" + ``,
					},
					"ready_state": schema.StringAttribute{
						Computed:    true,
						Description: `The state of the deployment depending on the process of deploying, or if it is ready or in an error state. must be one of ["QUEUED", "BUILDING", "ERROR", "INITIALIZING", "READY", "CANCELED"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"QUEUED",
								"BUILDING",
								"ERROR",
								"INITIALIZING",
								"READY",
								"CANCELED",
							),
						},
					},
					"ready_substate": schema.StringAttribute{
						Computed:    true,
						Description: `The substate of the deployment when the state is "READY". must be one of ["STAGED", "PROMOTED"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"STAGED",
								"PROMOTED",
							),
						},
					},
					"regions": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `The regions the deployment exists in`,
					},
					"source": schema.StringAttribute{
						Computed:    true,
						Description: `Where was the deployment created from. must be one of ["api-trigger-git-deploy", "cli", "clone/repo", "git", "import", "import/repo"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"api-trigger-git-deploy",
								"cli",
								"clone/repo",
								"git",
								"import",
								"import/repo",
							),
						},
					},
					"target": schema.StringAttribute{
						Computed:    true,
						Description: `If defined, either ` + "`" + `staging` + "`" + ` if a staging alias in the format ` + "`" + `<project>.<team>.now.sh` + "`" + ` was assigned upon creation, or ` + "`" + `production` + "`" + ` if the aliases from ` + "`" + `alias` + "`" + ` were assigned. must be one of ["staging", "production"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"staging",
								"production",
							),
						},
					},
					"team": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Computed:    true,
								Description: `The ID of the team owner`,
							},
							"name": schema.StringAttribute{
								Computed:    true,
								Description: `The name of the team owner`,
							},
							"slug": schema.StringAttribute{
								Computed:    true,
								Description: `The slug of the team owner`,
							},
							"avatar": schema.StringAttribute{
								Computed:    true,
								Description: `The avatar of the team owner`,
							},
						},
						Description: `The team that owns the deployment if any`,
					},
					"type": schema.StringAttribute{
						Computed:    true,
						Description: `must be one of ["LAMBDAS"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"LAMBDAS",
							),
						},
					},
					"url": schema.StringAttribute{
						Computed:    true,
						Description: `A string with the unique URL of the deployment`,
					},
					"user_aliases": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `An array of domains that were provided by the user when creating the Deployment.`,
					},
					"version": schema.NumberAttribute{
						Computed:    true,
						Description: `The platform version that was used to create the deployment.`,
					},
					"preview_comments_enabled": schema.BoolAttribute{
						Computed:    true,
						Description: `Whether or not preview comments are enabled for the deployment`,
					},
					"alias": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation`,
					},
					"alias_assigned": schema.BoolAttribute{
						Computed:    true,
						Description: `A boolean that will be true when the aliases from the alias property were assigned successfully`,
					},
					"alias_error": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"code": schema.StringAttribute{
								Computed: true,
							},
							"message": schema.StringAttribute{
								Computed: true,
							},
						},
						Description: `An object that will contain a ` + "`" + `code` + "`" + ` and a ` + "`" + `message` + "`" + ` when the aliasing fails, otherwise the value will be ` + "`" + `null` + "`" + ``,
					},
					"alias_final": schema.StringAttribute{
						Computed: true,
					},
					"alias_warning": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"code": schema.StringAttribute{
								Computed: true,
							},
							"message": schema.StringAttribute{
								Computed: true,
							},
							"link": schema.StringAttribute{
								Computed: true,
							},
							"action": schema.StringAttribute{
								Computed: true,
							},
						},
					},
					"auto_assign_custom_domains": schema.BoolAttribute{
						Computed: true,
					},
					"automatic_aliases": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"booted_at": schema.NumberAttribute{
						Computed: true,
					},
					"build_error_at": schema.NumberAttribute{
						Computed: true,
					},
					"building_at": schema.NumberAttribute{
						Computed: true,
					},
					"canceled_at": schema.NumberAttribute{
						Computed: true,
					},
					"checks_state": schema.StringAttribute{
						Computed:    true,
						Description: `must be one of ["registered", "running", "completed"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"registered",
								"running",
								"completed",
							),
						},
					},
					"checks_conclusion": schema.StringAttribute{
						Computed:    true,
						Description: `must be one of ["succeeded", "failed", "skipped", "canceled"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"succeeded",
								"failed",
								"skipped",
								"canceled",
							),
						},
					},
					"created_at": schema.NumberAttribute{
						Computed:    true,
						Description: `A number containing the date when the deployment was created in milliseconds`,
					},
					"creator": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"uid": schema.StringAttribute{
								Computed:    true,
								Description: `The ID of the user that created the deployment`,
							},
							"username": schema.StringAttribute{
								Computed:    true,
								Description: `The username of the user that created the deployment`,
							},
							"avatar": schema.StringAttribute{
								Computed:    true,
								Description: `The avatar of the user that created the deployment`,
							},
						},
						Description: `Information about the deployment creator`,
					},
					"error_code": schema.StringAttribute{
						Computed: true,
					},
					"error_link": schema.StringAttribute{
						Computed: true,
					},
					"error_message": schema.StringAttribute{
						Computed: true,
					},
					"error_step": schema.StringAttribute{
						Computed: true,
					},
					"passive_regions": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"git_source": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"one": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["github"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"github",
											),
										},
									},
									"repo_id": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"str": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("number"),
													}...),
												},
											},
											"number": schema.NumberAttribute{
												Computed: true,
												Validators: []validator.Number{
													numbervalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("str"),
													}...),
												},
											},
										},
										Validators: []validator.Object{
											validators.ExactlyOneChild(),
										},
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"pr_id": schema.NumberAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"two": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["github"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"github",
											),
										},
									},
									"org": schema.StringAttribute{
										Computed: true,
									},
									"repo": schema.StringAttribute{
										Computed: true,
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"pr_id": schema.NumberAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"three": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["gitlab"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"gitlab",
											),
										},
									},
									"project_id": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"str": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													stringvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("number"),
													}...),
												},
											},
											"number": schema.NumberAttribute{
												Computed: true,
												Validators: []validator.Number{
													numbervalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("str"),
													}...),
												},
											},
										},
										Validators: []validator.Object{
											validators.ExactlyOneChild(),
										},
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"pr_id": schema.NumberAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"four": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["bitbucket"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"bitbucket",
											),
										},
									},
									"workspace_uuid": schema.StringAttribute{
										Computed: true,
									},
									"repo_uuid": schema.StringAttribute{
										Computed: true,
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"pr_id": schema.NumberAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"five": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["bitbucket"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"bitbucket",
											),
										},
									},
									"owner": schema.StringAttribute{
										Computed: true,
									},
									"slug": schema.StringAttribute{
										Computed: true,
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"pr_id": schema.NumberAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"six": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["custom"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"custom",
											),
										},
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"git_url": schema.StringAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"seven": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["github"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"github",
											),
										},
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"repo_id": schema.NumberAttribute{
										Computed: true,
									},
									"org": schema.StringAttribute{
										Computed: true,
									},
									"repo": schema.StringAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("eight"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"eight": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["gitlab"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"gitlab",
											),
										},
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"project_id": schema.NumberAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("nine"),
									}...),
								},
							},
							"nine": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Computed:    true,
										Description: `must be one of ["bitbucket"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"bitbucket",
											),
										},
									},
									"ref": schema.StringAttribute{
										Computed: true,
									},
									"sha": schema.StringAttribute{
										Computed: true,
									},
									"owner": schema.StringAttribute{
										Computed: true,
									},
									"slug": schema.StringAttribute{
										Computed: true,
									},
									"workspace_uuid": schema.StringAttribute{
										Computed: true,
									},
									"repo_uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								Validators: []validator.Object{
									objectvalidator.ConflictsWith(path.Expressions{
										path.MatchRelative().AtParent().AtName("one"),
										path.MatchRelative().AtParent().AtName("two"),
										path.MatchRelative().AtParent().AtName("three"),
										path.MatchRelative().AtParent().AtName("four"),
										path.MatchRelative().AtParent().AtName("five"),
										path.MatchRelative().AtParent().AtName("six"),
										path.MatchRelative().AtParent().AtName("seven"),
										path.MatchRelative().AtParent().AtName("eight"),
									}...),
								},
							},
						},
						Validators: []validator.Object{
							validators.ExactlyOneChild(),
						},
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Description: `A string holding the unique ID of the deployment`,
					},
				},
				Description: `The deployment including only public information`,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("one"),
					}...),
				},
			},
			"type": schema.StringAttribute{
				Computed:    true,
				Description: `must be one of ["LAMBDAS"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"LAMBDAS",
					),
				},
			},
			"url": schema.StringAttribute{
				Computed:    true,
				Description: `A string with the unique URL of the deployment`,
			},
			"user_aliases": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: `An array of domains that were provided by the user when creating the Deployment.`,
			},
			"version": schema.NumberAttribute{
				Computed:    true,
				Description: `The platform version that was used to create the deployment.`,
			},
			"with_latest_commit": schema.BoolAttribute{
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional:    true,
				Description: `When ` + "`" + `true` + "`" + ` and ` + "`" + `deploymentId` + "`" + ` is passed in, the sha from the previous deployment's ` + "`" + `gitSource` + "`" + ` is removed forcing the latest commit to be used. Requires replacement if changed. `,
			},
		},
	}
}

func (r *DeploymentResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *DeploymentResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *DeploymentResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	forceNew := new(operations.ForceNew)
	if !data.ForceNew.IsUnknown() && !data.ForceNew.IsNull() {
		*forceNew = operations.ForceNew(data.ForceNew.ValueString())
	} else {
		forceNew = nil
	}
	skipAutoDetectionConfirmation := new(operations.SkipAutoDetectionConfirmation)
	if !data.SkipAutoDetectionConfirmation.IsUnknown() && !data.SkipAutoDetectionConfirmation.IsNull() {
		*skipAutoDetectionConfirmation = operations.SkipAutoDetectionConfirmation(data.SkipAutoDetectionConfirmation.ValueString())
	} else {
		skipAutoDetectionConfirmation = nil
	}
	teamID := new(string)
	if !data.TeamID.IsUnknown() && !data.TeamID.IsNull() {
		*teamID = data.TeamID.ValueString()
	} else {
		teamID = nil
	}
	slug := new(string)
	if !data.Slug.IsUnknown() && !data.Slug.IsNull() {
		*slug = data.Slug.ValueString()
	} else {
		slug = nil
	}
	requestBody := data.ToOperationsCreateDeploymentRequestBody()
	request := operations.CreateDeploymentRequest{
		ForceNew:                      forceNew,
		SkipAutoDetectionConfirmation: skipAutoDetectionConfirmation,
		TeamID:                        teamID,
		Slug:                          slug,
		RequestBody:                   requestBody,
	}
	res, err := r.client.Deployments.Create(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.Object == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromOperationsCreateDeploymentResponseBody(res.Object)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	idOrURL := data.ProjectID.ValueString()
	var withGitRepoInfo *string
	teamId1 := new(string)
	if !data.TeamID.IsUnknown() && !data.TeamID.IsNull() {
		*teamId1 = data.TeamID.ValueString()
	} else {
		teamId1 = nil
	}
	slug1 := new(string)
	if !data.Slug.IsUnknown() && !data.Slug.IsNull() {
		*slug1 = data.Slug.ValueString()
	} else {
		slug1 = nil
	}
	request1 := operations.GetDeploymentRequest{
		IDOrURL:         idOrURL,
		WithGitRepoInfo: withGitRepoInfo,
		TeamID:          teamId1,
		Slug:            slug1,
	}
	res1, err := r.client.Deployments.GetDeployment(ctx, request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if res1.OneOf == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromOperationsGetDeploymentResponseBody(res1.OneOf)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DeploymentResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *DeploymentResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	idOrURL := data.ProjectID.ValueString()
	var withGitRepoInfo *string
	teamID := new(string)
	if !data.TeamID.IsUnknown() && !data.TeamID.IsNull() {
		*teamID = data.TeamID.ValueString()
	} else {
		teamID = nil
	}
	slug := new(string)
	if !data.Slug.IsUnknown() && !data.Slug.IsNull() {
		*slug = data.Slug.ValueString()
	} else {
		slug = nil
	}
	request := operations.GetDeploymentRequest{
		IDOrURL:         idOrURL,
		WithGitRepoInfo: withGitRepoInfo,
		TeamID:          teamID,
		Slug:            slug,
	}
	res, err := r.client.Deployments.GetDeployment(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.OneOf == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromOperationsGetDeploymentResponseBody(res.OneOf)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DeploymentResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *DeploymentResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; all attributes marked as RequiresReplace

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DeploymentResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *DeploymentResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; entity does not have a configured DELETE operation
}

func (r *DeploymentResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("project_id"), req.ID)...)
}
