// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/boolvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/numbervalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	tfTypes "github.com/vercel/terraform-provider-vercel/internal/provider/types"
	"github.com/vercel/terraform-provider-vercel/internal/sdk"
	"github.com/vercel/terraform-provider-vercel/internal/sdk/models/operations"
	"github.com/vercel/terraform-provider-vercel/internal/validators"
	speakeasy_listvalidators "github.com/vercel/terraform-provider-vercel/internal/validators/listvalidators"
	speakeasy_stringvalidators "github.com/vercel/terraform-provider-vercel/internal/validators/stringvalidators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &ProjectResource{}
var _ resource.ResourceWithImportState = &ProjectResource{}

func NewProjectResource() resource.Resource {
	return &ProjectResource{}
}

// ProjectResource defines the resource implementation.
type ProjectResource struct {
	client *sdk.SDK
}

// ProjectResourceModel describes the resource data model.
type ProjectResourceModel struct {
	AccountID                            types.String                                  `tfsdk:"account_id"`
	Analytics                            *tfTypes.GetProjectAnalytics                  `tfsdk:"analytics"`
	AutoAssignCustomDomains              types.Bool                                    `tfsdk:"auto_assign_custom_domains"`
	AutoAssignCustomDomainsUpdatedBy     types.String                                  `tfsdk:"auto_assign_custom_domains_updated_by"`
	AutoExposeSystemEnvs                 types.Bool                                    `tfsdk:"auto_expose_system_envs"`
	BuildCommand                         types.String                                  `tfsdk:"build_command"`
	CommandForIgnoringBuildStep          types.String                                  `tfsdk:"command_for_ignoring_build_step"`
	ConcurrencyBucketName                types.String                                  `tfsdk:"concurrency_bucket_name"`
	ConnectBuildsEnabled                 types.Bool                                    `tfsdk:"connect_builds_enabled"`
	ConnectConfigurationID               types.String                                  `tfsdk:"connect_configuration_id"`
	CreatedAt                            types.Number                                  `tfsdk:"created_at"`
	Crons                                *tfTypes.GetProjectCrons                      `tfsdk:"crons"`
	CustomerSupportCodeVisibility        types.Bool                                    `tfsdk:"customer_support_code_visibility"`
	DataCache                            *tfTypes.GetProjectDataCache                  `tfsdk:"data_cache"`
	DevCommand                           types.String                                  `tfsdk:"dev_command"`
	DirectoryListing                     types.Bool                                    `tfsdk:"directory_listing"`
	EnablePreviewFeedback                types.Bool                                    `tfsdk:"enable_preview_feedback"`
	Env                                  []tfTypes.GetProjectEnv                       `tfsdk:"env"`
	EnvironmentVariables                 []tfTypes.EnvironmentVariables                `tfsdk:"environment_variables"`
	Framework                            types.String                                  `tfsdk:"framework"`
	GitComments                          *tfTypes.GetProjectGitComments                `tfsdk:"git_comments"`
	GitForkProtection                    types.Bool                                    `tfsdk:"git_fork_protection"`
	GitLFS                               types.Bool                                    `tfsdk:"git_lfs"`
	GitRepository                        *tfTypes.GitRepository                        `tfsdk:"git_repository"`
	HasActiveBranches                    types.Bool                                    `tfsdk:"has_active_branches"`
	HasFloatingAliases                   types.Bool                                    `tfsdk:"has_floating_aliases"`
	ID                                   types.String                                  `tfsdk:"id"`
	InstallCommand                       types.String                                  `tfsdk:"install_command"`
	LastAliasRequest                     *tfTypes.GetProjectLastAliasRequest           `tfsdk:"last_alias_request"`
	LastRollbackTarget                   *tfTypes.GetProjectLastRollbackTarget         `tfsdk:"last_rollback_target"`
	LatestDeployments                    []tfTypes.GetProjectLatestDeployments         `tfsdk:"latest_deployments"`
	Link                                 *tfTypes.GetProjectLink                       `tfsdk:"link"`
	Live                                 types.Bool                                    `tfsdk:"live"`
	Name                                 types.String                                  `tfsdk:"name"`
	NodeVersion                          types.String                                  `tfsdk:"node_version"`
	OidcTokenConfig                      *tfTypes.GetProjectOidcTokenConfig            `tfsdk:"oidc_token_config"`
	OptionsAllowlist                     *tfTypes.OptionsAllowlist                     `tfsdk:"options_allowlist"`
	OutputDirectory                      types.String                                  `tfsdk:"output_directory"`
	PassiveConnectConfigurationID        types.String                                  `tfsdk:"passive_connect_configuration_id"`
	PasswordProtection                   *tfTypes.PasswordProtection                   `tfsdk:"password_protection"`
	Paused                               types.Bool                                    `tfsdk:"paused"`
	Permissions                          *tfTypes.GetProjectPermissions                `tfsdk:"permissions"`
	ProductionDeploymentsFastLane        types.Bool                                    `tfsdk:"production_deployments_fast_lane"`
	ProtectionBypass                     map[string]tfTypes.GetProjectProtectionBypass `tfsdk:"protection_bypass"`
	PublicSource                         types.Bool                                    `tfsdk:"public_source"`
	RootDirectory                        types.String                                  `tfsdk:"root_directory"`
	Security                             *tfTypes.GetProjectSecurity                   `tfsdk:"security"`
	ServerlessFunctionRegion             types.String                                  `tfsdk:"serverless_function_region"`
	ServerlessFunctionZeroConfigFailover types.Bool                                    `tfsdk:"serverless_function_zero_config_failover"`
	SkewProtectionBoundaryAt             types.Int64                                   `tfsdk:"skew_protection_boundary_at"`
	SkewProtectionMaxAge                 types.Int64                                   `tfsdk:"skew_protection_max_age"`
	SkipGitConnectDuringLink             types.Bool                                    `tfsdk:"skip_git_connect_during_link"`
	Slug                                 types.String                                  `tfsdk:"slug"`
	SourceFilesOutsideRootDirectory      types.Bool                                    `tfsdk:"source_files_outside_root_directory"`
	SpeedInsights                        *tfTypes.GetProjectSpeedInsights              `tfsdk:"speed_insights"`
	SsoProtection                        *tfTypes.SsoProtection                        `tfsdk:"sso_protection"`
	Targets                              map[string]tfTypes.GetProjectOidcTokenClaims  `tfsdk:"targets"`
	TeamID                               types.String                                  `tfsdk:"team_id"`
	TransferCompletedAt                  types.Number                                  `tfsdk:"transfer_completed_at"`
	TransferStartedAt                    types.Number                                  `tfsdk:"transfer_started_at"`
	TransferToAccountID                  types.String                                  `tfsdk:"transfer_to_account_id"`
	TransferredFromAccountID             types.String                                  `tfsdk:"transferred_from_account_id"`
	TrustedIps                           *tfTypes.TrustedIps                           `tfsdk:"trusted_ips"`
	UpdatedAt                            types.Number                                  `tfsdk:"updated_at"`
	WebAnalytics                         *tfTypes.GetProjectWebAnalytics               `tfsdk:"web_analytics"`
}

func (r *ProjectResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_project"
}

func (r *ProjectResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Project Resource",
		Attributes: map[string]schema.Attribute{
			"account_id": schema.StringAttribute{
				Computed: true,
			},
			"analytics": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"canceled_at": schema.NumberAttribute{
						Computed: true,
					},
					"disabled_at": schema.NumberAttribute{
						Computed: true,
					},
					"enabled_at": schema.NumberAttribute{
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"paid_at": schema.NumberAttribute{
						Computed: true,
					},
					"sample_rate_percent": schema.NumberAttribute{
						Computed: true,
					},
					"spend_limit_in_dollars": schema.NumberAttribute{
						Computed: true,
					},
				},
			},
			"auto_assign_custom_domains": schema.BoolAttribute{
				Computed: true,
				Optional: true,
			},
			"auto_assign_custom_domains_updated_by": schema.StringAttribute{
				Computed: true,
				Optional: true,
			},
			"auto_expose_system_envs": schema.BoolAttribute{
				Computed: true,
				Optional: true,
			},
			"build_command": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The build command for this project. When ` + "`" + `null` + "`" + ` is used this value will be automatically detected`,
			},
			"command_for_ignoring_build_step": schema.StringAttribute{
				Computed: true,
				Optional: true,
			},
			"concurrency_bucket_name": schema.StringAttribute{
				Computed: true,
			},
			"connect_builds_enabled": schema.BoolAttribute{
				Computed: true,
			},
			"connect_configuration_id": schema.StringAttribute{
				Computed: true,
			},
			"created_at": schema.NumberAttribute{
				Computed: true,
			},
			"crons": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"definitions": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Computed:    true,
									Description: `The hostname that should be used.`,
								},
								"path": schema.StringAttribute{
									Computed:    true,
									Description: `The path that should be called for the cronjob.`,
								},
								"schedule": schema.StringAttribute{
									Computed:    true,
									Description: `The cron expression.`,
								},
							},
						},
					},
					"deployment_id": schema.StringAttribute{
						Computed:    true,
						Description: `The ID of the Deployment from which the definitions originated.`,
					},
					"disabled_at": schema.NumberAttribute{
						Computed:    true,
						Description: `The time the feature was disabled for this project.`,
					},
					"enabled_at": schema.NumberAttribute{
						Computed:    true,
						Description: `The time the feature was enabled for this project. Note: It enables automatically with the first Deployment that outputs cronjobs.`,
					},
					"updated_at": schema.NumberAttribute{
						Computed: true,
					},
				},
			},
			"customer_support_code_visibility": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Specifies whether customer support can see git source for a deployment`,
			},
			"data_cache": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"storage_size_bytes": schema.NumberAttribute{
						Computed: true,
					},
					"unlimited": schema.BoolAttribute{
						Computed: true,
					},
					"user_disabled": schema.BoolAttribute{
						Computed: true,
					},
				},
			},
			"dev_command": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The dev command for this project. When ` + "`" + `null` + "`" + ` is used this value will be automatically detected`,
			},
			"directory_listing": schema.BoolAttribute{
				Computed: true,
				Optional: true,
			},
			"enable_preview_feedback": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Opt-in to Preview comments on the project level`,
			},
			"env": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"comment": schema.StringAttribute{
							Computed: true,
						},
						"configuration_id": schema.StringAttribute{
							Computed: true,
						},
						"content_hint": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"one": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["redis-url"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"redis-url",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("eight"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"ten": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["postgres-host"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"postgres-host",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("eight"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"eleven": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["postgres-password"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"postgres-password",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("eight"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"twelve": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["postgres-database"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"postgres-database",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("eight"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"thirteen": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["postgres-url-no-ssl"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"postgres-url-no-ssl",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("eight"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"fourteen": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["integration-store-secret"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"integration-store-secret",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("eight"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"two": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["redis-rest-api-url"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"redis-rest-api-url",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("eight"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"three": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["redis-rest-api-token"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"redis-rest-api-token",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("eight"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"four": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["redis-rest-api-read-only-token"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"redis-rest-api-read-only-token",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("eight"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"five": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["blob-read-write-token"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"blob-read-write-token",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("eight"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"six": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["postgres-url"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"postgres-url",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("eight"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"seven": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["postgres-url-non-pooling"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"postgres-url-non-pooling",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("eight"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"eight": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["postgres-prisma-url"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"postgres-prisma-url",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("nine"),
										}...),
									},
								},
								"nine": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"store_id": schema.StringAttribute{
											Computed: true,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `must be one of ["postgres-user"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"postgres-user",
												),
											},
										},
									},
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("one"),
											path.MatchRelative().AtParent().AtName("ten"),
											path.MatchRelative().AtParent().AtName("eleven"),
											path.MatchRelative().AtParent().AtName("twelve"),
											path.MatchRelative().AtParent().AtName("thirteen"),
											path.MatchRelative().AtParent().AtName("fourteen"),
											path.MatchRelative().AtParent().AtName("two"),
											path.MatchRelative().AtParent().AtName("three"),
											path.MatchRelative().AtParent().AtName("four"),
											path.MatchRelative().AtParent().AtName("five"),
											path.MatchRelative().AtParent().AtName("six"),
											path.MatchRelative().AtParent().AtName("seven"),
											path.MatchRelative().AtParent().AtName("eight"),
										}...),
									},
								},
							},
							Validators: []validator.Object{
								validators.ExactlyOneChild(),
							},
						},
						"created_at": schema.NumberAttribute{
							Computed: true,
						},
						"created_by": schema.StringAttribute{
							Computed: true,
						},
						"custom_environment_id": schema.StringAttribute{
							Computed: true,
						},
						"decrypted": schema.BoolAttribute{
							Computed:    true,
							Description: `Whether ` + "`" + `value` + "`" + ` is decrypted.`,
						},
						"edge_config_id": schema.StringAttribute{
							Computed: true,
						},
						"edge_config_token_id": schema.StringAttribute{
							Computed: true,
						},
						"git_branch": schema.StringAttribute{
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"internal_content_hint": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"encrypted_value": schema.StringAttribute{
									Computed:    true,
									Description: `Contains the ` + "`" + `value` + "`" + ` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.`,
								},
								"type": schema.StringAttribute{
									Computed:    true,
									Description: `must be one of ["flags-secret"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"flags-secret",
										),
									},
								},
							},
							Description: `Similar to ` + "`" + `contentHints` + "`" + `, but should not be exposed to the user.`,
						},
						"key": schema.StringAttribute{
							Computed: true,
						},
						"target": schema.ListAttribute{
							Computed:    true,
							ElementType: types.StringType,
						},
						"type": schema.StringAttribute{
							Computed:    true,
							Description: `must be one of ["system", "secret", "encrypted", "plain", "sensitive"]`,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"system",
									"secret",
									"encrypted",
									"plain",
									"sensitive",
								),
							},
						},
						"updated_at": schema.NumberAttribute{
							Computed: true,
						},
						"updated_by": schema.StringAttribute{
							Computed: true,
						},
						"value": schema.StringAttribute{
							Computed: true,
						},
					},
				},
			},
			"environment_variables": schema.ListNestedAttribute{
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"git_branch": schema.StringAttribute{
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Optional:    true,
							Description: `If defined, the git branch of the environment variable (must have target=preview). Requires replacement if changed. `,
						},
						"key": schema.StringAttribute{
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Required:    true,
							Description: `Name of the ENV variable. Requires replacement if changed. `,
						},
						"target": schema.ListAttribute{
							PlanModifiers: []planmodifier.List{
								listplanmodifier.RequiresReplaceIfConfigured(),
							},
							Required:    true,
							ElementType: types.StringType,
							Description: `Deployment Target or Targets in which the ENV variable will be used. Requires replacement if changed. `,
						},
						"type": schema.StringAttribute{
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Optional:    true,
							Description: `Type of the ENV variable. Requires replacement if changed. ; must be one of ["system", "secret", "encrypted", "plain", "sensitive"]`,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"system",
									"secret",
									"encrypted",
									"plain",
									"sensitive",
								),
							},
						},
						"value": schema.StringAttribute{
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Required:    true,
							Description: `Value for the ENV variable. Requires replacement if changed. `,
						},
					},
				},
				Description: `Collection of ENV Variables the Project will use. Requires replacement if changed. `,
			},
			"framework": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The framework that is being used for this project. When ` + "`" + `null` + "`" + ` is used no framework is selected. must be one of ["blitzjs", "nextjs", "gatsby", "remix", "astro", "hexo", "eleventy", "docusaurus-2", "docusaurus", "preact", "solidstart-1", "solidstart", "dojo", "ember", "vue", "scully", "ionic-angular", "angular", "polymer", "svelte", "sveltekit", "sveltekit-1", "ionic-react", "create-react-app", "gridsome", "umijs", "sapper", "saber", "stencil", "nuxtjs", "redwoodjs", "hugo", "jekyll", "brunch", "middleman", "zola", "hydrogen", "vite", "vitepress", "vuepress", "parcel", "sanity", "storybook"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"blitzjs",
						"nextjs",
						"gatsby",
						"remix",
						"astro",
						"hexo",
						"eleventy",
						"docusaurus-2",
						"docusaurus",
						"preact",
						"solidstart-1",
						"solidstart",
						"dojo",
						"ember",
						"vue",
						"scully",
						"ionic-angular",
						"angular",
						"polymer",
						"svelte",
						"sveltekit",
						"sveltekit-1",
						"ionic-react",
						"create-react-app",
						"gridsome",
						"umijs",
						"sapper",
						"saber",
						"stencil",
						"nuxtjs",
						"redwoodjs",
						"hugo",
						"jekyll",
						"brunch",
						"middleman",
						"zola",
						"hydrogen",
						"vite",
						"vitepress",
						"vuepress",
						"parcel",
						"sanity",
						"storybook",
					),
				},
			},
			"git_comments": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"on_commit": schema.BoolAttribute{
						Computed:    true,
						Description: `Whether the Vercel bot should comment on commits`,
					},
					"on_pull_request": schema.BoolAttribute{
						Computed:    true,
						Description: `Whether the Vercel bot should comment on PRs`,
					},
				},
			},
			"git_fork_protection": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Specifies whether PRs from Git forks should require a team member's authorization before it can be deployed`,
			},
			"git_lfs": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Specifies whether Git LFS is enabled for this project.`,
			},
			"git_repository": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"repo": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `The name of the git repository. For example: \"vercel/next.js\". Requires replacement if changed. `,
					},
					"type": schema.StringAttribute{
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
						},
						Required:    true,
						Description: `The Git Provider of the repository. Requires replacement if changed. ; must be one of ["github", "gitlab", "bitbucket"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"github",
								"gitlab",
								"bitbucket",
							),
						},
					},
				},
				Description: `The Git Repository that will be connected to the project. When this is defined, any pushes to the specified connected Git Repository will be automatically deployed. Requires replacement if changed. `,
			},
			"has_active_branches": schema.BoolAttribute{
				Computed: true,
			},
			"has_floating_aliases": schema.BoolAttribute{
				Computed: true,
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `The unique project identifier or the project name`,
			},
			"install_command": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The install command for this project. When ` + "`" + `null` + "`" + ` is used this value will be automatically detected`,
			},
			"last_alias_request": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"from_deployment_id": schema.StringAttribute{
						Computed: true,
					},
					"job_status": schema.StringAttribute{
						Computed:    true,
						Description: `must be one of ["succeeded", "failed", "skipped", "pending", "in-progress"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"succeeded",
								"failed",
								"skipped",
								"pending",
								"in-progress",
							),
						},
					},
					"requested_at": schema.NumberAttribute{
						Computed: true,
					},
					"to_deployment_id": schema.StringAttribute{
						Computed: true,
					},
					"type": schema.StringAttribute{
						Computed:    true,
						Description: `must be one of ["promote", "rollback"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"promote",
								"rollback",
							),
						},
					},
				},
			},
			"last_rollback_target": schema.SingleNestedAttribute{
				Computed:   true,
				Attributes: map[string]schema.Attribute{},
			},
			"latest_deployments": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"alias": schema.ListAttribute{
							Computed:    true,
							ElementType: types.StringType,
						},
						"alias_assigned": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"number": schema.NumberAttribute{
									Computed: true,
									Validators: []validator.Number{
										numbervalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("boolean"),
										}...),
									},
								},
								"boolean": schema.BoolAttribute{
									Computed: true,
									Validators: []validator.Bool{
										boolvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("number"),
										}...),
									},
								},
							},
							Validators: []validator.Object{
								validators.ExactlyOneChild(),
							},
						},
						"alias_error": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"code": schema.StringAttribute{
									Computed: true,
								},
								"message": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"alias_final": schema.StringAttribute{
							Computed: true,
						},
						"automatic_aliases": schema.ListAttribute{
							Computed:    true,
							ElementType: types.StringType,
						},
						"building_at": schema.NumberAttribute{
							Computed: true,
						},
						"builds": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"dest": schema.StringAttribute{
										Computed: true,
									},
									"src": schema.StringAttribute{
										Computed: true,
									},
									"use": schema.StringAttribute{
										Computed: true,
									},
								},
							},
						},
						"checks_conclusion": schema.StringAttribute{
							Computed:    true,
							Description: `must be one of ["succeeded", "failed", "skipped", "canceled"]`,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"succeeded",
									"failed",
									"skipped",
									"canceled",
								),
							},
						},
						"checks_state": schema.StringAttribute{
							Computed:    true,
							Description: `must be one of ["registered", "running", "completed"]`,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"registered",
									"running",
									"completed",
								),
							},
						},
						"connect_builds_enabled": schema.BoolAttribute{
							Computed: true,
						},
						"connect_configuration_id": schema.StringAttribute{
							Computed: true,
						},
						"created_at": schema.NumberAttribute{
							Computed: true,
						},
						"created_in": schema.StringAttribute{
							Computed: true,
						},
						"creator": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"email": schema.StringAttribute{
									Computed: true,
								},
								"github_login": schema.StringAttribute{
									Computed: true,
								},
								"gitlab_login": schema.StringAttribute{
									Computed: true,
								},
								"uid": schema.StringAttribute{
									Computed: true,
								},
								"username": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"deployment_hostname": schema.StringAttribute{
							Computed: true,
						},
						"forced": schema.BoolAttribute{
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"meta": schema.MapAttribute{
							Computed:    true,
							ElementType: types.StringType,
						},
						"monorepo_manager": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"oidc_token_claims": schema.MapNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"str": schema.StringAttribute{
										Computed: true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("array_of_str"),
											}...),
										},
									},
									"array_of_str": schema.ListAttribute{
										Computed:    true,
										ElementType: types.StringType,
										Validators: []validator.List{
											listvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("str"),
											}...),
										},
									},
								},
								Validators: []validator.Object{
									validators.ExactlyOneChild(),
								},
							},
						},
						"plan": schema.StringAttribute{
							Computed:    true,
							Description: `must be one of ["pro", "enterprise", "hobby"]`,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"pro",
									"enterprise",
									"hobby",
								),
							},
						},
						"preview_comments_enabled": schema.BoolAttribute{
							Computed:    true,
							Description: `Whether or not preview comments are enabled for the deployment`,
						},
						"private": schema.BoolAttribute{
							Computed: true,
						},
						"ready_at": schema.NumberAttribute{
							Computed: true,
						},
						"ready_state": schema.StringAttribute{
							Computed:    true,
							Description: `must be one of ["BUILDING", "ERROR", "INITIALIZING", "QUEUED", "READY", "CANCELED"]`,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"BUILDING",
									"ERROR",
									"INITIALIZING",
									"QUEUED",
									"READY",
									"CANCELED",
								),
							},
						},
						"ready_substate": schema.StringAttribute{
							Computed:    true,
							Description: `must be one of ["STAGED", "PROMOTED"]`,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"STAGED",
									"PROMOTED",
								),
							},
						},
						"requested_at": schema.NumberAttribute{
							Computed: true,
						},
						"target": schema.StringAttribute{
							Computed: true,
						},
						"team_id": schema.StringAttribute{
							Computed: true,
						},
						"type": schema.StringAttribute{
							Computed:    true,
							Description: `must be one of ["LAMBDAS"]`,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"LAMBDAS",
								),
							},
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
						"user_id": schema.StringAttribute{
							Computed: true,
						},
						"with_cache": schema.BoolAttribute{
							Computed: true,
						},
					},
				},
			},
			"link": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"one": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"created_at": schema.NumberAttribute{
								Computed: true,
							},
							"deploy_hooks": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"created_at": schema.NumberAttribute{
											Computed: true,
										},
										"id": schema.StringAttribute{
											Computed: true,
										},
										"name": schema.StringAttribute{
											Computed: true,
										},
										"ref": schema.StringAttribute{
											Computed: true,
										},
										"url": schema.StringAttribute{
											Computed: true,
										},
									},
								},
							},
							"git_credential_id": schema.StringAttribute{
								Computed: true,
							},
							"org": schema.StringAttribute{
								Computed: true,
							},
							"production_branch": schema.StringAttribute{
								Computed: true,
							},
							"repo": schema.StringAttribute{
								Computed: true,
							},
							"repo_id": schema.NumberAttribute{
								Computed: true,
							},
							"sourceless": schema.BoolAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["github"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"github",
									),
								},
							},
							"updated_at": schema.NumberAttribute{
								Computed: true,
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("two"),
								path.MatchRelative().AtParent().AtName("three"),
							}...),
						},
					},
					"two": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"created_at": schema.NumberAttribute{
								Computed: true,
							},
							"deploy_hooks": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"created_at": schema.NumberAttribute{
											Computed: true,
										},
										"id": schema.StringAttribute{
											Computed: true,
										},
										"name": schema.StringAttribute{
											Computed: true,
										},
										"ref": schema.StringAttribute{
											Computed: true,
										},
										"url": schema.StringAttribute{
											Computed: true,
										},
									},
								},
							},
							"git_credential_id": schema.StringAttribute{
								Computed: true,
							},
							"production_branch": schema.StringAttribute{
								Computed: true,
							},
							"project_id": schema.StringAttribute{
								Computed: true,
							},
							"project_name": schema.StringAttribute{
								Computed: true,
							},
							"project_namespace": schema.StringAttribute{
								Computed: true,
							},
							"project_name_with_namespace": schema.StringAttribute{
								Computed: true,
							},
							"project_url": schema.StringAttribute{
								Computed: true,
							},
							"sourceless": schema.BoolAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["gitlab"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"gitlab",
									),
								},
							},
							"updated_at": schema.NumberAttribute{
								Computed: true,
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
								path.MatchRelative().AtParent().AtName("three"),
							}...),
						},
					},
					"three": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"created_at": schema.NumberAttribute{
								Computed: true,
							},
							"deploy_hooks": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"created_at": schema.NumberAttribute{
											Computed: true,
										},
										"id": schema.StringAttribute{
											Computed: true,
										},
										"name": schema.StringAttribute{
											Computed: true,
										},
										"ref": schema.StringAttribute{
											Computed: true,
										},
										"url": schema.StringAttribute{
											Computed: true,
										},
									},
								},
							},
							"git_credential_id": schema.StringAttribute{
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed: true,
							},
							"owner": schema.StringAttribute{
								Computed: true,
							},
							"production_branch": schema.StringAttribute{
								Computed: true,
							},
							"slug": schema.StringAttribute{
								Computed: true,
							},
							"sourceless": schema.BoolAttribute{
								Computed: true,
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Description: `must be one of ["bitbucket"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"bitbucket",
									),
								},
							},
							"updated_at": schema.NumberAttribute{
								Computed: true,
							},
							"uuid": schema.StringAttribute{
								Computed: true,
							},
							"workspace_uuid": schema.StringAttribute{
								Computed: true,
							},
						},
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("one"),
								path.MatchRelative().AtParent().AtName("two"),
							}...),
						},
					},
				},
				Validators: []validator.Object{
					validators.ExactlyOneChild(),
				},
			},
			"live": schema.BoolAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:    true,
				Description: `The desired name for the project`,
			},
			"node_version": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `must be one of ["20.x", "18.x", "16.x", "14.x", "12.x", "10.x"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"20.x",
						"18.x",
						"16.x",
						"14.x",
						"12.x",
						"10.x",
					),
				},
			},
			"oidc_token_config": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Computed: true,
					},
				},
			},
			"options_allowlist": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"paths": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"value": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Description: `The regex path that should not be protected by Deployment Protection. Not Null`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Not Null`,
						Validators: []validator.List{
							speakeasy_listvalidators.NotNull(),
						},
					},
				},
				Description: `Specify a list of paths that should not be protected by Deployment Protection to enable Cors preflight requests`,
			},
			"output_directory": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The output directory of the project. When ` + "`" + `null` + "`" + ` is used this value will be automatically detected`,
			},
			"passive_connect_configuration_id": schema.StringAttribute{
				Computed: true,
			},
			"password_protection": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"deployment_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Specify if the password will apply to every Deployment Target or just Preview. Not Null; must be one of ["all", "preview", "prod_deployment_urls_and_all_previews"]`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"all",
								"preview",
								"prod_deployment_urls_and_all_previews",
							),
						},
					},
					"password": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `The password that will be used to protect Project Deployments`,
					},
				},
				Description: `Allows to protect project deployments with a password`,
			},
			"paused": schema.BoolAttribute{
				Computed: true,
			},
			"permissions": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"access_group": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"alias_global": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"alias_project": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"alias_protection_bypass": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"analytics": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"analytics_sampling": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"analytics_usage": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"audit_log": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"billing_address": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"billing_information": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"billing_invoice": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"billing_invoice_email_recipient": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"billing_invoice_language": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"billing_plan": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"billing_purchase_order": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"billing_tax_id": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"blob": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"blob_store_token_set": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"budget": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"cache_artifact": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"cache_artifact_usage_event": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"code_checks": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"concurrent_builds": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"connect": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"connect_configuration": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"connect_configuration_link": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"data_cache_billing_settings": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"data_cache_namespace": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"deployment": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"deployment_check": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"deployment_check_preview": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"deployment_check_re_run_from_production_branch": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"deployment_preview": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"deployment_private": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"deployment_production_git": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"deployment_promote": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"deployment_rollback": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"domain": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"domain_accept_delegation": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"domain_auth_codes": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"domain_certificate": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"domain_check_config": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"domain_move": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"domain_purchase": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"domain_record": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"domain_transfer_in": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"edge_config": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"edge_config_item": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"edge_config_schema": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"edge_config_token": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"endpoint_verification": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"environments": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"event": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"file_upload": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"git_repository": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"integration": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"integration_configuration": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"integration_configuration_projects": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"integration_configuration_transfer": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"integration_event": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"integration_resource_secrets": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"integration_store": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"integration_store_token_set": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"integration_vercel_configuration_override": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"ip_blocking": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"job": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"job_global": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"log_drain": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"logs": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"logs_preset": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"marketplace_billing_data": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"monitoring": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"monitoring_alert": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"monitoring_chart": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"monitoring_query": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"monitoring_settings": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_customer_budget": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_deployment_failed": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_domain_configuration": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_domain_expire": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_domain_moved": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_domain_purchase": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_domain_renewal": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_domain_transfer": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_domain_unverified": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_monitoring_alert": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_payment_failed": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_statement_of_reasons": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"notification_usage_alert": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"oauth2_application": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"oauth2_connection": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"open_telemetry_endpoint": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"options_allowlist": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"own_event": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"password_protection": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"password_protection_invoice_item": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"payment_method": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"permissions": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"postgres": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"postgres_store_token_set": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"preview_deployment_suffix": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"production_alias_protection_bypass": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_access_group": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_analytics_sampling": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_analytics_usage": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_deployment_expiration": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_deployment_hook": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_domain": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_domain_check_config": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_domain_move": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_env_vars": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_env_vars_production": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_env_vars_unowned_by_integration": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_id": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_integration_configuration": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_link": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_member": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_monitoring": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_permissions": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_production_branch": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_protection_bypass": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_support_case": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_support_case_comment": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_transfer": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_transfer_in": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_transfer_out": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"project_usage": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"pro_trial_onboarding": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"rate_limit": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"redis": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"redis_store_token_set": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"remote_caching": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"repository": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"saml_config": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"seawall_config": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"secret": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"sensitive_environment_variable_policy": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"shared_env_var_connection": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"shared_env_vars": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"shared_env_vars_production": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"skew_protection": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"space": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"space_run": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"support_case": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"support_case_comment": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"team": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"team_access_request": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"team_fellow_membership": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"team_invite": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"team_invite_code": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"team_join": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"team_own_membership": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"team_own_membership_disconnect_saml": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"token": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"trusted_ips": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"usage": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"usage_cycle": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"user": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"user_connection": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"web_analytics": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"web_analytics_plan": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"web_authn": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"webhook": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
					"webhook_event": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
					},
				},
			},
			"production_deployments_fast_lane": schema.BoolAttribute{
				Computed: true,
			},
			"protection_bypass": schema.MapNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created_at": schema.NumberAttribute{
							Computed: true,
						},
						"created_by": schema.StringAttribute{
							Computed: true,
						},
						"scope": schema.StringAttribute{
							Computed:    true,
							Description: `must be one of ["automation-bypass"]`,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"automation-bypass",
								),
							},
						},
					},
				},
			},
			"public_source": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Specifies whether the source code and logs of the deployments for this project should be public or not`,
			},
			"root_directory": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The name of a directory or relative path to the source code of your project. When ` + "`" + `null` + "`" + ` is used it will default to the project root`,
			},
			"security": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"attack_mode_active_until": schema.NumberAttribute{
						Computed: true,
					},
					"attack_mode_enabled": schema.BoolAttribute{
						Computed: true,
					},
					"attack_mode_updated_at": schema.NumberAttribute{
						Computed: true,
					},
					"firewall_config_version": schema.NumberAttribute{
						Computed: true,
					},
					"firewall_enabled": schema.BoolAttribute{
						Computed: true,
					},
					"firewall_seawall_enabled": schema.BoolAttribute{
						Computed: true,
					},
					"firewall_updated_at": schema.NumberAttribute{
						Computed: true,
					},
					"ja3_enabled": schema.BoolAttribute{
						Computed: true,
					},
					"ja4_enabled": schema.BoolAttribute{
						Computed: true,
					},
				},
			},
			"serverless_function_region": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The region to deploy Serverless Functions in this project`,
			},
			"serverless_function_zero_config_failover": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Specifies whether Zero Config Failover is enabled for this project.`,
			},
			"skew_protection_boundary_at": schema.Int64Attribute{
				Computed:    true,
				Optional:    true,
				Description: `Deployments created before this absolute datetime have Skew Protection disabled. Value is in milliseconds since epoch to match \"createdAt\" fields.`,
			},
			"skew_protection_max_age": schema.Int64Attribute{
				Computed:    true,
				Optional:    true,
				Description: `Deployments created before this rolling window have Skew Protection disabled. Value is in seconds to match \"revalidate\" fields.`,
			},
			"skip_git_connect_during_link": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Opts-out of the message prompting a CLI user to connect a Git repository in ` + "`" + `vercel link` + "`" + `.`,
			},
			"slug": schema.StringAttribute{
				Optional:    true,
				Description: `The Team slug to perform the request on behalf of.`,
			},
			"source_files_outside_root_directory": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Indicates if there are source files outside of the root directory`,
			},
			"speed_insights": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"canceled_at": schema.NumberAttribute{
						Computed: true,
					},
					"disabled_at": schema.NumberAttribute{
						Computed: true,
					},
					"enabled_at": schema.NumberAttribute{
						Computed: true,
					},
					"has_data": schema.BoolAttribute{
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"paid_at": schema.NumberAttribute{
						Computed: true,
					},
				},
			},
			"sso_protection": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"deployment_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString("preview"),
						Description: `Specify if the Vercel Authentication (SSO Protection) will apply to every Deployment Target or just Preview. must be one of ["all", "preview", "prod_deployment_urls_and_all_previews"]; Default: "preview"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"all",
								"preview",
								"prod_deployment_urls_and_all_previews",
							),
						},
					},
				},
				Description: `Ensures visitors to your Preview Deployments are logged into Vercel and have a minimum of Viewer access on your team`,
			},
			"targets": schema.MapNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"str": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								stringvalidator.ConflictsWith(path.Expressions{
									path.MatchRelative().AtParent().AtName("array_of_str"),
								}...),
							},
						},
						"array_of_str": schema.ListAttribute{
							Computed:    true,
							ElementType: types.StringType,
							Validators: []validator.List{
								listvalidator.ConflictsWith(path.Expressions{
									path.MatchRelative().AtParent().AtName("str"),
								}...),
							},
						},
					},
					Validators: []validator.Object{
						validators.ExactlyOneChild(),
					},
				},
			},
			"team_id": schema.StringAttribute{
				Optional:    true,
				Description: `The Team identifier to perform the request on behalf of.`,
			},
			"transfer_completed_at": schema.NumberAttribute{
				Computed: true,
			},
			"transfer_started_at": schema.NumberAttribute{
				Computed: true,
			},
			"transfer_to_account_id": schema.StringAttribute{
				Computed: true,
			},
			"transferred_from_account_id": schema.StringAttribute{
				Computed: true,
			},
			"trusted_ips": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"addresses": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"note": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Description: `An optional note explaining what the IP address or subnet is used for`,
								},
								"value": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Description: `The IP addresses that are allowlisted. Supports IPv4 addresses and CIDR notations. IPv6 is not supported. Not Null`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `Not Null`,
						Validators: []validator.List{
							speakeasy_listvalidators.NotNull(),
							listvalidator.SizeAtLeast(1),
						},
					},
					"deployment_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Specify if the Trusted IPs will apply to every Deployment Target or just Preview. Not Null; must be one of ["all", "preview", "production", "prod_deployment_urls_and_all_previews"]`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"all",
								"preview",
								"production",
								"prod_deployment_urls_and_all_previews",
							),
						},
					},
					"protection_mode": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `exclusive: ip match is enough to bypass deployment protection (regardless of other settings). additional: ip must match + any other protection should be also provided (password, vercel auth, shareable link, automation bypass header, automation bypass query param). Not Null; must be one of ["exclusive", "additional"]`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
							stringvalidator.OneOf(
								"exclusive",
								"additional",
							),
						},
					},
				},
				Description: `Restricts access to deployments based on the incoming request IP address`,
			},
			"updated_at": schema.NumberAttribute{
				Computed: true,
			},
			"web_analytics": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"canceled_at": schema.NumberAttribute{
						Computed: true,
					},
					"disabled_at": schema.NumberAttribute{
						Computed: true,
					},
					"enabled_at": schema.NumberAttribute{
						Computed: true,
					},
					"has_data": schema.BoolAttribute{
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
				},
			},
		},
	}
}

func (r *ProjectResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *ProjectResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *ProjectResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	teamID := new(string)
	if !data.TeamID.IsUnknown() && !data.TeamID.IsNull() {
		*teamID = data.TeamID.ValueString()
	} else {
		teamID = nil
	}
	slug := new(string)
	if !data.Slug.IsUnknown() && !data.Slug.IsNull() {
		*slug = data.Slug.ValueString()
	} else {
		slug = nil
	}
	requestBody := data.ToOperationsCreateProjectRequestBody()
	request := operations.CreateProjectRequest{
		TeamID:      teamID,
		Slug:        slug,
		RequestBody: requestBody,
	}
	res, err := r.client.Projects.Create(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromOperationsCreateProjectResponseBody(res.Object)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	idOrName := data.ID.ValueString()
	teamId1 := new(string)
	if !data.TeamID.IsUnknown() && !data.TeamID.IsNull() {
		*teamId1 = data.TeamID.ValueString()
	} else {
		teamId1 = nil
	}
	slug1 := new(string)
	if !data.Slug.IsUnknown() && !data.Slug.IsNull() {
		*slug1 = data.Slug.ValueString()
	} else {
		slug1 = nil
	}
	requestBody1 := data.ToOperationsUpdateProjectRequestBody()
	request1 := operations.UpdateProjectRequest{
		IDOrName:    idOrName,
		TeamID:      teamId1,
		Slug:        slug1,
		RequestBody: requestBody1,
	}
	res1, err := r.client.Projects.Update(ctx, request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromOperationsUpdateProjectResponseBody(res1.Object)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	idOrName1 := data.ID.ValueString()
	teamId2 := new(string)
	if !data.TeamID.IsUnknown() && !data.TeamID.IsNull() {
		*teamId2 = data.TeamID.ValueString()
	} else {
		teamId2 = nil
	}
	slug2 := new(string)
	if !data.Slug.IsUnknown() && !data.Slug.IsNull() {
		*slug2 = data.Slug.ValueString()
	} else {
		slug2 = nil
	}
	request2 := operations.GetProjectRequest{
		IDOrName: idOrName1,
		TeamID:   teamId2,
		Slug:     slug2,
	}
	res2, err := r.client.Projects.GetProject(ctx, request2)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res2 != nil && res2.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res2.RawResponse))
		}
		return
	}
	if res2 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res2))
		return
	}
	if res2.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res2.StatusCode), debugResponse(res2.RawResponse))
		return
	}
	if !(res2.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res2.RawResponse))
		return
	}
	data.RefreshFromOperationsGetProjectResponseBody(res2.Object)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ProjectResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *ProjectResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	idOrName := data.ID.ValueString()
	teamID := new(string)
	if !data.TeamID.IsUnknown() && !data.TeamID.IsNull() {
		*teamID = data.TeamID.ValueString()
	} else {
		teamID = nil
	}
	slug := new(string)
	if !data.Slug.IsUnknown() && !data.Slug.IsNull() {
		*slug = data.Slug.ValueString()
	} else {
		slug = nil
	}
	request := operations.GetProjectRequest{
		IDOrName: idOrName,
		TeamID:   teamID,
		Slug:     slug,
	}
	res, err := r.client.Projects.GetProject(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromOperationsGetProjectResponseBody(res.Object)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ProjectResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *ProjectResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	idOrName := data.ID.ValueString()
	teamID := new(string)
	if !data.TeamID.IsUnknown() && !data.TeamID.IsNull() {
		*teamID = data.TeamID.ValueString()
	} else {
		teamID = nil
	}
	slug := new(string)
	if !data.Slug.IsUnknown() && !data.Slug.IsNull() {
		*slug = data.Slug.ValueString()
	} else {
		slug = nil
	}
	requestBody := data.ToOperationsUpdateProjectRequestBody()
	request := operations.UpdateProjectRequest{
		IDOrName:    idOrName,
		TeamID:      teamID,
		Slug:        slug,
		RequestBody: requestBody,
	}
	res, err := r.client.Projects.Update(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromOperationsUpdateProjectResponseBody(res.Object)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	idOrName1 := data.ID.ValueString()
	teamId1 := new(string)
	if !data.TeamID.IsUnknown() && !data.TeamID.IsNull() {
		*teamId1 = data.TeamID.ValueString()
	} else {
		teamId1 = nil
	}
	slug1 := new(string)
	if !data.Slug.IsUnknown() && !data.Slug.IsNull() {
		*slug1 = data.Slug.ValueString()
	} else {
		slug1 = nil
	}
	request1 := operations.GetProjectRequest{
		IDOrName: idOrName1,
		TeamID:   teamId1,
		Slug:     slug1,
	}
	res1, err := r.client.Projects.GetProject(ctx, request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromOperationsGetProjectResponseBody(res1.Object)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ProjectResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *ProjectResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	idOrName := data.ID.ValueString()
	teamID := new(string)
	if !data.TeamID.IsUnknown() && !data.TeamID.IsNull() {
		*teamID = data.TeamID.ValueString()
	} else {
		teamID = nil
	}
	slug := new(string)
	if !data.Slug.IsUnknown() && !data.Slug.IsNull() {
		*slug = data.Slug.ValueString()
	} else {
		slug = nil
	}
	request := operations.DeleteProjectRequest{
		IDOrName: idOrName,
		TeamID:   teamID,
		Slug:     slug,
	}
	res, err := r.client.Projects.Delete(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 204 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *ProjectResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
}
