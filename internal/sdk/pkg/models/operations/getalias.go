// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"time"
)

type GetAliasRequest struct {
	// Get the alias only if it was created after the provided timestamp
	From *int64 `queryParam:"style=form,explode=true,name=from"`
	// The alias or alias ID to be retrieved
	IDOrAlias string `pathParam:"style=simple,explode=false,name=idOrAlias"`
	// Get the alias only if it is assigned to the provided project ID
	ProjectID *string `queryParam:"style=form,explode=true,name=projectId"`
	// Get the alias only if it was created after this JavaScript timestamp
	Since *int64 `queryParam:"style=form,explode=true,name=since"`
	// The Team identifier or slug to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// Get the alias only if it was created before this JavaScript timestamp
	Until *int64 `queryParam:"style=form,explode=true,name=until"`
}

// GetAlias200ApplicationJSONCreator - Information of the user who created the alias
type GetAlias200ApplicationJSONCreator struct {
	// Email of the user who created the alias
	Email string `json:"email"`
	// ID of the user who created the alias
	UID string `json:"uid"`
	// Username of the user who created the alias
	Username string `json:"username"`
}

// GetAlias200ApplicationJSONDeployment - A map with the deployment ID, URL and metadata
type GetAlias200ApplicationJSONDeployment struct {
	// The deployment unique identifier
	ID string `json:"id"`
	// The deployment metadata
	Meta *string `json:"meta,omitempty"`
	// The deployment unique URL
	URL string `json:"url"`
}

type GetAlias200ApplicationJSONProtectionBypass2Access string

const (
	GetAlias200ApplicationJSONProtectionBypass2AccessRequested GetAlias200ApplicationJSONProtectionBypass2Access = "requested"
	GetAlias200ApplicationJSONProtectionBypass2AccessGranted   GetAlias200ApplicationJSONProtectionBypass2Access = "granted"
)

func (e GetAlias200ApplicationJSONProtectionBypass2Access) ToPointer() *GetAlias200ApplicationJSONProtectionBypass2Access {
	return &e
}

func (e *GetAlias200ApplicationJSONProtectionBypass2Access) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "requested":
		fallthrough
	case "granted":
		*e = GetAlias200ApplicationJSONProtectionBypass2Access(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAlias200ApplicationJSONProtectionBypass2Access: %v", v)
	}
}

type GetAlias200ApplicationJSONProtectionBypass2Scope string

const (
	GetAlias200ApplicationJSONProtectionBypass2ScopeUser GetAlias200ApplicationJSONProtectionBypass2Scope = "user"
)

func (e GetAlias200ApplicationJSONProtectionBypass2Scope) ToPointer() *GetAlias200ApplicationJSONProtectionBypass2Scope {
	return &e
}

func (e *GetAlias200ApplicationJSONProtectionBypass2Scope) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		*e = GetAlias200ApplicationJSONProtectionBypass2Scope(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAlias200ApplicationJSONProtectionBypass2Scope: %v", v)
	}
}

// GetAlias200ApplicationJSONProtectionBypass2 - The protection bypass for the alias
type GetAlias200ApplicationJSONProtectionBypass2 struct {
	Access        GetAlias200ApplicationJSONProtectionBypass2Access `json:"access"`
	CreatedAt     int64                                             `json:"createdAt"`
	LastUpdatedAt int64                                             `json:"lastUpdatedAt"`
	LastUpdatedBy string                                            `json:"lastUpdatedBy"`
	Scope         GetAlias200ApplicationJSONProtectionBypass2Scope  `json:"scope"`
}

type GetAlias200ApplicationJSONProtectionBypass1Scope string

const (
	GetAlias200ApplicationJSONProtectionBypass1ScopeShareableLink    GetAlias200ApplicationJSONProtectionBypass1Scope = "shareable-link"
	GetAlias200ApplicationJSONProtectionBypass1ScopeAutomationBypass GetAlias200ApplicationJSONProtectionBypass1Scope = "automation-bypass"
)

func (e GetAlias200ApplicationJSONProtectionBypass1Scope) ToPointer() *GetAlias200ApplicationJSONProtectionBypass1Scope {
	return &e
}

func (e *GetAlias200ApplicationJSONProtectionBypass1Scope) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "shareable-link":
		fallthrough
	case "automation-bypass":
		*e = GetAlias200ApplicationJSONProtectionBypass1Scope(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAlias200ApplicationJSONProtectionBypass1Scope: %v", v)
	}
}

// GetAlias200ApplicationJSONProtectionBypass1 - The protection bypass for the alias
type GetAlias200ApplicationJSONProtectionBypass1 struct {
	CreatedAt int64                                            `json:"createdAt"`
	CreatedBy string                                           `json:"createdBy"`
	Scope     GetAlias200ApplicationJSONProtectionBypass1Scope `json:"scope"`
}

type GetAlias200ApplicationJSONProtectionBypassType string

const (
	GetAlias200ApplicationJSONProtectionBypassTypeGetAlias200ApplicationJSONProtectionBypass1 GetAlias200ApplicationJSONProtectionBypassType = "getAlias_200ApplicationJSON_protectionBypass_1"
	GetAlias200ApplicationJSONProtectionBypassTypeGetAlias200ApplicationJSONProtectionBypass2 GetAlias200ApplicationJSONProtectionBypassType = "getAlias_200ApplicationJSON_protectionBypass_2"
)

type GetAlias200ApplicationJSONProtectionBypass struct {
	GetAlias200ApplicationJSONProtectionBypass1 *GetAlias200ApplicationJSONProtectionBypass1
	GetAlias200ApplicationJSONProtectionBypass2 *GetAlias200ApplicationJSONProtectionBypass2

	Type GetAlias200ApplicationJSONProtectionBypassType
}

func CreateGetAlias200ApplicationJSONProtectionBypassGetAlias200ApplicationJSONProtectionBypass1(getAlias200ApplicationJSONProtectionBypass1 GetAlias200ApplicationJSONProtectionBypass1) GetAlias200ApplicationJSONProtectionBypass {
	typ := GetAlias200ApplicationJSONProtectionBypassTypeGetAlias200ApplicationJSONProtectionBypass1

	return GetAlias200ApplicationJSONProtectionBypass{
		GetAlias200ApplicationJSONProtectionBypass1: &getAlias200ApplicationJSONProtectionBypass1,
		Type: typ,
	}
}

func CreateGetAlias200ApplicationJSONProtectionBypassGetAlias200ApplicationJSONProtectionBypass2(getAlias200ApplicationJSONProtectionBypass2 GetAlias200ApplicationJSONProtectionBypass2) GetAlias200ApplicationJSONProtectionBypass {
	typ := GetAlias200ApplicationJSONProtectionBypassTypeGetAlias200ApplicationJSONProtectionBypass2

	return GetAlias200ApplicationJSONProtectionBypass{
		GetAlias200ApplicationJSONProtectionBypass2: &getAlias200ApplicationJSONProtectionBypass2,
		Type: typ,
	}
}

func (u *GetAlias200ApplicationJSONProtectionBypass) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	getAlias200ApplicationJSONProtectionBypass1 := new(GetAlias200ApplicationJSONProtectionBypass1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getAlias200ApplicationJSONProtectionBypass1); err == nil {
		u.GetAlias200ApplicationJSONProtectionBypass1 = getAlias200ApplicationJSONProtectionBypass1
		u.Type = GetAlias200ApplicationJSONProtectionBypassTypeGetAlias200ApplicationJSONProtectionBypass1
		return nil
	}

	getAlias200ApplicationJSONProtectionBypass2 := new(GetAlias200ApplicationJSONProtectionBypass2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&getAlias200ApplicationJSONProtectionBypass2); err == nil {
		u.GetAlias200ApplicationJSONProtectionBypass2 = getAlias200ApplicationJSONProtectionBypass2
		u.Type = GetAlias200ApplicationJSONProtectionBypassTypeGetAlias200ApplicationJSONProtectionBypass2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetAlias200ApplicationJSONProtectionBypass) MarshalJSON() ([]byte, error) {
	if u.GetAlias200ApplicationJSONProtectionBypass1 != nil {
		return json.Marshal(u.GetAlias200ApplicationJSONProtectionBypass1)
	}

	if u.GetAlias200ApplicationJSONProtectionBypass2 != nil {
		return json.Marshal(u.GetAlias200ApplicationJSONProtectionBypass2)
	}

	return nil, nil
}

// GetAlias200ApplicationJSONRedirectStatusCode - Status code to be used on redirect
type GetAlias200ApplicationJSONRedirectStatusCode int64

const (
	GetAlias200ApplicationJSONRedirectStatusCodeThreeHundredAndOne   GetAlias200ApplicationJSONRedirectStatusCode = 301
	GetAlias200ApplicationJSONRedirectStatusCodeThreeHundredAndTwo   GetAlias200ApplicationJSONRedirectStatusCode = 302
	GetAlias200ApplicationJSONRedirectStatusCodeThreeHundredAndSeven GetAlias200ApplicationJSONRedirectStatusCode = 307
	GetAlias200ApplicationJSONRedirectStatusCodeThreeHundredAndEight GetAlias200ApplicationJSONRedirectStatusCode = 308
)

func (e GetAlias200ApplicationJSONRedirectStatusCode) ToPointer() *GetAlias200ApplicationJSONRedirectStatusCode {
	return &e
}

func (e *GetAlias200ApplicationJSONRedirectStatusCode) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 301:
		fallthrough
	case 302:
		fallthrough
	case 307:
		fallthrough
	case 308:
		*e = GetAlias200ApplicationJSONRedirectStatusCode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAlias200ApplicationJSONRedirectStatusCode: %v", v)
	}
}

// GetAlias200ApplicationJSON - The alias information
type GetAlias200ApplicationJSON struct {
	// The alias name, it could be a `.vercel.app` subdomain or a custom domain
	Alias string `json:"alias"`
	// The date when the alias was created
	Created time.Time `json:"created"`
	// The date when the alias was created in milliseconds since the UNIX epoch
	CreatedAt *int64 `json:"createdAt,omitempty"`
	// Information of the user who created the alias
	Creator *GetAlias200ApplicationJSONCreator `json:"creator,omitempty"`
	// The date when the alias was deleted in milliseconds since the UNIX epoch
	DeletedAt *int64 `json:"deletedAt,omitempty"`
	// A map with the deployment ID, URL and metadata
	Deployment *GetAlias200ApplicationJSONDeployment `json:"deployment,omitempty"`
	// The deployment ID
	DeploymentID *string `json:"deploymentId"`
	// The unique identifier of the project
	ProjectID *string `json:"projectId"`
	// The protection bypass for the alias
	ProtectionBypass map[string]GetAlias200ApplicationJSONProtectionBypass `json:"protectionBypass,omitempty"`
	// Target destination domain for redirect when the alias is a redirect
	Redirect *string `json:"redirect,omitempty"`
	// Status code to be used on redirect
	RedirectStatusCode *GetAlias200ApplicationJSONRedirectStatusCode `json:"redirectStatusCode,omitempty"`
	// The unique identifier of the alias
	UID string `json:"uid"`
	// The date when the alias was updated in milliseconds since the UNIX epoch
	UpdatedAt *int64 `json:"updatedAt,omitempty"`
}

type GetAliasResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// The alias information
	GetAlias200ApplicationJSONObject *GetAlias200ApplicationJSON
}
