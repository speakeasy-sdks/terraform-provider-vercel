// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type GetDeploymentsDeploymentIDBuildsRequest struct {
	// The deployment unique identifier
	DeploymentID string `pathParam:"style=simple,explode=false,name=deploymentId"`
}

// GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsConfig - An object that contains the Build's configuration
type GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsConfig struct {
	DistDir           *string `json:"distDir,omitempty"`
	ForceBuildIn      *string `json:"forceBuildIn,omitempty"`
	ReuseWorkPathFrom *string `json:"reuseWorkPathFrom,omitempty"`
	ZeroConfig        *bool   `json:"zeroConfig,omitempty"`
}

// GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputEdge - Exists if the output is an edge function.
type GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputEdge struct {
	// The regions where the edge function will be invoked. Only exists if the edge function as a regional edge function, see: https://vercel.com/docs/concepts/edge-network/regions#setting-edge-function-regions
	Regions []string `json:"regions"`
}

// GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputLambda - If the output is a Serverless Function, an object containing the name, location and memory size of the function
type GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputLambda struct {
	DeployedTo   []string `json:"deployedTo"`
	FunctionName string   `json:"functionName"`
	Layers       []string `json:"layers,omitempty"`
	MemorySize   *int64   `json:"memorySize,omitempty"`
	Timeout      *int64   `json:"timeout,omitempty"`
}

// GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputType - The type of the output
type GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputType string

const (
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputTypeLambda GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputType = "lambda"
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputTypeFile   GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputType = "file"
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputTypeEdge   GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputType = "edge"
)

func (e GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputType) ToPointer() *GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputType {
	return &e
}

func (e *GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "lambda":
		fallthrough
	case "file":
		fallthrough
	case "edge":
		*e = GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputType: %v", v)
	}
}

// GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutput - A list of outputs for the Build that can be either Serverless Functions or static files
type GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutput struct {
	// The SHA1 of the file
	Digest string `json:"digest"`
	// Exists if the output is an edge function.
	Edge *GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputEdge `json:"edge,omitempty"`
	// If the output is a Serverless Function, an object containing the name, location and memory size of the function
	Lambda *GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputLambda `json:"lambda,omitempty"`
	// The POSIX file permissions
	Mode int64 `json:"mode"`
	// The absolute path of the file or Serverless Function
	Path string `json:"path"`
	// The size of the file in bytes
	Size *int64 `json:"size,omitempty"`
	// The type of the output
	Type *GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutputType `json:"type,omitempty"`
}

// GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState - The state of the deployment depending on the process of deploying, or if it is ready or in an error state
type GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState string

const (
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyStateInitializing GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState = "INITIALIZING"
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyStateBuilding     GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState = "BUILDING"
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyStateUploading    GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState = "UPLOADING"
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyStateDeploying    GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState = "DEPLOYING"
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyStateReady        GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState = "READY"
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyStateArchived     GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState = "ARCHIVED"
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyStateError        GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState = "ERROR"
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyStateQueued       GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState = "QUEUED"
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyStateCanceled     GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState = "CANCELED"
)

func (e GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState) ToPointer() *GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState {
	return &e
}

func (e *GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INITIALIZING":
		fallthrough
	case "BUILDING":
		fallthrough
	case "UPLOADING":
		fallthrough
	case "DEPLOYING":
		fallthrough
	case "READY":
		fallthrough
	case "ARCHIVED":
		fallthrough
	case "ERROR":
		fallthrough
	case "QUEUED":
		fallthrough
	case "CANCELED":
		*e = GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState: %v", v)
	}
}

// GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuilds - An object representing a Build on Vercel
type GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuilds struct {
	// An object that contains the Build's configuration
	Config     *GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsConfig `json:"config,omitempty"`
	CopiedFrom *string                                                         `json:"copiedFrom,omitempty"`
	// The time at which the Build was created
	CreatedAt *int64 `json:"createdAt,omitempty"`
	// The region where the Build was first created
	CreatedIn *string `json:"createdIn,omitempty"`
	// The time at which the Build was deployed
	DeployedAt *int64 `json:"deployedAt,omitempty"`
	// The unique identifier of the deployment
	DeploymentID string `json:"deploymentId"`
	// The entrypoint of the deployment
	Entrypoint string `json:"entrypoint"`
	// If the Build uses the `@vercel/static` Runtime, it contains a hashed string of all outputs
	Fingerprint *string `json:"fingerprint,omitempty"`
	// The unique identifier of the Build
	ID string `json:"id"`
	// A list of outputs for the Build that can be either Serverless Functions or static files
	Output []GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsOutput `json:"output"`
	// The state of the deployment depending on the process of deploying, or if it is ready or in an error state
	ReadyState GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuildsReadyState `json:"readyState"`
	// The time at which the Build state was last modified
	ReadyStateAt *int64 `json:"readyStateAt,omitempty"`
	// The time at which the Build was scheduled to be built
	ScheduledAt *int64 `json:"scheduledAt,omitempty"`
	// The Runtime the Build used to generate the output
	Use *string `json:"use,omitempty"`
}

type GetDeploymentsDeploymentIDBuilds200ApplicationJSON struct {
	Builds []GetDeploymentsDeploymentIDBuilds200ApplicationJSONBuilds `json:"builds"`
}

type GetDeploymentsDeploymentIDBuildsResponse struct {
	ContentType                                              string
	StatusCode                                               int
	RawResponse                                              *http.Response
	GetDeploymentsDeploymentIDBuilds200ApplicationJSONObject *GetDeploymentsDeploymentIDBuilds200ApplicationJSON
}
