// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
)

type UploadFileRequest struct {
	// The file size in bytes
	ContentLength *int64 `header:"style=simple,explode=false,name=Content-Length"`
	// The Team identifier or slug to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The file SHA1 used to check the integrity
	XNowDigest *string `header:"style=simple,explode=false,name=x-now-digest"`
	// The file size as an alternative to `Content-Length`
	XNowSize *int64 `header:"style=simple,explode=false,name=x-now-size"`
	// The file SHA1 used to check the integrity
	XVercelDigest *string `header:"style=simple,explode=false,name=x-vercel-digest"`
}

type UploadFile200ApplicationJSON2 struct {
}

type UploadFile200ApplicationJSON1 struct {
	// Array of URLs where the file was updated
	Urls []string `json:"urls"`
}

type UploadFile200ApplicationJSONType string

const (
	UploadFile200ApplicationJSONTypeUploadFile200ApplicationJSON1 UploadFile200ApplicationJSONType = "uploadFile_200ApplicationJSON_1"
	UploadFile200ApplicationJSONTypeUploadFile200ApplicationJSON2 UploadFile200ApplicationJSONType = "uploadFile_200ApplicationJSON_2"
)

type UploadFile200ApplicationJSON struct {
	UploadFile200ApplicationJSON1 *UploadFile200ApplicationJSON1
	UploadFile200ApplicationJSON2 *UploadFile200ApplicationJSON2

	Type UploadFile200ApplicationJSONType
}

func CreateUploadFile200ApplicationJSONUploadFile200ApplicationJSON1(uploadFile200ApplicationJSON1 UploadFile200ApplicationJSON1) UploadFile200ApplicationJSON {
	typ := UploadFile200ApplicationJSONTypeUploadFile200ApplicationJSON1

	return UploadFile200ApplicationJSON{
		UploadFile200ApplicationJSON1: &uploadFile200ApplicationJSON1,
		Type:                          typ,
	}
}

func CreateUploadFile200ApplicationJSONUploadFile200ApplicationJSON2(uploadFile200ApplicationJSON2 UploadFile200ApplicationJSON2) UploadFile200ApplicationJSON {
	typ := UploadFile200ApplicationJSONTypeUploadFile200ApplicationJSON2

	return UploadFile200ApplicationJSON{
		UploadFile200ApplicationJSON2: &uploadFile200ApplicationJSON2,
		Type:                          typ,
	}
}

func (u *UploadFile200ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	uploadFile200ApplicationJSON2 := new(UploadFile200ApplicationJSON2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&uploadFile200ApplicationJSON2); err == nil {
		u.UploadFile200ApplicationJSON2 = uploadFile200ApplicationJSON2
		u.Type = UploadFile200ApplicationJSONTypeUploadFile200ApplicationJSON2
		return nil
	}

	uploadFile200ApplicationJSON1 := new(UploadFile200ApplicationJSON1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&uploadFile200ApplicationJSON1); err == nil {
		u.UploadFile200ApplicationJSON1 = uploadFile200ApplicationJSON1
		u.Type = UploadFile200ApplicationJSONTypeUploadFile200ApplicationJSON1
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UploadFile200ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.UploadFile200ApplicationJSON2 != nil {
		return json.Marshal(u.UploadFile200ApplicationJSON2)
	}

	if u.UploadFile200ApplicationJSON1 != nil {
		return json.Marshal(u.UploadFile200ApplicationJSON1)
	}

	return nil, nil
}

type UploadFileResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// File already uploaded
	// File successfully uploaded
	UploadFile200ApplicationJSONOneOf *UploadFile200ApplicationJSON
}
