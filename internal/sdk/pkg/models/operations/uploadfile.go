// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"errors"
	"net/http"
	"vercel/internal/sdk/pkg/utils"
)

type UploadFileRequest struct {
	// The file size in bytes
	ContentLength *int64 `header:"style=simple,explode=false,name=Content-Length"`
	// The Team identifier or slug to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The file SHA1 used to check the integrity
	XNowDigest *string `header:"style=simple,explode=false,name=x-now-digest"`
	// The file size as an alternative to `Content-Length`
	XNowSize *int64 `header:"style=simple,explode=false,name=x-now-size"`
	// The file SHA1 used to check the integrity
	XVercelDigest *string `header:"style=simple,explode=false,name=x-vercel-digest"`
}

func (o *UploadFileRequest) GetContentLength() *int64 {
	if o == nil {
		return nil
	}
	return o.ContentLength
}

func (o *UploadFileRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *UploadFileRequest) GetXNowDigest() *string {
	if o == nil {
		return nil
	}
	return o.XNowDigest
}

func (o *UploadFileRequest) GetXNowSize() *int64 {
	if o == nil {
		return nil
	}
	return o.XNowSize
}

func (o *UploadFileRequest) GetXVercelDigest() *string {
	if o == nil {
		return nil
	}
	return o.XVercelDigest
}

type UploadFile200ApplicationJSON2 struct {
}

type UploadFile200ApplicationJSON1 struct {
	// Array of URLs where the file was updated
	Urls []string `json:"urls"`
}

func (o *UploadFile200ApplicationJSON1) GetUrls() []string {
	if o == nil {
		return []string{}
	}
	return o.Urls
}

type UploadFile200ApplicationJSONType string

const (
	UploadFile200ApplicationJSONTypeUploadFile200ApplicationJSON1 UploadFile200ApplicationJSONType = "uploadFile_200ApplicationJSON_1"
	UploadFile200ApplicationJSONTypeUploadFile200ApplicationJSON2 UploadFile200ApplicationJSONType = "uploadFile_200ApplicationJSON_2"
)

type UploadFile200ApplicationJSON struct {
	UploadFile200ApplicationJSON1 *UploadFile200ApplicationJSON1
	UploadFile200ApplicationJSON2 *UploadFile200ApplicationJSON2

	Type UploadFile200ApplicationJSONType
}

func CreateUploadFile200ApplicationJSONUploadFile200ApplicationJSON1(uploadFile200ApplicationJSON1 UploadFile200ApplicationJSON1) UploadFile200ApplicationJSON {
	typ := UploadFile200ApplicationJSONTypeUploadFile200ApplicationJSON1

	return UploadFile200ApplicationJSON{
		UploadFile200ApplicationJSON1: &uploadFile200ApplicationJSON1,
		Type:                          typ,
	}
}

func CreateUploadFile200ApplicationJSONUploadFile200ApplicationJSON2(uploadFile200ApplicationJSON2 UploadFile200ApplicationJSON2) UploadFile200ApplicationJSON {
	typ := UploadFile200ApplicationJSONTypeUploadFile200ApplicationJSON2

	return UploadFile200ApplicationJSON{
		UploadFile200ApplicationJSON2: &uploadFile200ApplicationJSON2,
		Type:                          typ,
	}
}

func (u *UploadFile200ApplicationJSON) UnmarshalJSON(data []byte) error {

	uploadFile200ApplicationJSON2 := new(UploadFile200ApplicationJSON2)
	if err := utils.UnmarshalJSON(data, &uploadFile200ApplicationJSON2, "", true, true); err == nil {
		u.UploadFile200ApplicationJSON2 = uploadFile200ApplicationJSON2
		u.Type = UploadFile200ApplicationJSONTypeUploadFile200ApplicationJSON2
		return nil
	}

	uploadFile200ApplicationJSON1 := new(UploadFile200ApplicationJSON1)
	if err := utils.UnmarshalJSON(data, &uploadFile200ApplicationJSON1, "", true, true); err == nil {
		u.UploadFile200ApplicationJSON1 = uploadFile200ApplicationJSON1
		u.Type = UploadFile200ApplicationJSONTypeUploadFile200ApplicationJSON1
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UploadFile200ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.UploadFile200ApplicationJSON1 != nil {
		return utils.MarshalJSON(u.UploadFile200ApplicationJSON1, "", true)
	}

	if u.UploadFile200ApplicationJSON2 != nil {
		return utils.MarshalJSON(u.UploadFile200ApplicationJSON2, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type UploadFileResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// File already uploaded
	// File successfully uploaded
	UploadFile200ApplicationJSONOneOf *UploadFile200ApplicationJSON
}

func (o *UploadFileResponse) GetContentType() string {
	if o == nil {
		return ""
	}
	return o.ContentType
}

func (o *UploadFileResponse) GetStatusCode() int {
	if o == nil {
		return 0
	}
	return o.StatusCode
}

func (o *UploadFileResponse) GetRawResponse() *http.Response {
	if o == nil {
		return nil
	}
	return o.RawResponse
}

func (o *UploadFileResponse) GetUploadFile200ApplicationJSONOneOf() *UploadFile200ApplicationJSON {
	if o == nil {
		return nil
	}
	return o.UploadFile200ApplicationJSONOneOf
}
