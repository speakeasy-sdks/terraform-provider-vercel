// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type TeamLimitedMembership2JoinedFromGitUserIDType string

const (
	TeamLimitedMembership2JoinedFromGitUserIDTypeStr     TeamLimitedMembership2JoinedFromGitUserIDType = "str"
	TeamLimitedMembership2JoinedFromGitUserIDTypeInteger TeamLimitedMembership2JoinedFromGitUserIDType = "integer"
)

type TeamLimitedMembership2JoinedFromGitUserID struct {
	Str     *string
	Integer *int64

	Type TeamLimitedMembership2JoinedFromGitUserIDType
}

func CreateTeamLimitedMembership2JoinedFromGitUserIDStr(str string) TeamLimitedMembership2JoinedFromGitUserID {
	typ := TeamLimitedMembership2JoinedFromGitUserIDTypeStr

	return TeamLimitedMembership2JoinedFromGitUserID{
		Str:  &str,
		Type: typ,
	}
}

func CreateTeamLimitedMembership2JoinedFromGitUserIDInteger(integer int64) TeamLimitedMembership2JoinedFromGitUserID {
	typ := TeamLimitedMembership2JoinedFromGitUserIDTypeInteger

	return TeamLimitedMembership2JoinedFromGitUserID{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *TeamLimitedMembership2JoinedFromGitUserID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = TeamLimitedMembership2JoinedFromGitUserIDTypeStr
		return nil
	}

	integer := new(int64)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&integer); err == nil {
		u.Integer = integer
		u.Type = TeamLimitedMembership2JoinedFromGitUserIDTypeInteger
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u TeamLimitedMembership2JoinedFromGitUserID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.Integer != nil {
		return json.Marshal(u.Integer)
	}

	return nil, nil
}

type TeamLimitedMembership2JoinedFromOrigin string

const (
	TeamLimitedMembership2JoinedFromOriginLink              TeamLimitedMembership2JoinedFromOrigin = "link"
	TeamLimitedMembership2JoinedFromOriginSaml              TeamLimitedMembership2JoinedFromOrigin = "saml"
	TeamLimitedMembership2JoinedFromOriginMail              TeamLimitedMembership2JoinedFromOrigin = "mail"
	TeamLimitedMembership2JoinedFromOriginImport            TeamLimitedMembership2JoinedFromOrigin = "import"
	TeamLimitedMembership2JoinedFromOriginTeams             TeamLimitedMembership2JoinedFromOrigin = "teams"
	TeamLimitedMembership2JoinedFromOriginGithub            TeamLimitedMembership2JoinedFromOrigin = "github"
	TeamLimitedMembership2JoinedFromOriginGitlab            TeamLimitedMembership2JoinedFromOrigin = "gitlab"
	TeamLimitedMembership2JoinedFromOriginBitbucket         TeamLimitedMembership2JoinedFromOrigin = "bitbucket"
	TeamLimitedMembership2JoinedFromOriginDsync             TeamLimitedMembership2JoinedFromOrigin = "dsync"
	TeamLimitedMembership2JoinedFromOriginFeedback          TeamLimitedMembership2JoinedFromOrigin = "feedback"
	TeamLimitedMembership2JoinedFromOriginOrganizationTeams TeamLimitedMembership2JoinedFromOrigin = "organization-teams"
)

func (e TeamLimitedMembership2JoinedFromOrigin) ToPointer() *TeamLimitedMembership2JoinedFromOrigin {
	return &e
}

func (e *TeamLimitedMembership2JoinedFromOrigin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "link":
		fallthrough
	case "saml":
		fallthrough
	case "mail":
		fallthrough
	case "import":
		fallthrough
	case "teams":
		fallthrough
	case "github":
		fallthrough
	case "gitlab":
		fallthrough
	case "bitbucket":
		fallthrough
	case "dsync":
		fallthrough
	case "feedback":
		fallthrough
	case "organization-teams":
		*e = TeamLimitedMembership2JoinedFromOrigin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedMembership2JoinedFromOrigin: %v", v)
	}
}

type TeamLimitedMembership2JoinedFrom struct {
	CommitID         *string                                    `json:"commitId,omitempty"`
	DsyncConnectedAt *int64                                     `json:"dsyncConnectedAt,omitempty"`
	DsyncUserID      *string                                    `json:"dsyncUserId,omitempty"`
	GitUserID        *TeamLimitedMembership2JoinedFromGitUserID `json:"gitUserId,omitempty"`
	GitUserLogin     *string                                    `json:"gitUserLogin,omitempty"`
	IdpUserID        *string                                    `json:"idpUserId,omitempty"`
	Origin           TeamLimitedMembership2JoinedFromOrigin     `json:"origin"`
	RepoID           *string                                    `json:"repoId,omitempty"`
	RepoPath         *string                                    `json:"repoPath,omitempty"`
	SsoConnectedAt   *int64                                     `json:"ssoConnectedAt,omitempty"`
	SsoUserID        *string                                    `json:"ssoUserId,omitempty"`
}

type TeamLimitedMembership2Role string

const (
	TeamLimitedMembership2RoleOwner       TeamLimitedMembership2Role = "OWNER"
	TeamLimitedMembership2RoleMember      TeamLimitedMembership2Role = "MEMBER"
	TeamLimitedMembership2RoleViewer      TeamLimitedMembership2Role = "VIEWER"
	TeamLimitedMembership2RoleDeveloper   TeamLimitedMembership2Role = "DEVELOPER"
	TeamLimitedMembership2RoleBilling     TeamLimitedMembership2Role = "BILLING"
	TeamLimitedMembership2RoleContributor TeamLimitedMembership2Role = "CONTRIBUTOR"
)

func (e TeamLimitedMembership2Role) ToPointer() *TeamLimitedMembership2Role {
	return &e
}

func (e *TeamLimitedMembership2Role) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OWNER":
		fallthrough
	case "MEMBER":
		fallthrough
	case "VIEWER":
		fallthrough
	case "DEVELOPER":
		fallthrough
	case "BILLING":
		fallthrough
	case "CONTRIBUTOR":
		*e = TeamLimitedMembership2Role(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedMembership2Role: %v", v)
	}
}

// TeamLimitedMembership2 - The membership of the authenticated User in relation to the Team.
type TeamLimitedMembership2 struct {
	AccessRequestedAt int64                             `json:"accessRequestedAt"`
	Confirmed         bool                              `json:"confirmed"`
	ConfirmedAt       *int64                            `json:"confirmedAt,omitempty"`
	Created           int64                             `json:"created"`
	CreatedAt         int64                             `json:"createdAt"`
	JoinedFrom        *TeamLimitedMembership2JoinedFrom `json:"joinedFrom,omitempty"`
	Role              TeamLimitedMembership2Role        `json:"role"`
	TeamID            *string                           `json:"teamId,omitempty"`
	UID               string                            `json:"uid"`
}

type TeamLimitedMembership1JoinedFromGitUserIDType string

const (
	TeamLimitedMembership1JoinedFromGitUserIDTypeStr     TeamLimitedMembership1JoinedFromGitUserIDType = "str"
	TeamLimitedMembership1JoinedFromGitUserIDTypeInteger TeamLimitedMembership1JoinedFromGitUserIDType = "integer"
)

type TeamLimitedMembership1JoinedFromGitUserID struct {
	Str     *string
	Integer *int64

	Type TeamLimitedMembership1JoinedFromGitUserIDType
}

func CreateTeamLimitedMembership1JoinedFromGitUserIDStr(str string) TeamLimitedMembership1JoinedFromGitUserID {
	typ := TeamLimitedMembership1JoinedFromGitUserIDTypeStr

	return TeamLimitedMembership1JoinedFromGitUserID{
		Str:  &str,
		Type: typ,
	}
}

func CreateTeamLimitedMembership1JoinedFromGitUserIDInteger(integer int64) TeamLimitedMembership1JoinedFromGitUserID {
	typ := TeamLimitedMembership1JoinedFromGitUserIDTypeInteger

	return TeamLimitedMembership1JoinedFromGitUserID{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *TeamLimitedMembership1JoinedFromGitUserID) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	str := new(string)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&str); err == nil {
		u.Str = str
		u.Type = TeamLimitedMembership1JoinedFromGitUserIDTypeStr
		return nil
	}

	integer := new(int64)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&integer); err == nil {
		u.Integer = integer
		u.Type = TeamLimitedMembership1JoinedFromGitUserIDTypeInteger
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u TeamLimitedMembership1JoinedFromGitUserID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return json.Marshal(u.Str)
	}

	if u.Integer != nil {
		return json.Marshal(u.Integer)
	}

	return nil, nil
}

type TeamLimitedMembership1JoinedFromOrigin string

const (
	TeamLimitedMembership1JoinedFromOriginLink              TeamLimitedMembership1JoinedFromOrigin = "link"
	TeamLimitedMembership1JoinedFromOriginSaml              TeamLimitedMembership1JoinedFromOrigin = "saml"
	TeamLimitedMembership1JoinedFromOriginMail              TeamLimitedMembership1JoinedFromOrigin = "mail"
	TeamLimitedMembership1JoinedFromOriginImport            TeamLimitedMembership1JoinedFromOrigin = "import"
	TeamLimitedMembership1JoinedFromOriginTeams             TeamLimitedMembership1JoinedFromOrigin = "teams"
	TeamLimitedMembership1JoinedFromOriginGithub            TeamLimitedMembership1JoinedFromOrigin = "github"
	TeamLimitedMembership1JoinedFromOriginGitlab            TeamLimitedMembership1JoinedFromOrigin = "gitlab"
	TeamLimitedMembership1JoinedFromOriginBitbucket         TeamLimitedMembership1JoinedFromOrigin = "bitbucket"
	TeamLimitedMembership1JoinedFromOriginDsync             TeamLimitedMembership1JoinedFromOrigin = "dsync"
	TeamLimitedMembership1JoinedFromOriginFeedback          TeamLimitedMembership1JoinedFromOrigin = "feedback"
	TeamLimitedMembership1JoinedFromOriginOrganizationTeams TeamLimitedMembership1JoinedFromOrigin = "organization-teams"
)

func (e TeamLimitedMembership1JoinedFromOrigin) ToPointer() *TeamLimitedMembership1JoinedFromOrigin {
	return &e
}

func (e *TeamLimitedMembership1JoinedFromOrigin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "link":
		fallthrough
	case "saml":
		fallthrough
	case "mail":
		fallthrough
	case "import":
		fallthrough
	case "teams":
		fallthrough
	case "github":
		fallthrough
	case "gitlab":
		fallthrough
	case "bitbucket":
		fallthrough
	case "dsync":
		fallthrough
	case "feedback":
		fallthrough
	case "organization-teams":
		*e = TeamLimitedMembership1JoinedFromOrigin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedMembership1JoinedFromOrigin: %v", v)
	}
}

type TeamLimitedMembership1JoinedFrom struct {
	CommitID         *string                                    `json:"commitId,omitempty"`
	DsyncConnectedAt *int64                                     `json:"dsyncConnectedAt,omitempty"`
	DsyncUserID      *string                                    `json:"dsyncUserId,omitempty"`
	GitUserID        *TeamLimitedMembership1JoinedFromGitUserID `json:"gitUserId,omitempty"`
	GitUserLogin     *string                                    `json:"gitUserLogin,omitempty"`
	IdpUserID        *string                                    `json:"idpUserId,omitempty"`
	Origin           TeamLimitedMembership1JoinedFromOrigin     `json:"origin"`
	RepoID           *string                                    `json:"repoId,omitempty"`
	RepoPath         *string                                    `json:"repoPath,omitempty"`
	SsoConnectedAt   *int64                                     `json:"ssoConnectedAt,omitempty"`
	SsoUserID        *string                                    `json:"ssoUserId,omitempty"`
}

type TeamLimitedMembership1Role string

const (
	TeamLimitedMembership1RoleOwner       TeamLimitedMembership1Role = "OWNER"
	TeamLimitedMembership1RoleMember      TeamLimitedMembership1Role = "MEMBER"
	TeamLimitedMembership1RoleViewer      TeamLimitedMembership1Role = "VIEWER"
	TeamLimitedMembership1RoleDeveloper   TeamLimitedMembership1Role = "DEVELOPER"
	TeamLimitedMembership1RoleBilling     TeamLimitedMembership1Role = "BILLING"
	TeamLimitedMembership1RoleContributor TeamLimitedMembership1Role = "CONTRIBUTOR"
)

func (e TeamLimitedMembership1Role) ToPointer() *TeamLimitedMembership1Role {
	return &e
}

func (e *TeamLimitedMembership1Role) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OWNER":
		fallthrough
	case "MEMBER":
		fallthrough
	case "VIEWER":
		fallthrough
	case "DEVELOPER":
		fallthrough
	case "BILLING":
		fallthrough
	case "CONTRIBUTOR":
		*e = TeamLimitedMembership1Role(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedMembership1Role: %v", v)
	}
}

// TeamLimitedMembership1 - The membership of the authenticated User in relation to the Team.
type TeamLimitedMembership1 struct {
	AccessRequestedAt *int64                            `json:"accessRequestedAt,omitempty"`
	Confirmed         bool                              `json:"confirmed"`
	ConfirmedAt       int64                             `json:"confirmedAt"`
	Created           int64                             `json:"created"`
	CreatedAt         int64                             `json:"createdAt"`
	JoinedFrom        *TeamLimitedMembership1JoinedFrom `json:"joinedFrom,omitempty"`
	Role              TeamLimitedMembership1Role        `json:"role"`
	TeamID            *string                           `json:"teamId,omitempty"`
	UID               string                            `json:"uid"`
}

type TeamLimitedMembershipType string

const (
	TeamLimitedMembershipTypeTeamLimitedMembership1 TeamLimitedMembershipType = "TeamLimited_membership_1"
	TeamLimitedMembershipTypeTeamLimitedMembership2 TeamLimitedMembershipType = "TeamLimited_membership_2"
)

type TeamLimitedMembership struct {
	TeamLimitedMembership1 *TeamLimitedMembership1
	TeamLimitedMembership2 *TeamLimitedMembership2

	Type TeamLimitedMembershipType
}

func CreateTeamLimitedMembershipTeamLimitedMembership1(teamLimitedMembership1 TeamLimitedMembership1) TeamLimitedMembership {
	typ := TeamLimitedMembershipTypeTeamLimitedMembership1

	return TeamLimitedMembership{
		TeamLimitedMembership1: &teamLimitedMembership1,
		Type:                   typ,
	}
}

func CreateTeamLimitedMembershipTeamLimitedMembership2(teamLimitedMembership2 TeamLimitedMembership2) TeamLimitedMembership {
	typ := TeamLimitedMembershipTypeTeamLimitedMembership2

	return TeamLimitedMembership{
		TeamLimitedMembership2: &teamLimitedMembership2,
		Type:                   typ,
	}
}

func (u *TeamLimitedMembership) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	teamLimitedMembership1 := new(TeamLimitedMembership1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&teamLimitedMembership1); err == nil {
		u.TeamLimitedMembership1 = teamLimitedMembership1
		u.Type = TeamLimitedMembershipTypeTeamLimitedMembership1
		return nil
	}

	teamLimitedMembership2 := new(TeamLimitedMembership2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&teamLimitedMembership2); err == nil {
		u.TeamLimitedMembership2 = teamLimitedMembership2
		u.Type = TeamLimitedMembershipTypeTeamLimitedMembership2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u TeamLimitedMembership) MarshalJSON() ([]byte, error) {
	if u.TeamLimitedMembership1 != nil {
		return json.Marshal(u.TeamLimitedMembership1)
	}

	if u.TeamLimitedMembership2 != nil {
		return json.Marshal(u.TeamLimitedMembership2)
	}

	return nil, nil
}

// TeamLimitedSamlConnection - Information for the SAML Single Sign-On configuration.
type TeamLimitedSamlConnection struct {
	// Timestamp (in milliseconds) of when the configuration was connected.
	ConnectedAt int64 `json:"connectedAt"`
	// Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
	LastReceivedWebhookEvent *int64 `json:"lastReceivedWebhookEvent,omitempty"`
	// Current state of the connection.
	State string `json:"state"`
	// Current status of the connection.
	Status string `json:"status"`
	// The Identity Provider "type", for example Okta.
	Type string `json:"type"`
}

// TeamLimitedSamlDirectory - Information for the SAML Single Sign-On configuration.
type TeamLimitedSamlDirectory struct {
	// Timestamp (in milliseconds) of when the configuration was connected.
	ConnectedAt int64 `json:"connectedAt"`
	// Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
	LastReceivedWebhookEvent *int64 `json:"lastReceivedWebhookEvent,omitempty"`
	// Current state of the connection.
	State string `json:"state"`
	// Current status of the connection.
	Status string `json:"status"`
	// The Identity Provider "type", for example Okta.
	Type string `json:"type"`
}

// TeamLimitedSaml - When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.
type TeamLimitedSaml struct {
	// Information for the SAML Single Sign-On configuration.
	Connection *TeamLimitedSamlConnection `json:"connection,omitempty"`
	// Information for the SAML Single Sign-On configuration.
	Directory *TeamLimitedSamlDirectory `json:"directory,omitempty"`
	// When `true`, interactions with the Team **must** be done with an authentication token that has been authenticated with the Team's SAML Single Sign-On provider.
	Enforced bool `json:"enforced"`
}

// TeamLimited - A limited form of data representing a Team, due to the authentication token missing privileges to read the full Team data.
type TeamLimited struct {
	// The ID of the file used as avatar for this Team.
	Avatar *string `json:"avatar"`
	// Will remain undocumented. Remove in v3 API.
	Created string `json:"created"`
	// UNIX timestamp (in milliseconds) when the Team was created.
	CreatedAt int64 `json:"createdAt"`
	// The Team's unique identifier.
	ID string `json:"id"`
	// Property indicating that this Team data contains only limited information, due to the authentication token missing privileges to read the full Team data. Re-login with the Team's configured SAML Single Sign-On provider in order to upgrade the authentication token with the necessary privileges.
	Limited    bool                  `json:"limited"`
	Membership TeamLimitedMembership `json:"membership"`
	// Name associated with the Team account, or `null` if none has been provided.
	Name *string `json:"name"`
	// When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.
	Saml *TeamLimitedSaml `json:"saml,omitempty"`
	// The Team's slug, which is unique across the Vercel platform.
	Slug string `json:"slug"`
}
