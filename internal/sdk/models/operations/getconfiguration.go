// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/zchee/terraform-provider-vercel/internal/sdk/internal/utils"
	"net/http"
)

type GetConfigurationRequest struct {
	// ID of the configuration to check
	ID string `pathParam:"style=simple,explode=false,name=id"`
	// The Team slug to perform the request on behalf of.
	Slug *string `queryParam:"style=form,explode=true,name=slug"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
}

func (o *GetConfigurationRequest) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetConfigurationRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *GetConfigurationRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

type GetConfigurationDisabledReason string

const (
	GetConfigurationDisabledReasonDisabledByOwner          GetConfigurationDisabledReason = "disabled-by-owner"
	GetConfigurationDisabledReasonFeatureNotAvailable      GetConfigurationDisabledReason = "feature-not-available"
	GetConfigurationDisabledReasonDisabledByAdmin          GetConfigurationDisabledReason = "disabled-by-admin"
	GetConfigurationDisabledReasonOriginalOwnerLeftTheTeam GetConfigurationDisabledReason = "original-owner-left-the-team"
)

func (e GetConfigurationDisabledReason) ToPointer() *GetConfigurationDisabledReason {
	return &e
}
func (e *GetConfigurationDisabledReason) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disabled-by-owner":
		fallthrough
	case "feature-not-available":
		fallthrough
	case "disabled-by-admin":
		fallthrough
	case "original-owner-left-the-team":
		*e = GetConfigurationDisabledReason(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationDisabledReason: %v", v)
	}
}

// GetConfigurationInstallationType - Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
type GetConfigurationInstallationType string

const (
	GetConfigurationInstallationTypeMarketplace GetConfigurationInstallationType = "marketplace"
	GetConfigurationInstallationTypeExternal    GetConfigurationInstallationType = "external"
)

func (e GetConfigurationInstallationType) ToPointer() *GetConfigurationInstallationType {
	return &e
}
func (e *GetConfigurationInstallationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "marketplace":
		fallthrough
	case "external":
		*e = GetConfigurationInstallationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationInstallationType: %v", v)
	}
}

// ProjectSelection - A string representing the permission for projects. Possible values are `all` or `selected`.
type ProjectSelection string

const (
	ProjectSelectionSelected ProjectSelection = "selected"
	ProjectSelectionAll      ProjectSelection = "all"
)

func (e ProjectSelection) ToPointer() *ProjectSelection {
	return &e
}
func (e *ProjectSelection) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "selected":
		fallthrough
	case "all":
		*e = ProjectSelection(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectSelection: %v", v)
	}
}

type GetConfigurationAdded string

const (
	GetConfigurationAddedReadIntegrationConfiguration      GetConfigurationAdded = "read:integration-configuration"
	GetConfigurationAddedReadWriteIntegrationConfiguration GetConfigurationAdded = "read-write:integration-configuration"
	GetConfigurationAddedReadDeployment                    GetConfigurationAdded = "read:deployment"
	GetConfigurationAddedReadWriteDeployment               GetConfigurationAdded = "read-write:deployment"
	GetConfigurationAddedReadWriteDeploymentCheck          GetConfigurationAdded = "read-write:deployment-check"
	GetConfigurationAddedReadProject                       GetConfigurationAdded = "read:project"
	GetConfigurationAddedReadWriteProject                  GetConfigurationAdded = "read-write:project"
	GetConfigurationAddedReadWriteProjectEnvVars           GetConfigurationAdded = "read-write:project-env-vars"
	GetConfigurationAddedReadWriteGlobalProjectEnvVars     GetConfigurationAdded = "read-write:global-project-env-vars"
	GetConfigurationAddedReadTeam                          GetConfigurationAdded = "read:team"
	GetConfigurationAddedReadUser                          GetConfigurationAdded = "read:user"
	GetConfigurationAddedReadWriteLogDrain                 GetConfigurationAdded = "read-write:log-drain"
	GetConfigurationAddedReadDomain                        GetConfigurationAdded = "read:domain"
	GetConfigurationAddedReadWriteDomain                   GetConfigurationAdded = "read-write:domain"
	GetConfigurationAddedReadWriteEdgeConfig               GetConfigurationAdded = "read-write:edge-config"
	GetConfigurationAddedReadWriteOtelEndpoint             GetConfigurationAdded = "read-write:otel-endpoint"
	GetConfigurationAddedReadMonitoring                    GetConfigurationAdded = "read:monitoring"
	GetConfigurationAddedReadWriteIntegrationResource      GetConfigurationAdded = "read-write:integration-resource"
)

func (e GetConfigurationAdded) ToPointer() *GetConfigurationAdded {
	return &e
}
func (e *GetConfigurationAdded) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "read:integration-configuration":
		fallthrough
	case "read-write:integration-configuration":
		fallthrough
	case "read:deployment":
		fallthrough
	case "read-write:deployment":
		fallthrough
	case "read-write:deployment-check":
		fallthrough
	case "read:project":
		fallthrough
	case "read-write:project":
		fallthrough
	case "read-write:project-env-vars":
		fallthrough
	case "read-write:global-project-env-vars":
		fallthrough
	case "read:team":
		fallthrough
	case "read:user":
		fallthrough
	case "read-write:log-drain":
		fallthrough
	case "read:domain":
		fallthrough
	case "read-write:domain":
		fallthrough
	case "read-write:edge-config":
		fallthrough
	case "read-write:otel-endpoint":
		fallthrough
	case "read:monitoring":
		fallthrough
	case "read-write:integration-resource":
		*e = GetConfigurationAdded(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationAdded: %v", v)
	}
}

type GetConfigurationUpgraded string

const (
	GetConfigurationUpgradedReadIntegrationConfiguration      GetConfigurationUpgraded = "read:integration-configuration"
	GetConfigurationUpgradedReadWriteIntegrationConfiguration GetConfigurationUpgraded = "read-write:integration-configuration"
	GetConfigurationUpgradedReadDeployment                    GetConfigurationUpgraded = "read:deployment"
	GetConfigurationUpgradedReadWriteDeployment               GetConfigurationUpgraded = "read-write:deployment"
	GetConfigurationUpgradedReadWriteDeploymentCheck          GetConfigurationUpgraded = "read-write:deployment-check"
	GetConfigurationUpgradedReadProject                       GetConfigurationUpgraded = "read:project"
	GetConfigurationUpgradedReadWriteProject                  GetConfigurationUpgraded = "read-write:project"
	GetConfigurationUpgradedReadWriteProjectEnvVars           GetConfigurationUpgraded = "read-write:project-env-vars"
	GetConfigurationUpgradedReadWriteGlobalProjectEnvVars     GetConfigurationUpgraded = "read-write:global-project-env-vars"
	GetConfigurationUpgradedReadTeam                          GetConfigurationUpgraded = "read:team"
	GetConfigurationUpgradedReadUser                          GetConfigurationUpgraded = "read:user"
	GetConfigurationUpgradedReadWriteLogDrain                 GetConfigurationUpgraded = "read-write:log-drain"
	GetConfigurationUpgradedReadDomain                        GetConfigurationUpgraded = "read:domain"
	GetConfigurationUpgradedReadWriteDomain                   GetConfigurationUpgraded = "read-write:domain"
	GetConfigurationUpgradedReadWriteEdgeConfig               GetConfigurationUpgraded = "read-write:edge-config"
	GetConfigurationUpgradedReadWriteOtelEndpoint             GetConfigurationUpgraded = "read-write:otel-endpoint"
	GetConfigurationUpgradedReadMonitoring                    GetConfigurationUpgraded = "read:monitoring"
	GetConfigurationUpgradedReadWriteIntegrationResource      GetConfigurationUpgraded = "read-write:integration-resource"
)

func (e GetConfigurationUpgraded) ToPointer() *GetConfigurationUpgraded {
	return &e
}
func (e *GetConfigurationUpgraded) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "read:integration-configuration":
		fallthrough
	case "read-write:integration-configuration":
		fallthrough
	case "read:deployment":
		fallthrough
	case "read-write:deployment":
		fallthrough
	case "read-write:deployment-check":
		fallthrough
	case "read:project":
		fallthrough
	case "read-write:project":
		fallthrough
	case "read-write:project-env-vars":
		fallthrough
	case "read-write:global-project-env-vars":
		fallthrough
	case "read:team":
		fallthrough
	case "read:user":
		fallthrough
	case "read-write:log-drain":
		fallthrough
	case "read:domain":
		fallthrough
	case "read-write:domain":
		fallthrough
	case "read-write:edge-config":
		fallthrough
	case "read-write:otel-endpoint":
		fallthrough
	case "read:monitoring":
		fallthrough
	case "read-write:integration-resource":
		*e = GetConfigurationUpgraded(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationUpgraded: %v", v)
	}
}

type GetConfigurationScopes struct {
	Added    []GetConfigurationAdded    `json:"added"`
	Upgraded []GetConfigurationUpgraded `json:"upgraded"`
}

func (o *GetConfigurationScopes) GetAdded() []GetConfigurationAdded {
	if o == nil {
		return []GetConfigurationAdded{}
	}
	return o.Added
}

func (o *GetConfigurationScopes) GetUpgraded() []GetConfigurationUpgraded {
	if o == nil {
		return []GetConfigurationUpgraded{}
	}
	return o.Upgraded
}

type GetConfigurationScopesQueue struct {
	ConfirmedAt *float64               `json:"confirmedAt,omitempty"`
	Note        string                 `json:"note"`
	RequestedAt float64                `json:"requestedAt"`
	Scopes      GetConfigurationScopes `json:"scopes"`
}

func (o *GetConfigurationScopesQueue) GetConfirmedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ConfirmedAt
}

func (o *GetConfigurationScopesQueue) GetNote() string {
	if o == nil {
		return ""
	}
	return o.Note
}

func (o *GetConfigurationScopesQueue) GetRequestedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.RequestedAt
}

func (o *GetConfigurationScopesQueue) GetScopes() GetConfigurationScopes {
	if o == nil {
		return GetConfigurationScopes{}
	}
	return o.Scopes
}

// GetConfigurationIntegrationsSource - Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
type GetConfigurationIntegrationsSource string

const (
	GetConfigurationIntegrationsSourceMarketplace  GetConfigurationIntegrationsSource = "marketplace"
	GetConfigurationIntegrationsSourceDeployButton GetConfigurationIntegrationsSource = "deploy-button"
	GetConfigurationIntegrationsSourceExternal     GetConfigurationIntegrationsSource = "external"
)

func (e GetConfigurationIntegrationsSource) ToPointer() *GetConfigurationIntegrationsSource {
	return &e
}
func (e *GetConfigurationIntegrationsSource) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "marketplace":
		fallthrough
	case "deploy-button":
		fallthrough
	case "external":
		*e = GetConfigurationIntegrationsSource(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationIntegrationsSource: %v", v)
	}
}

type GetConfigurationIntegrationsType string

const (
	GetConfigurationIntegrationsTypeIntegrationConfiguration GetConfigurationIntegrationsType = "integration-configuration"
)

func (e GetConfigurationIntegrationsType) ToPointer() *GetConfigurationIntegrationsType {
	return &e
}
func (e *GetConfigurationIntegrationsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration-configuration":
		*e = GetConfigurationIntegrationsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationIntegrationsType: %v", v)
	}
}

type GetConfiguration2 struct {
	CanConfigureOpenTelemetry *bool `json:"canConfigureOpenTelemetry,omitempty"`
	// A timestamp that tells you when the configuration was installed successfully
	CompletedAt *float64 `json:"completedAt,omitempty"`
	// A timestamp that tells you when the configuration was created
	CreatedAt float64 `json:"createdAt"`
	// A timestamp that tells you when the configuration was updated.
	DeletedAt *float64 `json:"deletedAt,omitempty"`
	// A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
	DisabledAt     *float64                        `json:"disabledAt,omitempty"`
	DisabledReason *GetConfigurationDisabledReason `json:"disabledReason,omitempty"`
	// The unique identifier of the configuration
	ID string `json:"id"`
	// Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
	InstallationType *GetConfigurationInstallationType `json:"installationType,omitempty"`
	// The unique identifier of the app the configuration was created for
	IntegrationID string `json:"integrationId"`
	// A timestamp that tells you when the configuration was migrated as part of the Northstar migration. In the future, if we allow integration configurations to be transferred between teams, this field should be cleared upon transfer.
	NorthstarMigratedAt *float64 `json:"northstarMigratedAt,omitempty"`
	// The user or team ID that owns the configuration
	OwnerID string `json:"ownerId"`
	// A string representing the permission for projects. Possible values are `all` or `selected`.
	ProjectSelection ProjectSelection `json:"projectSelection"`
	// When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
	Projects             []string `json:"projects,omitempty"`
	RemovedLogDrainsAt   *float64 `json:"removedLogDrainsAt,omitempty"`
	RemovedProjectEnvsAt *float64 `json:"removedProjectEnvsAt,omitempty"`
	RemovedTokensAt      *float64 `json:"removedTokensAt,omitempty"`
	RemovedWebhooksAt    *float64 `json:"removedWebhooksAt,omitempty"`
	// The resources that are allowed to be accessed by the configuration.
	Scopes      []string                      `json:"scopes"`
	ScopesQueue []GetConfigurationScopesQueue `json:"scopesQueue,omitempty"`
	// The slug of the integration the configuration is created for.
	Slug string `json:"slug"`
	// Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
	Source *GetConfigurationIntegrationsSource `json:"source,omitempty"`
	// When the configuration was created for a team, this will show the ID of the team.
	TeamID *string                          `json:"teamId,omitempty"`
	Type   GetConfigurationIntegrationsType `json:"type"`
	// A timestamp that tells you when the configuration was updated.
	UpdatedAt float64 `json:"updatedAt"`
	// The ID of the user that created the configuration.
	UserID string `json:"userId"`
}

func (o *GetConfiguration2) GetCanConfigureOpenTelemetry() *bool {
	if o == nil {
		return nil
	}
	return o.CanConfigureOpenTelemetry
}

func (o *GetConfiguration2) GetCompletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CompletedAt
}

func (o *GetConfiguration2) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetConfiguration2) GetDeletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DeletedAt
}

func (o *GetConfiguration2) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *GetConfiguration2) GetDisabledReason() *GetConfigurationDisabledReason {
	if o == nil {
		return nil
	}
	return o.DisabledReason
}

func (o *GetConfiguration2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetConfiguration2) GetInstallationType() *GetConfigurationInstallationType {
	if o == nil {
		return nil
	}
	return o.InstallationType
}

func (o *GetConfiguration2) GetIntegrationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationID
}

func (o *GetConfiguration2) GetNorthstarMigratedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.NorthstarMigratedAt
}

func (o *GetConfiguration2) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *GetConfiguration2) GetProjectSelection() ProjectSelection {
	if o == nil {
		return ProjectSelection("")
	}
	return o.ProjectSelection
}

func (o *GetConfiguration2) GetProjects() []string {
	if o == nil {
		return nil
	}
	return o.Projects
}

func (o *GetConfiguration2) GetRemovedLogDrainsAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedLogDrainsAt
}

func (o *GetConfiguration2) GetRemovedProjectEnvsAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedProjectEnvsAt
}

func (o *GetConfiguration2) GetRemovedTokensAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedTokensAt
}

func (o *GetConfiguration2) GetRemovedWebhooksAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedWebhooksAt
}

func (o *GetConfiguration2) GetScopes() []string {
	if o == nil {
		return []string{}
	}
	return o.Scopes
}

func (o *GetConfiguration2) GetScopesQueue() []GetConfigurationScopesQueue {
	if o == nil {
		return nil
	}
	return o.ScopesQueue
}

func (o *GetConfiguration2) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *GetConfiguration2) GetSource() *GetConfigurationIntegrationsSource {
	if o == nil {
		return nil
	}
	return o.Source
}

func (o *GetConfiguration2) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetConfiguration2) GetType() GetConfigurationIntegrationsType {
	if o == nil {
		return GetConfigurationIntegrationsType("")
	}
	return o.Type
}

func (o *GetConfiguration2) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *GetConfiguration2) GetUserID() string {
	if o == nil {
		return ""
	}
	return o.UserID
}

type GetConfigurationIntegrationsDisabledReason string

const (
	GetConfigurationIntegrationsDisabledReasonDisabledByOwner          GetConfigurationIntegrationsDisabledReason = "disabled-by-owner"
	GetConfigurationIntegrationsDisabledReasonFeatureNotAvailable      GetConfigurationIntegrationsDisabledReason = "feature-not-available"
	GetConfigurationIntegrationsDisabledReasonDisabledByAdmin          GetConfigurationIntegrationsDisabledReason = "disabled-by-admin"
	GetConfigurationIntegrationsDisabledReasonOriginalOwnerLeftTheTeam GetConfigurationIntegrationsDisabledReason = "original-owner-left-the-team"
)

func (e GetConfigurationIntegrationsDisabledReason) ToPointer() *GetConfigurationIntegrationsDisabledReason {
	return &e
}
func (e *GetConfigurationIntegrationsDisabledReason) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disabled-by-owner":
		fallthrough
	case "feature-not-available":
		fallthrough
	case "disabled-by-admin":
		fallthrough
	case "original-owner-left-the-team":
		*e = GetConfigurationIntegrationsDisabledReason(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationIntegrationsDisabledReason: %v", v)
	}
}

// InstallationType - Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
type InstallationType string

const (
	InstallationTypeMarketplace InstallationType = "marketplace"
	InstallationTypeExternal    InstallationType = "external"
)

func (e InstallationType) ToPointer() *InstallationType {
	return &e
}
func (e *InstallationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "marketplace":
		fallthrough
	case "external":
		*e = InstallationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InstallationType: %v", v)
	}
}

type Added string

const (
	AddedReadIntegrationConfiguration      Added = "read:integration-configuration"
	AddedReadWriteIntegrationConfiguration Added = "read-write:integration-configuration"
	AddedReadDeployment                    Added = "read:deployment"
	AddedReadWriteDeployment               Added = "read-write:deployment"
	AddedReadWriteDeploymentCheck          Added = "read-write:deployment-check"
	AddedReadProject                       Added = "read:project"
	AddedReadWriteProject                  Added = "read-write:project"
	AddedReadWriteProjectEnvVars           Added = "read-write:project-env-vars"
	AddedReadWriteGlobalProjectEnvVars     Added = "read-write:global-project-env-vars"
	AddedReadTeam                          Added = "read:team"
	AddedReadUser                          Added = "read:user"
	AddedReadWriteLogDrain                 Added = "read-write:log-drain"
	AddedReadDomain                        Added = "read:domain"
	AddedReadWriteDomain                   Added = "read-write:domain"
	AddedReadWriteEdgeConfig               Added = "read-write:edge-config"
	AddedReadWriteOtelEndpoint             Added = "read-write:otel-endpoint"
	AddedReadMonitoring                    Added = "read:monitoring"
	AddedReadWriteIntegrationResource      Added = "read-write:integration-resource"
)

func (e Added) ToPointer() *Added {
	return &e
}
func (e *Added) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "read:integration-configuration":
		fallthrough
	case "read-write:integration-configuration":
		fallthrough
	case "read:deployment":
		fallthrough
	case "read-write:deployment":
		fallthrough
	case "read-write:deployment-check":
		fallthrough
	case "read:project":
		fallthrough
	case "read-write:project":
		fallthrough
	case "read-write:project-env-vars":
		fallthrough
	case "read-write:global-project-env-vars":
		fallthrough
	case "read:team":
		fallthrough
	case "read:user":
		fallthrough
	case "read-write:log-drain":
		fallthrough
	case "read:domain":
		fallthrough
	case "read-write:domain":
		fallthrough
	case "read-write:edge-config":
		fallthrough
	case "read-write:otel-endpoint":
		fallthrough
	case "read:monitoring":
		fallthrough
	case "read-write:integration-resource":
		*e = Added(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Added: %v", v)
	}
}

type Upgraded string

const (
	UpgradedReadIntegrationConfiguration      Upgraded = "read:integration-configuration"
	UpgradedReadWriteIntegrationConfiguration Upgraded = "read-write:integration-configuration"
	UpgradedReadDeployment                    Upgraded = "read:deployment"
	UpgradedReadWriteDeployment               Upgraded = "read-write:deployment"
	UpgradedReadWriteDeploymentCheck          Upgraded = "read-write:deployment-check"
	UpgradedReadProject                       Upgraded = "read:project"
	UpgradedReadWriteProject                  Upgraded = "read-write:project"
	UpgradedReadWriteProjectEnvVars           Upgraded = "read-write:project-env-vars"
	UpgradedReadWriteGlobalProjectEnvVars     Upgraded = "read-write:global-project-env-vars"
	UpgradedReadTeam                          Upgraded = "read:team"
	UpgradedReadUser                          Upgraded = "read:user"
	UpgradedReadWriteLogDrain                 Upgraded = "read-write:log-drain"
	UpgradedReadDomain                        Upgraded = "read:domain"
	UpgradedReadWriteDomain                   Upgraded = "read-write:domain"
	UpgradedReadWriteEdgeConfig               Upgraded = "read-write:edge-config"
	UpgradedReadWriteOtelEndpoint             Upgraded = "read-write:otel-endpoint"
	UpgradedReadMonitoring                    Upgraded = "read:monitoring"
	UpgradedReadWriteIntegrationResource      Upgraded = "read-write:integration-resource"
)

func (e Upgraded) ToPointer() *Upgraded {
	return &e
}
func (e *Upgraded) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "read:integration-configuration":
		fallthrough
	case "read-write:integration-configuration":
		fallthrough
	case "read:deployment":
		fallthrough
	case "read-write:deployment":
		fallthrough
	case "read-write:deployment-check":
		fallthrough
	case "read:project":
		fallthrough
	case "read-write:project":
		fallthrough
	case "read-write:project-env-vars":
		fallthrough
	case "read-write:global-project-env-vars":
		fallthrough
	case "read:team":
		fallthrough
	case "read:user":
		fallthrough
	case "read-write:log-drain":
		fallthrough
	case "read:domain":
		fallthrough
	case "read-write:domain":
		fallthrough
	case "read-write:edge-config":
		fallthrough
	case "read-write:otel-endpoint":
		fallthrough
	case "read:monitoring":
		fallthrough
	case "read-write:integration-resource":
		*e = Upgraded(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Upgraded: %v", v)
	}
}

type Scopes struct {
	Added    []Added    `json:"added"`
	Upgraded []Upgraded `json:"upgraded"`
}

func (o *Scopes) GetAdded() []Added {
	if o == nil {
		return []Added{}
	}
	return o.Added
}

func (o *Scopes) GetUpgraded() []Upgraded {
	if o == nil {
		return []Upgraded{}
	}
	return o.Upgraded
}

type ScopesQueue struct {
	ConfirmedAt *float64 `json:"confirmedAt,omitempty"`
	Note        string   `json:"note"`
	RequestedAt float64  `json:"requestedAt"`
	Scopes      Scopes   `json:"scopes"`
}

func (o *ScopesQueue) GetConfirmedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ConfirmedAt
}

func (o *ScopesQueue) GetNote() string {
	if o == nil {
		return ""
	}
	return o.Note
}

func (o *ScopesQueue) GetRequestedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.RequestedAt
}

func (o *ScopesQueue) GetScopes() Scopes {
	if o == nil {
		return Scopes{}
	}
	return o.Scopes
}

// GetConfigurationSource - Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
type GetConfigurationSource string

const (
	GetConfigurationSourceMarketplace  GetConfigurationSource = "marketplace"
	GetConfigurationSourceDeployButton GetConfigurationSource = "deploy-button"
	GetConfigurationSourceExternal     GetConfigurationSource = "external"
)

func (e GetConfigurationSource) ToPointer() *GetConfigurationSource {
	return &e
}
func (e *GetConfigurationSource) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "marketplace":
		fallthrough
	case "deploy-button":
		fallthrough
	case "external":
		*e = GetConfigurationSource(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationSource: %v", v)
	}
}

type GetConfigurationType string

const (
	GetConfigurationTypeIntegrationConfiguration GetConfigurationType = "integration-configuration"
)

func (e GetConfigurationType) ToPointer() *GetConfigurationType {
	return &e
}
func (e *GetConfigurationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration-configuration":
		*e = GetConfigurationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationType: %v", v)
	}
}

// GetConfiguration1 - The configuration with the provided id
type GetConfiguration1 struct {
	// A timestamp that tells you when the configuration was installed successfully
	CompletedAt *float64 `json:"completedAt,omitempty"`
	// A timestamp that tells you when the configuration was created
	CreatedAt float64 `json:"createdAt"`
	// A timestamp that tells you when the configuration was updated.
	DeletedAt *float64 `json:"deletedAt,omitempty"`
	// A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
	DisabledAt     *float64                                    `json:"disabledAt,omitempty"`
	DisabledReason *GetConfigurationIntegrationsDisabledReason `json:"disabledReason,omitempty"`
	// The unique identifier of the configuration
	ID string `json:"id"`
	// Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
	InstallationType *InstallationType `json:"installationType,omitempty"`
	// The unique identifier of the app the configuration was created for
	IntegrationID string `json:"integrationId"`
	// A timestamp that tells you when the configuration was migrated as part of the Northstar migration. In the future, if we allow integration configurations to be transferred between teams, this field should be cleared upon transfer.
	NorthstarMigratedAt *float64 `json:"northstarMigratedAt,omitempty"`
	// The user or team ID that owns the configuration
	OwnerID string `json:"ownerId"`
	// When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
	Projects             []string `json:"projects,omitempty"`
	RemovedLogDrainsAt   *float64 `json:"removedLogDrainsAt,omitempty"`
	RemovedProjectEnvsAt *float64 `json:"removedProjectEnvsAt,omitempty"`
	RemovedTokensAt      *float64 `json:"removedTokensAt,omitempty"`
	RemovedWebhooksAt    *float64 `json:"removedWebhooksAt,omitempty"`
	// The resources that are allowed to be accessed by the configuration.
	Scopes      []string      `json:"scopes"`
	ScopesQueue []ScopesQueue `json:"scopesQueue,omitempty"`
	// The slug of the integration the configuration is created for.
	Slug string `json:"slug"`
	// Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
	Source *GetConfigurationSource `json:"source,omitempty"`
	// When the configuration was created for a team, this will show the ID of the team.
	TeamID *string              `json:"teamId,omitempty"`
	Type   GetConfigurationType `json:"type"`
	// A timestamp that tells you when the configuration was updated.
	UpdatedAt float64 `json:"updatedAt"`
	// The ID of the user that created the configuration.
	UserID string `json:"userId"`
}

func (o *GetConfiguration1) GetCompletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CompletedAt
}

func (o *GetConfiguration1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetConfiguration1) GetDeletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DeletedAt
}

func (o *GetConfiguration1) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *GetConfiguration1) GetDisabledReason() *GetConfigurationIntegrationsDisabledReason {
	if o == nil {
		return nil
	}
	return o.DisabledReason
}

func (o *GetConfiguration1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetConfiguration1) GetInstallationType() *InstallationType {
	if o == nil {
		return nil
	}
	return o.InstallationType
}

func (o *GetConfiguration1) GetIntegrationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationID
}

func (o *GetConfiguration1) GetNorthstarMigratedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.NorthstarMigratedAt
}

func (o *GetConfiguration1) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *GetConfiguration1) GetProjects() []string {
	if o == nil {
		return nil
	}
	return o.Projects
}

func (o *GetConfiguration1) GetRemovedLogDrainsAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedLogDrainsAt
}

func (o *GetConfiguration1) GetRemovedProjectEnvsAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedProjectEnvsAt
}

func (o *GetConfiguration1) GetRemovedTokensAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedTokensAt
}

func (o *GetConfiguration1) GetRemovedWebhooksAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedWebhooksAt
}

func (o *GetConfiguration1) GetScopes() []string {
	if o == nil {
		return []string{}
	}
	return o.Scopes
}

func (o *GetConfiguration1) GetScopesQueue() []ScopesQueue {
	if o == nil {
		return nil
	}
	return o.ScopesQueue
}

func (o *GetConfiguration1) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *GetConfiguration1) GetSource() *GetConfigurationSource {
	if o == nil {
		return nil
	}
	return o.Source
}

func (o *GetConfiguration1) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetConfiguration1) GetType() GetConfigurationType {
	if o == nil {
		return GetConfigurationType("")
	}
	return o.Type
}

func (o *GetConfiguration1) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *GetConfiguration1) GetUserID() string {
	if o == nil {
		return ""
	}
	return o.UserID
}

type GetConfigurationResponseBodyType string

const (
	GetConfigurationResponseBodyTypeGetConfiguration1 GetConfigurationResponseBodyType = "getConfiguration_1"
	GetConfigurationResponseBodyTypeGetConfiguration2 GetConfigurationResponseBodyType = "getConfiguration_2"
)

// GetConfigurationResponseBody - The configuration with the provided id
type GetConfigurationResponseBody struct {
	GetConfiguration1 *GetConfiguration1
	GetConfiguration2 *GetConfiguration2

	Type GetConfigurationResponseBodyType
}

func CreateGetConfigurationResponseBodyGetConfiguration1(getConfiguration1 GetConfiguration1) GetConfigurationResponseBody {
	typ := GetConfigurationResponseBodyTypeGetConfiguration1

	return GetConfigurationResponseBody{
		GetConfiguration1: &getConfiguration1,
		Type:              typ,
	}
}

func CreateGetConfigurationResponseBodyGetConfiguration2(getConfiguration2 GetConfiguration2) GetConfigurationResponseBody {
	typ := GetConfigurationResponseBodyTypeGetConfiguration2

	return GetConfigurationResponseBody{
		GetConfiguration2: &getConfiguration2,
		Type:              typ,
	}
}

func (u *GetConfigurationResponseBody) UnmarshalJSON(data []byte) error {

	var getConfiguration1 GetConfiguration1 = GetConfiguration1{}
	if err := utils.UnmarshalJSON(data, &getConfiguration1, "", true, true); err == nil {
		u.GetConfiguration1 = &getConfiguration1
		u.Type = GetConfigurationResponseBodyTypeGetConfiguration1
		return nil
	}

	var getConfiguration2 GetConfiguration2 = GetConfiguration2{}
	if err := utils.UnmarshalJSON(data, &getConfiguration2, "", true, true); err == nil {
		u.GetConfiguration2 = &getConfiguration2
		u.Type = GetConfigurationResponseBodyTypeGetConfiguration2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetConfigurationResponseBody", string(data))
}

func (u GetConfigurationResponseBody) MarshalJSON() ([]byte, error) {
	if u.GetConfiguration1 != nil {
		return utils.MarshalJSON(u.GetConfiguration1, "", true)
	}

	if u.GetConfiguration2 != nil {
		return utils.MarshalJSON(u.GetConfiguration2, "", true)
	}

	return nil, errors.New("could not marshal union type GetConfigurationResponseBody: all fields are null")
}

type GetConfigurationResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// The configuration with the provided id
	OneOf *GetConfigurationResponseBody
}

func (o *GetConfigurationResponse) GetContentType() string {
	if o == nil {
		return ""
	}
	return o.ContentType
}

func (o *GetConfigurationResponse) GetStatusCode() int {
	if o == nil {
		return 0
	}
	return o.StatusCode
}

func (o *GetConfigurationResponse) GetRawResponse() *http.Response {
	if o == nil {
		return nil
	}
	return o.RawResponse
}

func (o *GetConfigurationResponse) GetOneOf() *GetConfigurationResponseBody {
	if o == nil {
		return nil
	}
	return o.OneOf
}
