// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/vercel/terraform-provider-terraform/internal/sdk/internal/utils"
	"net/http"
)

// ForceNew - Forces a new deployment even if there is a previous similar deployment
type ForceNew string

const (
	ForceNewZero ForceNew = "0"
	ForceNewOne  ForceNew = "1"
)

func (e ForceNew) ToPointer() *ForceNew {
	return &e
}
func (e *ForceNew) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "0":
		fallthrough
	case "1":
		*e = ForceNew(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ForceNew: %v", v)
	}
}

// SkipAutoDetectionConfirmation - Allows to skip framework detection so the API would not fail to ask for confirmation
type SkipAutoDetectionConfirmation string

const (
	SkipAutoDetectionConfirmationZero SkipAutoDetectionConfirmation = "0"
	SkipAutoDetectionConfirmationOne  SkipAutoDetectionConfirmation = "1"
)

func (e SkipAutoDetectionConfirmation) ToPointer() *SkipAutoDetectionConfirmation {
	return &e
}
func (e *SkipAutoDetectionConfirmation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "0":
		fallthrough
	case "1":
		*e = SkipAutoDetectionConfirmation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SkipAutoDetectionConfirmation: %v", v)
	}
}

// UploadedFile - Used in the case you want to reference a file that was already uploaded
type UploadedFile struct {
	// The file path relative to the project root
	File string `json:"file"`
	// The file contents hashed with SHA1, used to check the integrity
	Sha *string `json:"sha,omitempty"`
	// The file size in bytes
	Size *int64 `json:"size,omitempty"`
}

func (o *UploadedFile) GetFile() string {
	if o == nil {
		return ""
	}
	return o.File
}

func (o *UploadedFile) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *UploadedFile) GetSize() *int64 {
	if o == nil {
		return nil
	}
	return o.Size
}

// Encoding - The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
type Encoding string

const (
	EncodingBase64 Encoding = "base64"
	EncodingUTF8   Encoding = "utf-8"
)

func (e Encoding) ToPointer() *Encoding {
	return &e
}
func (e *Encoding) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "base64":
		fallthrough
	case "utf-8":
		*e = Encoding(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Encoding: %v", v)
	}
}

// InlinedFile - Used in the case you want to inline a file inside the request
type InlinedFile struct {
	// The file content, it could be either a `base64` (useful for images, etc.) of the files or the plain content for source code
	Data string `json:"data"`
	// The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
	Encoding *Encoding `json:"encoding,omitempty"`
	// The file name including the whole path
	File string `json:"file"`
}

func (o *InlinedFile) GetData() string {
	if o == nil {
		return ""
	}
	return o.Data
}

func (o *InlinedFile) GetEncoding() *Encoding {
	if o == nil {
		return nil
	}
	return o.Encoding
}

func (o *InlinedFile) GetFile() string {
	if o == nil {
		return ""
	}
	return o.File
}

type FilesType string

const (
	FilesTypeInlinedFile  FilesType = "InlinedFile"
	FilesTypeUploadedFile FilesType = "UploadedFile"
)

type Files struct {
	InlinedFile  *InlinedFile
	UploadedFile *UploadedFile

	Type FilesType
}

func CreateFilesInlinedFile(inlinedFile InlinedFile) Files {
	typ := FilesTypeInlinedFile

	return Files{
		InlinedFile: &inlinedFile,
		Type:        typ,
	}
}

func CreateFilesUploadedFile(uploadedFile UploadedFile) Files {
	typ := FilesTypeUploadedFile

	return Files{
		UploadedFile: &uploadedFile,
		Type:         typ,
	}
}

func (u *Files) UnmarshalJSON(data []byte) error {

	var inlinedFile InlinedFile = InlinedFile{}
	if err := utils.UnmarshalJSON(data, &inlinedFile, "", true, true); err == nil {
		u.InlinedFile = &inlinedFile
		u.Type = FilesTypeInlinedFile
		return nil
	}

	var uploadedFile UploadedFile = UploadedFile{}
	if err := utils.UnmarshalJSON(data, &uploadedFile, "", true, true); err == nil {
		u.UploadedFile = &uploadedFile
		u.Type = FilesTypeUploadedFile
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Files", string(data))
}

func (u Files) MarshalJSON() ([]byte, error) {
	if u.InlinedFile != nil {
		return utils.MarshalJSON(u.InlinedFile, "", true)
	}

	if u.UploadedFile != nil {
		return utils.MarshalJSON(u.UploadedFile, "", true)
	}

	return nil, errors.New("could not marshal union type Files: all fields are null")
}

// GitMetadata - Populates initial git metadata for different git providers.
type GitMetadata struct {
	// The git repository's remote origin url
	RemoteURL *string `json:"remoteUrl,omitempty"`
	// The name of the author of the commit
	CommitAuthorName *string `json:"commitAuthorName,omitempty"`
	// The commit message
	CommitMessage *string `json:"commitMessage,omitempty"`
	// The branch on which the commit was made
	CommitRef *string `json:"commitRef,omitempty"`
	// The hash of the commit
	CommitSha *string `json:"commitSha,omitempty"`
	// Whether or not there have been modifications to the working tree since the latest commit
	Dirty *bool `json:"dirty,omitempty"`
}

func (o *GitMetadata) GetRemoteURL() *string {
	if o == nil {
		return nil
	}
	return o.RemoteURL
}

func (o *GitMetadata) GetCommitAuthorName() *string {
	if o == nil {
		return nil
	}
	return o.CommitAuthorName
}

func (o *GitMetadata) GetCommitMessage() *string {
	if o == nil {
		return nil
	}
	return o.CommitMessage
}

func (o *GitMetadata) GetCommitRef() *string {
	if o == nil {
		return nil
	}
	return o.CommitRef
}

func (o *GitMetadata) GetCommitSha() *string {
	if o == nil {
		return nil
	}
	return o.CommitSha
}

func (o *GitMetadata) GetDirty() *bool {
	if o == nil {
		return nil
	}
	return o.Dirty
}

type CreateDeploymentGitSourceDeploymentsRequestType string

const (
	CreateDeploymentGitSourceDeploymentsRequestTypeBitbucket CreateDeploymentGitSourceDeploymentsRequestType = "bitbucket"
)

func (e CreateDeploymentGitSourceDeploymentsRequestType) ToPointer() *CreateDeploymentGitSourceDeploymentsRequestType {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsRequestType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceDeploymentsRequestType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsRequestType: %v", v)
	}
}

type Five struct {
	Owner string                                          `json:"owner"`
	Ref   string                                          `json:"ref"`
	Sha   *string                                         `json:"sha,omitempty"`
	Slug  string                                          `json:"slug"`
	Type  CreateDeploymentGitSourceDeploymentsRequestType `json:"type"`
}

func (o *Five) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *Five) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *Five) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *Five) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *Five) GetType() CreateDeploymentGitSourceDeploymentsRequestType {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsRequestType("")
	}
	return o.Type
}

type CreateDeploymentGitSourceDeploymentsType string

const (
	CreateDeploymentGitSourceDeploymentsTypeBitbucket CreateDeploymentGitSourceDeploymentsType = "bitbucket"
)

func (e CreateDeploymentGitSourceDeploymentsType) ToPointer() *CreateDeploymentGitSourceDeploymentsType {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceDeploymentsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsType: %v", v)
	}
}

type Four struct {
	Ref           string                                   `json:"ref"`
	RepoUUID      string                                   `json:"repoUuid"`
	Sha           *string                                  `json:"sha,omitempty"`
	Type          CreateDeploymentGitSourceDeploymentsType `json:"type"`
	WorkspaceUUID *string                                  `json:"workspaceUuid,omitempty"`
}

func (o *Four) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *Four) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

func (o *Four) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *Four) GetType() CreateDeploymentGitSourceDeploymentsType {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsType("")
	}
	return o.Type
}

func (o *Four) GetWorkspaceUUID() *string {
	if o == nil {
		return nil
	}
	return o.WorkspaceUUID
}

type ProjectIDType string

const (
	ProjectIDTypeNumber ProjectIDType = "number"
	ProjectIDTypeStr    ProjectIDType = "str"
)

type ProjectID struct {
	Number *float64
	Str    *string

	Type ProjectIDType
}

func CreateProjectIDNumber(number float64) ProjectID {
	typ := ProjectIDTypeNumber

	return ProjectID{
		Number: &number,
		Type:   typ,
	}
}

func CreateProjectIDStr(str string) ProjectID {
	typ := ProjectIDTypeStr

	return ProjectID{
		Str:  &str,
		Type: typ,
	}
}

func (u *ProjectID) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = ProjectIDTypeNumber
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ProjectIDTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectID", string(data))
}

func (u ProjectID) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectID: all fields are null")
}

type CreateDeploymentGitSourceType string

const (
	CreateDeploymentGitSourceTypeGitlab CreateDeploymentGitSourceType = "gitlab"
)

func (e CreateDeploymentGitSourceType) ToPointer() *CreateDeploymentGitSourceType {
	return &e
}
func (e *CreateDeploymentGitSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = CreateDeploymentGitSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceType: %v", v)
	}
}

type Three struct {
	ProjectID ProjectID                     `json:"projectId"`
	Ref       string                        `json:"ref"`
	Sha       *string                       `json:"sha,omitempty"`
	Type      CreateDeploymentGitSourceType `json:"type"`
}

func (o *Three) GetProjectID() ProjectID {
	if o == nil {
		return ProjectID{}
	}
	return o.ProjectID
}

func (o *Three) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *Three) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *Three) GetType() CreateDeploymentGitSourceType {
	if o == nil {
		return CreateDeploymentGitSourceType("")
	}
	return o.Type
}

type GitSourceType string

const (
	GitSourceTypeGithub GitSourceType = "github"
)

func (e GitSourceType) ToPointer() *GitSourceType {
	return &e
}
func (e *GitSourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = GitSourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GitSourceType: %v", v)
	}
}

type Two struct {
	Org  string        `json:"org"`
	Ref  string        `json:"ref"`
	Repo string        `json:"repo"`
	Sha  *string       `json:"sha,omitempty"`
	Type GitSourceType `json:"type"`
}

func (o *Two) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *Two) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *Two) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *Two) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *Two) GetType() GitSourceType {
	if o == nil {
		return GitSourceType("")
	}
	return o.Type
}

type RepoIDType string

const (
	RepoIDTypeNumber RepoIDType = "number"
	RepoIDTypeStr    RepoIDType = "str"
)

type RepoID struct {
	Number *float64
	Str    *string

	Type RepoIDType
}

func CreateRepoIDNumber(number float64) RepoID {
	typ := RepoIDTypeNumber

	return RepoID{
		Number: &number,
		Type:   typ,
	}
}

func CreateRepoIDStr(str string) RepoID {
	typ := RepoIDTypeStr

	return RepoID{
		Str:  &str,
		Type: typ,
	}
}

func (u *RepoID) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = RepoIDTypeNumber
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = RepoIDTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RepoID", string(data))
}

func (u RepoID) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type RepoID: all fields are null")
}

type Type string

const (
	TypeGithub Type = "github"
)

func (e Type) ToPointer() *Type {
	return &e
}
func (e *Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Type: %v", v)
	}
}

type One struct {
	Ref    string  `json:"ref"`
	RepoID RepoID  `json:"repoId"`
	Sha    *string `json:"sha,omitempty"`
	Type   Type    `json:"type"`
}

func (o *One) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *One) GetRepoID() RepoID {
	if o == nil {
		return RepoID{}
	}
	return o.RepoID
}

func (o *One) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *One) GetType() Type {
	if o == nil {
		return Type("")
	}
	return o.Type
}

type GitSourceUnionType string

const (
	GitSourceUnionTypeOne   GitSourceUnionType = "1"
	GitSourceUnionTypeTwo   GitSourceUnionType = "2"
	GitSourceUnionTypeThree GitSourceUnionType = "3"
	GitSourceUnionTypeFour  GitSourceUnionType = "4"
	GitSourceUnionTypeFive  GitSourceUnionType = "5"
)

// GitSource - Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.
type GitSource struct {
	One   *One
	Two   *Two
	Three *Three
	Four  *Four
	Five  *Five

	Type GitSourceUnionType
}

func CreateGitSourceOne(one One) GitSource {
	typ := GitSourceUnionTypeOne

	return GitSource{
		One:  &one,
		Type: typ,
	}
}

func CreateGitSourceTwo(two Two) GitSource {
	typ := GitSourceUnionTypeTwo

	return GitSource{
		Two:  &two,
		Type: typ,
	}
}

func CreateGitSourceThree(three Three) GitSource {
	typ := GitSourceUnionTypeThree

	return GitSource{
		Three: &three,
		Type:  typ,
	}
}

func CreateGitSourceFour(four Four) GitSource {
	typ := GitSourceUnionTypeFour

	return GitSource{
		Four: &four,
		Type: typ,
	}
}

func CreateGitSourceFive(five Five) GitSource {
	typ := GitSourceUnionTypeFive

	return GitSource{
		Five: &five,
		Type: typ,
	}
}

func (u *GitSource) UnmarshalJSON(data []byte) error {

	var one One = One{}
	if err := utils.UnmarshalJSON(data, &one, "", true, true); err == nil {
		u.One = &one
		u.Type = GitSourceUnionTypeOne
		return nil
	}

	var three Three = Three{}
	if err := utils.UnmarshalJSON(data, &three, "", true, true); err == nil {
		u.Three = &three
		u.Type = GitSourceUnionTypeThree
		return nil
	}

	var two Two = Two{}
	if err := utils.UnmarshalJSON(data, &two, "", true, true); err == nil {
		u.Two = &two
		u.Type = GitSourceUnionTypeTwo
		return nil
	}

	var four Four = Four{}
	if err := utils.UnmarshalJSON(data, &four, "", true, true); err == nil {
		u.Four = &four
		u.Type = GitSourceUnionTypeFour
		return nil
	}

	var five Five = Five{}
	if err := utils.UnmarshalJSON(data, &five, "", true, true); err == nil {
		u.Five = &five
		u.Type = GitSourceUnionTypeFive
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GitSource", string(data))
}

func (u GitSource) MarshalJSON() ([]byte, error) {
	if u.One != nil {
		return utils.MarshalJSON(u.One, "", true)
	}

	if u.Two != nil {
		return utils.MarshalJSON(u.Two, "", true)
	}

	if u.Three != nil {
		return utils.MarshalJSON(u.Three, "", true)
	}

	if u.Four != nil {
		return utils.MarshalJSON(u.Four, "", true)
	}

	if u.Five != nil {
		return utils.MarshalJSON(u.Five, "", true)
	}

	return nil, errors.New("could not marshal union type GitSource: all fields are null")
}

// Framework - The framework that is being used for this project. When `null` is used no framework is selected
type Framework string

const (
	FrameworkBlitzjs        Framework = "blitzjs"
	FrameworkNextjs         Framework = "nextjs"
	FrameworkGatsby         Framework = "gatsby"
	FrameworkRemix          Framework = "remix"
	FrameworkAstro          Framework = "astro"
	FrameworkHexo           Framework = "hexo"
	FrameworkEleventy       Framework = "eleventy"
	FrameworkDocusaurus2    Framework = "docusaurus-2"
	FrameworkDocusaurus     Framework = "docusaurus"
	FrameworkPreact         Framework = "preact"
	FrameworkSolidstart1    Framework = "solidstart-1"
	FrameworkSolidstart     Framework = "solidstart"
	FrameworkDojo           Framework = "dojo"
	FrameworkEmber          Framework = "ember"
	FrameworkVue            Framework = "vue"
	FrameworkScully         Framework = "scully"
	FrameworkIonicAngular   Framework = "ionic-angular"
	FrameworkAngular        Framework = "angular"
	FrameworkPolymer        Framework = "polymer"
	FrameworkSvelte         Framework = "svelte"
	FrameworkSveltekit      Framework = "sveltekit"
	FrameworkSveltekit1     Framework = "sveltekit-1"
	FrameworkIonicReact     Framework = "ionic-react"
	FrameworkCreateReactApp Framework = "create-react-app"
	FrameworkGridsome       Framework = "gridsome"
	FrameworkUmijs          Framework = "umijs"
	FrameworkSapper         Framework = "sapper"
	FrameworkSaber          Framework = "saber"
	FrameworkStencil        Framework = "stencil"
	FrameworkNuxtjs         Framework = "nuxtjs"
	FrameworkRedwoodjs      Framework = "redwoodjs"
	FrameworkHugo           Framework = "hugo"
	FrameworkJekyll         Framework = "jekyll"
	FrameworkBrunch         Framework = "brunch"
	FrameworkMiddleman      Framework = "middleman"
	FrameworkZola           Framework = "zola"
	FrameworkHydrogen       Framework = "hydrogen"
	FrameworkVite           Framework = "vite"
	FrameworkVitepress      Framework = "vitepress"
	FrameworkVuepress       Framework = "vuepress"
	FrameworkParcel         Framework = "parcel"
	FrameworkSanity         Framework = "sanity"
	FrameworkStorybook      Framework = "storybook"
)

func (e Framework) ToPointer() *Framework {
	return &e
}
func (e *Framework) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blitzjs":
		fallthrough
	case "nextjs":
		fallthrough
	case "gatsby":
		fallthrough
	case "remix":
		fallthrough
	case "astro":
		fallthrough
	case "hexo":
		fallthrough
	case "eleventy":
		fallthrough
	case "docusaurus-2":
		fallthrough
	case "docusaurus":
		fallthrough
	case "preact":
		fallthrough
	case "solidstart-1":
		fallthrough
	case "solidstart":
		fallthrough
	case "dojo":
		fallthrough
	case "ember":
		fallthrough
	case "vue":
		fallthrough
	case "scully":
		fallthrough
	case "ionic-angular":
		fallthrough
	case "angular":
		fallthrough
	case "polymer":
		fallthrough
	case "svelte":
		fallthrough
	case "sveltekit":
		fallthrough
	case "sveltekit-1":
		fallthrough
	case "ionic-react":
		fallthrough
	case "create-react-app":
		fallthrough
	case "gridsome":
		fallthrough
	case "umijs":
		fallthrough
	case "sapper":
		fallthrough
	case "saber":
		fallthrough
	case "stencil":
		fallthrough
	case "nuxtjs":
		fallthrough
	case "redwoodjs":
		fallthrough
	case "hugo":
		fallthrough
	case "jekyll":
		fallthrough
	case "brunch":
		fallthrough
	case "middleman":
		fallthrough
	case "zola":
		fallthrough
	case "hydrogen":
		fallthrough
	case "vite":
		fallthrough
	case "vitepress":
		fallthrough
	case "vuepress":
		fallthrough
	case "parcel":
		fallthrough
	case "sanity":
		fallthrough
	case "storybook":
		*e = Framework(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Framework: %v", v)
	}
}

// NodeVersion - Override the Node.js version that should be used for this deployment
type NodeVersion string

const (
	NodeVersionTwentyX   NodeVersion = "20.x"
	NodeVersionEighteenX NodeVersion = "18.x"
	NodeVersionSixteenX  NodeVersion = "16.x"
)

func (e NodeVersion) ToPointer() *NodeVersion {
	return &e
}
func (e *NodeVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "20.x":
		fallthrough
	case "18.x":
		fallthrough
	case "16.x":
		*e = NodeVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for NodeVersion: %v", v)
	}
}

// ProjectSettings - Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments
type ProjectSettings struct {
	// The build command for this project. When `null` is used this value will be automatically detected
	BuildCommand                *string `json:"buildCommand,omitempty"`
	CommandForIgnoringBuildStep *string `json:"commandForIgnoringBuildStep,omitempty"`
	// The dev command for this project. When `null` is used this value will be automatically detected
	DevCommand *string `json:"devCommand,omitempty"`
	// The framework that is being used for this project. When `null` is used no framework is selected
	Framework *Framework `json:"framework,omitempty"`
	// The install command for this project. When `null` is used this value will be automatically detected
	InstallCommand *string `json:"installCommand,omitempty"`
	// Override the Node.js version that should be used for this deployment
	NodeVersion *NodeVersion `json:"nodeVersion,omitempty"`
	// The output directory of the project. When `null` is used this value will be automatically detected
	OutputDirectory *string `json:"outputDirectory,omitempty"`
	// The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root
	RootDirectory *string `json:"rootDirectory,omitempty"`
	// The region to deploy Serverless Functions in this project
	ServerlessFunctionRegion *string `json:"serverlessFunctionRegion,omitempty"`
	// Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
	//
	// Deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
	SkipGitConnectDuringLink *bool `json:"skipGitConnectDuringLink,omitempty"`
	// Indicates if there are source files outside of the root directory, typically used for monorepos
	SourceFilesOutsideRootDirectory *bool `json:"sourceFilesOutsideRootDirectory,omitempty"`
}

func (o *ProjectSettings) GetBuildCommand() *string {
	if o == nil {
		return nil
	}
	return o.BuildCommand
}

func (o *ProjectSettings) GetCommandForIgnoringBuildStep() *string {
	if o == nil {
		return nil
	}
	return o.CommandForIgnoringBuildStep
}

func (o *ProjectSettings) GetDevCommand() *string {
	if o == nil {
		return nil
	}
	return o.DevCommand
}

func (o *ProjectSettings) GetFramework() *Framework {
	if o == nil {
		return nil
	}
	return o.Framework
}

func (o *ProjectSettings) GetInstallCommand() *string {
	if o == nil {
		return nil
	}
	return o.InstallCommand
}

func (o *ProjectSettings) GetNodeVersion() *NodeVersion {
	if o == nil {
		return nil
	}
	return o.NodeVersion
}

func (o *ProjectSettings) GetOutputDirectory() *string {
	if o == nil {
		return nil
	}
	return o.OutputDirectory
}

func (o *ProjectSettings) GetRootDirectory() *string {
	if o == nil {
		return nil
	}
	return o.RootDirectory
}

func (o *ProjectSettings) GetServerlessFunctionRegion() *string {
	if o == nil {
		return nil
	}
	return o.ServerlessFunctionRegion
}

func (o *ProjectSettings) GetSkipGitConnectDuringLink() *bool {
	if o == nil {
		return nil
	}
	return o.SkipGitConnectDuringLink
}

func (o *ProjectSettings) GetSourceFilesOutsideRootDirectory() *bool {
	if o == nil {
		return nil
	}
	return o.SourceFilesOutsideRootDirectory
}

// Target - Either not defined, `staging`, or `production`. If `staging`, a staging alias in the format `<project>-<team>.vercel.app` will be assigned. If `production`, any aliases defined in `alias` will be assigned. If omitted, the target will be `preview`
type Target string

const (
	TargetStaging    Target = "staging"
	TargetProduction Target = "production"
)

func (e Target) ToPointer() *Target {
	return &e
}
func (e *Target) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "staging":
		fallthrough
	case "production":
		*e = Target(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Target: %v", v)
	}
}

type CreateDeploymentRequestBody struct {
	// Deploy to a custom environment, which will override the default environment
	CustomEnvironmentSlugOrID *string `json:"customEnvironmentSlugOrId,omitempty"`
	// An deployment id for an existing deployment to redeploy
	DeploymentID *string `json:"deploymentId,omitempty"`
	// A list of objects with the files to be deployed
	Files []Files `json:"files,omitempty"`
	// Populates initial git metadata for different git providers.
	GitMetadata *GitMetadata `json:"gitMetadata,omitempty"`
	// Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.
	GitSource *GitSource `json:"gitSource,omitempty"`
	// An object containing the deployment's metadata. Multiple key-value pairs can be attached to a deployment
	Meta map[string]string `json:"meta,omitempty"`
	// The monorepo manager that is being used for this deployment. When `null` is used no monorepo manager is selected
	MonorepoManager *string `json:"monorepoManager,omitempty"`
	// A string with the project name used in the deployment URL
	Name string `json:"name"`
	// The target project identifier in which the deployment will be created. When defined, this parameter overrides name
	Project *string `json:"project,omitempty"`
	// Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments
	ProjectSettings *ProjectSettings `json:"projectSettings,omitempty"`
	// Either not defined, `staging`, or `production`. If `staging`, a staging alias in the format `<project>-<team>.vercel.app` will be assigned. If `production`, any aliases defined in `alias` will be assigned. If omitted, the target will be `preview`
	Target *Target `json:"target,omitempty"`
	// When `true` and `deploymentId` is passed in, the sha from the previous deployment's `gitSource` is removed forcing the latest commit to be used.
	WithLatestCommit *bool `json:"withLatestCommit,omitempty"`
}

func (o *CreateDeploymentRequestBody) GetCustomEnvironmentSlugOrID() *string {
	if o == nil {
		return nil
	}
	return o.CustomEnvironmentSlugOrID
}

func (o *CreateDeploymentRequestBody) GetDeploymentID() *string {
	if o == nil {
		return nil
	}
	return o.DeploymentID
}

func (o *CreateDeploymentRequestBody) GetFiles() []Files {
	if o == nil {
		return nil
	}
	return o.Files
}

func (o *CreateDeploymentRequestBody) GetGitMetadata() *GitMetadata {
	if o == nil {
		return nil
	}
	return o.GitMetadata
}

func (o *CreateDeploymentRequestBody) GetGitSource() *GitSource {
	if o == nil {
		return nil
	}
	return o.GitSource
}

func (o *CreateDeploymentRequestBody) GetMeta() map[string]string {
	if o == nil {
		return nil
	}
	return o.Meta
}

func (o *CreateDeploymentRequestBody) GetMonorepoManager() *string {
	if o == nil {
		return nil
	}
	return o.MonorepoManager
}

func (o *CreateDeploymentRequestBody) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateDeploymentRequestBody) GetProject() *string {
	if o == nil {
		return nil
	}
	return o.Project
}

func (o *CreateDeploymentRequestBody) GetProjectSettings() *ProjectSettings {
	if o == nil {
		return nil
	}
	return o.ProjectSettings
}

func (o *CreateDeploymentRequestBody) GetTarget() *Target {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *CreateDeploymentRequestBody) GetWithLatestCommit() *bool {
	if o == nil {
		return nil
	}
	return o.WithLatestCommit
}

type CreateDeploymentRequest struct {
	// Forces a new deployment even if there is a previous similar deployment
	ForceNew *ForceNew `queryParam:"style=form,explode=true,name=forceNew"`
	// Allows to skip framework detection so the API would not fail to ask for confirmation
	SkipAutoDetectionConfirmation *SkipAutoDetectionConfirmation `queryParam:"style=form,explode=true,name=skipAutoDetectionConfirmation"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug        *string                      `queryParam:"style=form,explode=true,name=slug"`
	RequestBody *CreateDeploymentRequestBody `request:"mediaType=application/json"`
}

func (o *CreateDeploymentRequest) GetForceNew() *ForceNew {
	if o == nil {
		return nil
	}
	return o.ForceNew
}

func (o *CreateDeploymentRequest) GetSkipAutoDetectionConfirmation() *SkipAutoDetectionConfirmation {
	if o == nil {
		return nil
	}
	return o.SkipAutoDetectionConfirmation
}

func (o *CreateDeploymentRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *CreateDeploymentRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *CreateDeploymentRequest) GetRequestBody() *CreateDeploymentRequestBody {
	if o == nil {
		return nil
	}
	return o.RequestBody
}

type Build struct {
	// The keys of the environment variables that were assigned during the build phase.
	Env []string `json:"env"`
}

func (o *Build) GetEnv() []string {
	if o == nil {
		return []string{}
	}
	return o.Env
}

type CreateDeploymentBuilds struct {
}

// CreateDeploymentCrons - The cron jobs associated with this deployment. Note that preview deployments are also allowed to have this property, but only production deployments create cron jobs. If a preview deployment is promoted to production, only then they'll take effect.
type CreateDeploymentCrons struct {
	Schedule string `json:"schedule"`
	Path     string `json:"path"`
}

func (o *CreateDeploymentCrons) GetSchedule() string {
	if o == nil {
		return ""
	}
	return o.Schedule
}

func (o *CreateDeploymentCrons) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

// Functions - An object used to configure your Serverless Functions
type Functions struct {
	Memory       *float64 `json:"memory,omitempty"`
	MaxDuration  *float64 `json:"maxDuration,omitempty"`
	Runtime      *string  `json:"runtime,omitempty"`
	IncludeFiles *string  `json:"includeFiles,omitempty"`
	ExcludeFiles *string  `json:"excludeFiles,omitempty"`
}

func (o *Functions) GetMemory() *float64 {
	if o == nil {
		return nil
	}
	return o.Memory
}

func (o *Functions) GetMaxDuration() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxDuration
}

func (o *Functions) GetRuntime() *string {
	if o == nil {
		return nil
	}
	return o.Runtime
}

func (o *Functions) GetIncludeFiles() *string {
	if o == nil {
		return nil
	}
	return o.IncludeFiles
}

func (o *Functions) GetExcludeFiles() *string {
	if o == nil {
		return nil
	}
	return o.ExcludeFiles
}

// Plan - The pricing plan the deployment was made under
type Plan string

const (
	PlanPro        Plan = "pro"
	PlanEnterprise Plan = "enterprise"
	PlanHobby      Plan = "hobby"
)

func (e Plan) ToPointer() *Plan {
	return &e
}
func (e *Plan) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pro":
		fallthrough
	case "enterprise":
		fallthrough
	case "hobby":
		*e = Plan(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Plan: %v", v)
	}
}

// Routes3 - A list of routes objects used to rewrite paths to point towards other internal or external paths
type Routes3 struct {
	Src        string  `json:"src"`
	Continue   bool    `json:"continue"`
	Middleware float64 `json:"middleware"`
}

func (o *Routes3) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *Routes3) GetContinue() bool {
	if o == nil {
		return false
	}
	return o.Continue
}

func (o *Routes3) GetMiddleware() float64 {
	if o == nil {
		return 0.0
	}
	return o.Middleware
}

type RoutesHandle string

const (
	RoutesHandleError      RoutesHandle = "error"
	RoutesHandleFilesystem RoutesHandle = "filesystem"
	RoutesHandleHit        RoutesHandle = "hit"
	RoutesHandleMiss       RoutesHandle = "miss"
	RoutesHandleResource   RoutesHandle = "resource"
	RoutesHandleRewrite    RoutesHandle = "rewrite"
)

func (e RoutesHandle) ToPointer() *RoutesHandle {
	return &e
}
func (e *RoutesHandle) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "error":
		fallthrough
	case "filesystem":
		fallthrough
	case "hit":
		fallthrough
	case "miss":
		fallthrough
	case "resource":
		fallthrough
	case "rewrite":
		*e = RoutesHandle(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RoutesHandle: %v", v)
	}
}

// Routes2 - A list of routes objects used to rewrite paths to point towards other internal or external paths
type Routes2 struct {
	Handle RoutesHandle `json:"handle"`
	Src    *string      `json:"src,omitempty"`
	Dest   *string      `json:"dest,omitempty"`
	Status *float64     `json:"status,omitempty"`
}

func (o *Routes2) GetHandle() RoutesHandle {
	if o == nil {
		return RoutesHandle("")
	}
	return o.Handle
}

func (o *Routes2) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *Routes2) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

func (o *Routes2) GetStatus() *float64 {
	if o == nil {
		return nil
	}
	return o.Status
}

type CreateDeploymentHasType string

const (
	CreateDeploymentHasTypeHeader CreateDeploymentHasType = "header"
	CreateDeploymentHasTypeCookie CreateDeploymentHasType = "cookie"
	CreateDeploymentHasTypeQuery  CreateDeploymentHasType = "query"
)

func (e CreateDeploymentHasType) ToPointer() *CreateDeploymentHasType {
	return &e
}
func (e *CreateDeploymentHasType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "query":
		*e = CreateDeploymentHasType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentHasType: %v", v)
	}
}

type Has2 struct {
	Type  CreateDeploymentHasType `json:"type"`
	Key   string                  `json:"key"`
	Value *string                 `json:"value,omitempty"`
}

func (o *Has2) GetType() CreateDeploymentHasType {
	if o == nil {
		return CreateDeploymentHasType("")
	}
	return o.Type
}

func (o *Has2) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *Has2) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

type HasType string

const (
	HasTypeHost HasType = "host"
)

func (e HasType) ToPointer() *HasType {
	return &e
}
func (e *HasType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = HasType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for HasType: %v", v)
	}
}

type Has1 struct {
	Type  HasType `json:"type"`
	Value string  `json:"value"`
}

func (o *Has1) GetType() HasType {
	if o == nil {
		return HasType("")
	}
	return o.Type
}

func (o *Has1) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type RoutesHasType string

const (
	RoutesHasTypeHas1 RoutesHasType = "has_1"
	RoutesHasTypeHas2 RoutesHasType = "has_2"
)

type RoutesHas struct {
	Has1 *Has1
	Has2 *Has2

	Type RoutesHasType
}

func CreateRoutesHasHas1(has1 Has1) RoutesHas {
	typ := RoutesHasTypeHas1

	return RoutesHas{
		Has1: &has1,
		Type: typ,
	}
}

func CreateRoutesHasHas2(has2 Has2) RoutesHas {
	typ := RoutesHasTypeHas2

	return RoutesHas{
		Has2: &has2,
		Type: typ,
	}
}

func (u *RoutesHas) UnmarshalJSON(data []byte) error {

	var has1 Has1 = Has1{}
	if err := utils.UnmarshalJSON(data, &has1, "", true, true); err == nil {
		u.Has1 = &has1
		u.Type = RoutesHasTypeHas1
		return nil
	}

	var has2 Has2 = Has2{}
	if err := utils.UnmarshalJSON(data, &has2, "", true, true); err == nil {
		u.Has2 = &has2
		u.Type = RoutesHasTypeHas2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RoutesHas", string(data))
}

func (u RoutesHas) MarshalJSON() ([]byte, error) {
	if u.Has1 != nil {
		return utils.MarshalJSON(u.Has1, "", true)
	}

	if u.Has2 != nil {
		return utils.MarshalJSON(u.Has2, "", true)
	}

	return nil, errors.New("could not marshal union type RoutesHas: all fields are null")
}

type CreateDeploymentMissingType string

const (
	CreateDeploymentMissingTypeHeader CreateDeploymentMissingType = "header"
	CreateDeploymentMissingTypeCookie CreateDeploymentMissingType = "cookie"
	CreateDeploymentMissingTypeQuery  CreateDeploymentMissingType = "query"
)

func (e CreateDeploymentMissingType) ToPointer() *CreateDeploymentMissingType {
	return &e
}
func (e *CreateDeploymentMissingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "query":
		*e = CreateDeploymentMissingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentMissingType: %v", v)
	}
}

type Missing2 struct {
	Type  CreateDeploymentMissingType `json:"type"`
	Key   string                      `json:"key"`
	Value *string                     `json:"value,omitempty"`
}

func (o *Missing2) GetType() CreateDeploymentMissingType {
	if o == nil {
		return CreateDeploymentMissingType("")
	}
	return o.Type
}

func (o *Missing2) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *Missing2) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

type MissingType string

const (
	MissingTypeHost MissingType = "host"
)

func (e MissingType) ToPointer() *MissingType {
	return &e
}
func (e *MissingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = MissingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MissingType: %v", v)
	}
}

type Missing1 struct {
	Type  MissingType `json:"type"`
	Value string      `json:"value"`
}

func (o *Missing1) GetType() MissingType {
	if o == nil {
		return MissingType("")
	}
	return o.Type
}

func (o *Missing1) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type RoutesMissingType string

const (
	RoutesMissingTypeMissing1 RoutesMissingType = "missing_1"
	RoutesMissingTypeMissing2 RoutesMissingType = "missing_2"
)

type RoutesMissing struct {
	Missing1 *Missing1
	Missing2 *Missing2

	Type RoutesMissingType
}

func CreateRoutesMissingMissing1(missing1 Missing1) RoutesMissing {
	typ := RoutesMissingTypeMissing1

	return RoutesMissing{
		Missing1: &missing1,
		Type:     typ,
	}
}

func CreateRoutesMissingMissing2(missing2 Missing2) RoutesMissing {
	typ := RoutesMissingTypeMissing2

	return RoutesMissing{
		Missing2: &missing2,
		Type:     typ,
	}
}

func (u *RoutesMissing) UnmarshalJSON(data []byte) error {

	var missing1 Missing1 = Missing1{}
	if err := utils.UnmarshalJSON(data, &missing1, "", true, true); err == nil {
		u.Missing1 = &missing1
		u.Type = RoutesMissingTypeMissing1
		return nil
	}

	var missing2 Missing2 = Missing2{}
	if err := utils.UnmarshalJSON(data, &missing2, "", true, true); err == nil {
		u.Missing2 = &missing2
		u.Type = RoutesMissingTypeMissing2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RoutesMissing", string(data))
}

func (u RoutesMissing) MarshalJSON() ([]byte, error) {
	if u.Missing1 != nil {
		return utils.MarshalJSON(u.Missing1, "", true)
	}

	if u.Missing2 != nil {
		return utils.MarshalJSON(u.Missing2, "", true)
	}

	return nil, errors.New("could not marshal union type RoutesMissing: all fields are null")
}

type Locale struct {
	Redirect map[string]string `json:"redirect,omitempty"`
	Cookie   *string           `json:"cookie,omitempty"`
}

func (o *Locale) GetRedirect() map[string]string {
	if o == nil {
		return nil
	}
	return o.Redirect
}

func (o *Locale) GetCookie() *string {
	if o == nil {
		return nil
	}
	return o.Cookie
}

// Routes1 - A list of routes objects used to rewrite paths to point towards other internal or external paths
type Routes1 struct {
	Src           string            `json:"src"`
	Dest          *string           `json:"dest,omitempty"`
	Headers       map[string]string `json:"headers,omitempty"`
	Methods       []string          `json:"methods,omitempty"`
	Continue      *bool             `json:"continue,omitempty"`
	Override      *bool             `json:"override,omitempty"`
	CaseSensitive *bool             `json:"caseSensitive,omitempty"`
	Check         *bool             `json:"check,omitempty"`
	Important     *bool             `json:"important,omitempty"`
	Status        *float64          `json:"status,omitempty"`
	Has           []RoutesHas       `json:"has,omitempty"`
	Missing       []RoutesMissing   `json:"missing,omitempty"`
	Locale        *Locale           `json:"locale,omitempty"`
	// A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
	MiddlewarePath *string `json:"middlewarePath,omitempty"`
	// The original middleware matchers.
	MiddlewareRawSrc []string `json:"middlewareRawSrc,omitempty"`
	// A middleware index in the `middleware` key under the build result
	Middleware *float64 `json:"middleware,omitempty"`
}

func (o *Routes1) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *Routes1) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

func (o *Routes1) GetHeaders() map[string]string {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *Routes1) GetMethods() []string {
	if o == nil {
		return nil
	}
	return o.Methods
}

func (o *Routes1) GetContinue() *bool {
	if o == nil {
		return nil
	}
	return o.Continue
}

func (o *Routes1) GetOverride() *bool {
	if o == nil {
		return nil
	}
	return o.Override
}

func (o *Routes1) GetCaseSensitive() *bool {
	if o == nil {
		return nil
	}
	return o.CaseSensitive
}

func (o *Routes1) GetCheck() *bool {
	if o == nil {
		return nil
	}
	return o.Check
}

func (o *Routes1) GetImportant() *bool {
	if o == nil {
		return nil
	}
	return o.Important
}

func (o *Routes1) GetStatus() *float64 {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *Routes1) GetHas() []RoutesHas {
	if o == nil {
		return nil
	}
	return o.Has
}

func (o *Routes1) GetMissing() []RoutesMissing {
	if o == nil {
		return nil
	}
	return o.Missing
}

func (o *Routes1) GetLocale() *Locale {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *Routes1) GetMiddlewarePath() *string {
	if o == nil {
		return nil
	}
	return o.MiddlewarePath
}

func (o *Routes1) GetMiddlewareRawSrc() []string {
	if o == nil {
		return nil
	}
	return o.MiddlewareRawSrc
}

func (o *Routes1) GetMiddleware() *float64 {
	if o == nil {
		return nil
	}
	return o.Middleware
}

type RoutesType string

const (
	RoutesTypeRoutes1 RoutesType = "routes_1"
	RoutesTypeRoutes2 RoutesType = "routes_2"
	RoutesTypeRoutes3 RoutesType = "routes_3"
)

type Routes struct {
	Routes1 *Routes1
	Routes2 *Routes2
	Routes3 *Routes3

	Type RoutesType
}

func CreateRoutesRoutes1(routes1 Routes1) Routes {
	typ := RoutesTypeRoutes1

	return Routes{
		Routes1: &routes1,
		Type:    typ,
	}
}

func CreateRoutesRoutes2(routes2 Routes2) Routes {
	typ := RoutesTypeRoutes2

	return Routes{
		Routes2: &routes2,
		Type:    typ,
	}
}

func CreateRoutesRoutes3(routes3 Routes3) Routes {
	typ := RoutesTypeRoutes3

	return Routes{
		Routes3: &routes3,
		Type:    typ,
	}
}

func (u *Routes) UnmarshalJSON(data []byte) error {

	var routes3 Routes3 = Routes3{}
	if err := utils.UnmarshalJSON(data, &routes3, "", true, true); err == nil {
		u.Routes3 = &routes3
		u.Type = RoutesTypeRoutes3
		return nil
	}

	var routes2 Routes2 = Routes2{}
	if err := utils.UnmarshalJSON(data, &routes2, "", true, true); err == nil {
		u.Routes2 = &routes2
		u.Type = RoutesTypeRoutes2
		return nil
	}

	var routes1 Routes1 = Routes1{}
	if err := utils.UnmarshalJSON(data, &routes1, "", true, true); err == nil {
		u.Routes1 = &routes1
		u.Type = RoutesTypeRoutes1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Routes", string(data))
}

func (u Routes) MarshalJSON() ([]byte, error) {
	if u.Routes1 != nil {
		return utils.MarshalJSON(u.Routes1, "", true)
	}

	if u.Routes2 != nil {
		return utils.MarshalJSON(u.Routes2, "", true)
	}

	if u.Routes3 != nil {
		return utils.MarshalJSON(u.Routes3, "", true)
	}

	return nil, errors.New("could not marshal union type Routes: all fields are null")
}

type CreateDeploymentGitRepoDeploymentsType string

const (
	CreateDeploymentGitRepoDeploymentsTypeBitbucket CreateDeploymentGitRepoDeploymentsType = "bitbucket"
)

func (e CreateDeploymentGitRepoDeploymentsType) ToPointer() *CreateDeploymentGitRepoDeploymentsType {
	return &e
}
func (e *CreateDeploymentGitRepoDeploymentsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitRepoDeploymentsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitRepoDeploymentsType: %v", v)
	}
}

type CreateDeploymentGitRepoOwnerType string

const (
	CreateDeploymentGitRepoOwnerTypeUser CreateDeploymentGitRepoOwnerType = "user"
	CreateDeploymentGitRepoOwnerTypeTeam CreateDeploymentGitRepoOwnerType = "team"
)

func (e CreateDeploymentGitRepoOwnerType) ToPointer() *CreateDeploymentGitRepoOwnerType {
	return &e
}
func (e *CreateDeploymentGitRepoOwnerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		fallthrough
	case "team":
		*e = CreateDeploymentGitRepoOwnerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitRepoOwnerType: %v", v)
	}
}

type GitRepo3 struct {
	Owner         string                                 `json:"owner"`
	RepoUUID      string                                 `json:"repoUuid"`
	Slug          string                                 `json:"slug"`
	Type          CreateDeploymentGitRepoDeploymentsType `json:"type"`
	WorkspaceUUID string                                 `json:"workspaceUuid"`
	Path          string                                 `json:"path"`
	DefaultBranch string                                 `json:"defaultBranch"`
	Name          string                                 `json:"name"`
	Private       bool                                   `json:"private"`
	OwnerType     CreateDeploymentGitRepoOwnerType       `json:"ownerType"`
}

func (o *GitRepo3) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *GitRepo3) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

func (o *GitRepo3) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *GitRepo3) GetType() CreateDeploymentGitRepoDeploymentsType {
	if o == nil {
		return CreateDeploymentGitRepoDeploymentsType("")
	}
	return o.Type
}

func (o *GitRepo3) GetWorkspaceUUID() string {
	if o == nil {
		return ""
	}
	return o.WorkspaceUUID
}

func (o *GitRepo3) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *GitRepo3) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *GitRepo3) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GitRepo3) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *GitRepo3) GetOwnerType() CreateDeploymentGitRepoOwnerType {
	if o == nil {
		return CreateDeploymentGitRepoOwnerType("")
	}
	return o.OwnerType
}

type CreateDeploymentGitRepoType string

const (
	CreateDeploymentGitRepoTypeGithub CreateDeploymentGitRepoType = "github"
)

func (e CreateDeploymentGitRepoType) ToPointer() *CreateDeploymentGitRepoType {
	return &e
}
func (e *CreateDeploymentGitRepoType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = CreateDeploymentGitRepoType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitRepoType: %v", v)
	}
}

type GitRepoOwnerType string

const (
	GitRepoOwnerTypeUser GitRepoOwnerType = "user"
	GitRepoOwnerTypeTeam GitRepoOwnerType = "team"
)

func (e GitRepoOwnerType) ToPointer() *GitRepoOwnerType {
	return &e
}
func (e *GitRepoOwnerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		fallthrough
	case "team":
		*e = GitRepoOwnerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GitRepoOwnerType: %v", v)
	}
}

type GitRepo2 struct {
	Org           string                      `json:"org"`
	Repo          string                      `json:"repo"`
	RepoID        float64                     `json:"repoId"`
	Type          CreateDeploymentGitRepoType `json:"type"`
	RepoOwnerID   string                      `json:"repoOwnerId"`
	Path          string                      `json:"path"`
	DefaultBranch string                      `json:"defaultBranch"`
	Name          string                      `json:"name"`
	Private       bool                        `json:"private"`
	OwnerType     GitRepoOwnerType            `json:"ownerType"`
}

func (o *GitRepo2) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *GitRepo2) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *GitRepo2) GetRepoID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RepoID
}

func (o *GitRepo2) GetType() CreateDeploymentGitRepoType {
	if o == nil {
		return CreateDeploymentGitRepoType("")
	}
	return o.Type
}

func (o *GitRepo2) GetRepoOwnerID() string {
	if o == nil {
		return ""
	}
	return o.RepoOwnerID
}

func (o *GitRepo2) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *GitRepo2) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *GitRepo2) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GitRepo2) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *GitRepo2) GetOwnerType() GitRepoOwnerType {
	if o == nil {
		return GitRepoOwnerType("")
	}
	return o.OwnerType
}

type GitRepoType string

const (
	GitRepoTypeGitlab GitRepoType = "gitlab"
)

func (e GitRepoType) ToPointer() *GitRepoType {
	return &e
}
func (e *GitRepoType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = GitRepoType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GitRepoType: %v", v)
	}
}

type CreateDeploymentGitRepoDeploymentsOwnerType string

const (
	CreateDeploymentGitRepoDeploymentsOwnerTypeUser CreateDeploymentGitRepoDeploymentsOwnerType = "user"
	CreateDeploymentGitRepoDeploymentsOwnerTypeTeam CreateDeploymentGitRepoDeploymentsOwnerType = "team"
)

func (e CreateDeploymentGitRepoDeploymentsOwnerType) ToPointer() *CreateDeploymentGitRepoDeploymentsOwnerType {
	return &e
}
func (e *CreateDeploymentGitRepoDeploymentsOwnerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		fallthrough
	case "team":
		*e = CreateDeploymentGitRepoDeploymentsOwnerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitRepoDeploymentsOwnerType: %v", v)
	}
}

type GitRepo1 struct {
	Namespace     string                                      `json:"namespace"`
	ProjectID     float64                                     `json:"projectId"`
	Type          GitRepoType                                 `json:"type"`
	URL           string                                      `json:"url"`
	Path          string                                      `json:"path"`
	DefaultBranch string                                      `json:"defaultBranch"`
	Name          string                                      `json:"name"`
	Private       bool                                        `json:"private"`
	OwnerType     CreateDeploymentGitRepoDeploymentsOwnerType `json:"ownerType"`
}

func (o *GitRepo1) GetNamespace() string {
	if o == nil {
		return ""
	}
	return o.Namespace
}

func (o *GitRepo1) GetProjectID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ProjectID
}

func (o *GitRepo1) GetType() GitRepoType {
	if o == nil {
		return GitRepoType("")
	}
	return o.Type
}

func (o *GitRepo1) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *GitRepo1) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *GitRepo1) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *GitRepo1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GitRepo1) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *GitRepo1) GetOwnerType() CreateDeploymentGitRepoDeploymentsOwnerType {
	if o == nil {
		return CreateDeploymentGitRepoDeploymentsOwnerType("")
	}
	return o.OwnerType
}

type GitRepoUnionType string

const (
	GitRepoUnionTypeGitRepo1 GitRepoUnionType = "gitRepo_1"
	GitRepoUnionTypeGitRepo2 GitRepoUnionType = "gitRepo_2"
	GitRepoUnionTypeGitRepo3 GitRepoUnionType = "gitRepo_3"
)

type GitRepo struct {
	GitRepo1 *GitRepo1
	GitRepo2 *GitRepo2
	GitRepo3 *GitRepo3

	Type GitRepoUnionType
}

func CreateGitRepoGitRepo1(gitRepo1 GitRepo1) GitRepo {
	typ := GitRepoUnionTypeGitRepo1

	return GitRepo{
		GitRepo1: &gitRepo1,
		Type:     typ,
	}
}

func CreateGitRepoGitRepo2(gitRepo2 GitRepo2) GitRepo {
	typ := GitRepoUnionTypeGitRepo2

	return GitRepo{
		GitRepo2: &gitRepo2,
		Type:     typ,
	}
}

func CreateGitRepoGitRepo3(gitRepo3 GitRepo3) GitRepo {
	typ := GitRepoUnionTypeGitRepo3

	return GitRepo{
		GitRepo3: &gitRepo3,
		Type:     typ,
	}
}

func (u *GitRepo) UnmarshalJSON(data []byte) error {

	var gitRepo1 GitRepo1 = GitRepo1{}
	if err := utils.UnmarshalJSON(data, &gitRepo1, "", true, true); err == nil {
		u.GitRepo1 = &gitRepo1
		u.Type = GitRepoUnionTypeGitRepo1
		return nil
	}

	var gitRepo2 GitRepo2 = GitRepo2{}
	if err := utils.UnmarshalJSON(data, &gitRepo2, "", true, true); err == nil {
		u.GitRepo2 = &gitRepo2
		u.Type = GitRepoUnionTypeGitRepo2
		return nil
	}

	var gitRepo3 GitRepo3 = GitRepo3{}
	if err := utils.UnmarshalJSON(data, &gitRepo3, "", true, true); err == nil {
		u.GitRepo3 = &gitRepo3
		u.Type = GitRepoUnionTypeGitRepo3
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GitRepo", string(data))
}

func (u GitRepo) MarshalJSON() ([]byte, error) {
	if u.GitRepo1 != nil {
		return utils.MarshalJSON(u.GitRepo1, "", true)
	}

	if u.GitRepo2 != nil {
		return utils.MarshalJSON(u.GitRepo2, "", true)
	}

	if u.GitRepo3 != nil {
		return utils.MarshalJSON(u.GitRepo3, "", true)
	}

	return nil, errors.New("could not marshal union type GitRepo: all fields are null")
}

type AliasAssignedAtType string

const (
	AliasAssignedAtTypeNumber  AliasAssignedAtType = "number"
	AliasAssignedAtTypeBoolean AliasAssignedAtType = "boolean"
)

type AliasAssignedAt struct {
	Number  *float64
	Boolean *bool

	Type AliasAssignedAtType
}

func CreateAliasAssignedAtNumber(number float64) AliasAssignedAt {
	typ := AliasAssignedAtTypeNumber

	return AliasAssignedAt{
		Number: &number,
		Type:   typ,
	}
}

func CreateAliasAssignedAtBoolean(boolean bool) AliasAssignedAt {
	typ := AliasAssignedAtTypeBoolean

	return AliasAssignedAt{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *AliasAssignedAt) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = AliasAssignedAtTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = &boolean
		u.Type = AliasAssignedAtTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AliasAssignedAt", string(data))
}

func (u AliasAssignedAt) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type AliasAssignedAt: all fields are null")
}

type CreateDeploymentDeploymentsReadyState string

const (
	CreateDeploymentDeploymentsReadyStateError        CreateDeploymentDeploymentsReadyState = "ERROR"
	CreateDeploymentDeploymentsReadyStateBuilding     CreateDeploymentDeploymentsReadyState = "BUILDING"
	CreateDeploymentDeploymentsReadyStateInitializing CreateDeploymentDeploymentsReadyState = "INITIALIZING"
	CreateDeploymentDeploymentsReadyStateReady        CreateDeploymentDeploymentsReadyState = "READY"
)

func (e CreateDeploymentDeploymentsReadyState) ToPointer() *CreateDeploymentDeploymentsReadyState {
	return &e
}
func (e *CreateDeploymentDeploymentsReadyState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ERROR":
		fallthrough
	case "BUILDING":
		fallthrough
	case "INITIALIZING":
		fallthrough
	case "READY":
		*e = CreateDeploymentDeploymentsReadyState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentDeploymentsReadyState: %v", v)
	}
}

type CreateDeploymentOutput struct {
	Path         string `json:"path"`
	FunctionName string `json:"functionName"`
}

func (o *CreateDeploymentOutput) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *CreateDeploymentOutput) GetFunctionName() string {
	if o == nil {
		return ""
	}
	return o.FunctionName
}

type Lambdas struct {
	ID           string                                 `json:"id"`
	CreatedAt    *float64                               `json:"createdAt,omitempty"`
	Entrypoint   *string                                `json:"entrypoint,omitempty"`
	ReadyState   *CreateDeploymentDeploymentsReadyState `json:"readyState,omitempty"`
	ReadyStateAt *float64                               `json:"readyStateAt,omitempty"`
	Output       []CreateDeploymentOutput               `json:"output"`
}

func (o *Lambdas) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Lambdas) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Lambdas) GetEntrypoint() *string {
	if o == nil {
		return nil
	}
	return o.Entrypoint
}

func (o *Lambdas) GetReadyState() *CreateDeploymentDeploymentsReadyState {
	if o == nil {
		return nil
	}
	return o.ReadyState
}

func (o *Lambdas) GetReadyStateAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ReadyStateAt
}

func (o *Lambdas) GetOutput() []CreateDeploymentOutput {
	if o == nil {
		return []CreateDeploymentOutput{}
	}
	return o.Output
}

// ProjectObj - The public project information associated with the deployment.
type ProjectObj struct {
	ID        string  `json:"id"`
	Name      string  `json:"name"`
	Framework *string `json:"framework,omitempty"`
}

func (o *ProjectObj) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ProjectObj) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ProjectObj) GetFramework() *string {
	if o == nil {
		return nil
	}
	return o.Framework
}

// CreateDeploymentReadyState - The state of the deployment depending on the process of deploying, or if it is ready or in an error state
type CreateDeploymentReadyState string

const (
	CreateDeploymentReadyStateCanceled     CreateDeploymentReadyState = "CANCELED"
	CreateDeploymentReadyStateError        CreateDeploymentReadyState = "ERROR"
	CreateDeploymentReadyStateQueued       CreateDeploymentReadyState = "QUEUED"
	CreateDeploymentReadyStateBuilding     CreateDeploymentReadyState = "BUILDING"
	CreateDeploymentReadyStateInitializing CreateDeploymentReadyState = "INITIALIZING"
	CreateDeploymentReadyStateReady        CreateDeploymentReadyState = "READY"
)

func (e CreateDeploymentReadyState) ToPointer() *CreateDeploymentReadyState {
	return &e
}
func (e *CreateDeploymentReadyState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CANCELED":
		fallthrough
	case "ERROR":
		fallthrough
	case "QUEUED":
		fallthrough
	case "BUILDING":
		fallthrough
	case "INITIALIZING":
		fallthrough
	case "READY":
		*e = CreateDeploymentReadyState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentReadyState: %v", v)
	}
}

// ReadySubstate - The substate of the deployment when the state is "READY"
type ReadySubstate string

const (
	ReadySubstateStaged   ReadySubstate = "STAGED"
	ReadySubstatePromoted ReadySubstate = "PROMOTED"
)

func (e ReadySubstate) ToPointer() *ReadySubstate {
	return &e
}
func (e *ReadySubstate) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STAGED":
		fallthrough
	case "PROMOTED":
		*e = ReadySubstate(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReadySubstate: %v", v)
	}
}

// CreateDeploymentSource - Where was the deployment created from
type CreateDeploymentSource string

const (
	CreateDeploymentSourceCli                 CreateDeploymentSource = "cli"
	CreateDeploymentSourceGit                 CreateDeploymentSource = "git"
	CreateDeploymentSourceImport              CreateDeploymentSource = "import"
	CreateDeploymentSourceImportRepo          CreateDeploymentSource = "import/repo"
	CreateDeploymentSourceCloneRepo           CreateDeploymentSource = "clone/repo"
	CreateDeploymentSourceAPITriggerGitDeploy CreateDeploymentSource = "api-trigger-git-deploy"
)

func (e CreateDeploymentSource) ToPointer() *CreateDeploymentSource {
	return &e
}
func (e *CreateDeploymentSource) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cli":
		fallthrough
	case "git":
		fallthrough
	case "import":
		fallthrough
	case "import/repo":
		fallthrough
	case "clone/repo":
		fallthrough
	case "api-trigger-git-deploy":
		*e = CreateDeploymentSource(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentSource: %v", v)
	}
}

// CreateDeploymentTarget - If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
type CreateDeploymentTarget string

const (
	CreateDeploymentTargetStaging    CreateDeploymentTarget = "staging"
	CreateDeploymentTargetProduction CreateDeploymentTarget = "production"
)

func (e CreateDeploymentTarget) ToPointer() *CreateDeploymentTarget {
	return &e
}
func (e *CreateDeploymentTarget) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "staging":
		fallthrough
	case "production":
		*e = CreateDeploymentTarget(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentTarget: %v", v)
	}
}

// Team - The team that owns the deployment if any
type Team struct {
	// The ID of the team owner
	ID string `json:"id"`
	// The name of the team owner
	Name string `json:"name"`
	// The slug of the team owner
	Slug string `json:"slug"`
	// The avatar of the team owner
	Avatar *string `json:"avatar,omitempty"`
}

func (o *Team) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Team) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Team) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *Team) GetAvatar() *string {
	if o == nil {
		return nil
	}
	return o.Avatar
}

type CreateDeploymentType string

const (
	CreateDeploymentTypeLambdas CreateDeploymentType = "LAMBDAS"
)

func (e CreateDeploymentType) ToPointer() *CreateDeploymentType {
	return &e
}
func (e *CreateDeploymentType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "LAMBDAS":
		*e = CreateDeploymentType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentType: %v", v)
	}
}

// AliasError - An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
type AliasError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

func (o *AliasError) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *AliasError) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

type AliasWarning struct {
	Code    string  `json:"code"`
	Message string  `json:"message"`
	Link    *string `json:"link,omitempty"`
	Action  *string `json:"action,omitempty"`
}

func (o *AliasWarning) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *AliasWarning) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

func (o *AliasWarning) GetLink() *string {
	if o == nil {
		return nil
	}
	return o.Link
}

func (o *AliasWarning) GetAction() *string {
	if o == nil {
		return nil
	}
	return o.Action
}

type ChecksState string

const (
	ChecksStateRegistered ChecksState = "registered"
	ChecksStateRunning    ChecksState = "running"
	ChecksStateCompleted  ChecksState = "completed"
)

func (e ChecksState) ToPointer() *ChecksState {
	return &e
}
func (e *ChecksState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "registered":
		fallthrough
	case "running":
		fallthrough
	case "completed":
		*e = ChecksState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ChecksState: %v", v)
	}
}

type ChecksConclusion string

const (
	ChecksConclusionSucceeded ChecksConclusion = "succeeded"
	ChecksConclusionFailed    ChecksConclusion = "failed"
	ChecksConclusionSkipped   ChecksConclusion = "skipped"
	ChecksConclusionCanceled  ChecksConclusion = "canceled"
)

func (e ChecksConclusion) ToPointer() *ChecksConclusion {
	return &e
}
func (e *ChecksConclusion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "succeeded":
		fallthrough
	case "failed":
		fallthrough
	case "skipped":
		fallthrough
	case "canceled":
		*e = ChecksConclusion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ChecksConclusion: %v", v)
	}
}

// Creator - Information about the deployment creator
type Creator struct {
	// The ID of the user that created the deployment
	UID string `json:"uid"`
	// The username of the user that created the deployment
	Username *string `json:"username,omitempty"`
	// The avatar of the user that created the deployment
	Avatar *string `json:"avatar,omitempty"`
}

func (o *Creator) GetUID() string {
	if o == nil {
		return ""
	}
	return o.UID
}

func (o *Creator) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

func (o *Creator) GetAvatar() *string {
	if o == nil {
		return nil
	}
	return o.Avatar
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9TypeBitbucket CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type = "bitbucket"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type: %v", v)
	}
}

type CreateDeploymentGitSource9 struct {
	Type          CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type `json:"type"`
	Ref           string                                                                          `json:"ref"`
	Sha           string                                                                          `json:"sha"`
	Owner         *string                                                                         `json:"owner,omitempty"`
	Slug          *string                                                                         `json:"slug,omitempty"`
	WorkspaceUUID string                                                                          `json:"workspaceUuid"`
	RepoUUID      string                                                                          `json:"repoUuid"`
}

func (o *CreateDeploymentGitSource9) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSource9) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSource9) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSource9) GetOwner() *string {
	if o == nil {
		return nil
	}
	return o.Owner
}

func (o *CreateDeploymentGitSource9) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *CreateDeploymentGitSource9) GetWorkspaceUUID() string {
	if o == nil {
		return ""
	}
	return o.WorkspaceUUID
}

func (o *CreateDeploymentGitSource9) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8TypeGitlab CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type = "gitlab"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type: %v", v)
	}
}

type CreateDeploymentGitSource8 struct {
	Type      CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type `json:"type"`
	Ref       string                                                                          `json:"ref"`
	Sha       string                                                                          `json:"sha"`
	ProjectID float64                                                                         `json:"projectId"`
}

func (o *CreateDeploymentGitSource8) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSource8) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSource8) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSource8) GetProjectID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ProjectID
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7TypeGithub CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type = "github"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type: %v", v)
	}
}

type CreateDeploymentGitSource7 struct {
	Type   CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type `json:"type"`
	Ref    string                                                                          `json:"ref"`
	Sha    string                                                                          `json:"sha"`
	RepoID float64                                                                         `json:"repoId"`
	Org    *string                                                                         `json:"org,omitempty"`
	Repo   *string                                                                         `json:"repo,omitempty"`
}

func (o *CreateDeploymentGitSource7) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSource7) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSource7) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSource7) GetRepoID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RepoID
}

func (o *CreateDeploymentGitSource7) GetOrg() *string {
	if o == nil {
		return nil
	}
	return o.Org
}

func (o *CreateDeploymentGitSource7) GetRepo() *string {
	if o == nil {
		return nil
	}
	return o.Repo
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6TypeCustom CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type = "custom"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "custom":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type: %v", v)
	}
}

type CreateDeploymentGitSource6 struct {
	Type   CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type `json:"type"`
	Ref    string                                                                          `json:"ref"`
	Sha    string                                                                          `json:"sha"`
	GitURL string                                                                          `json:"gitUrl"`
}

func (o *CreateDeploymentGitSource6) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSource6) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSource6) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSource6) GetGitURL() string {
	if o == nil {
		return ""
	}
	return o.GitURL
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5TypeBitbucket CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type = "bitbucket"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type: %v", v)
	}
}

type GitSource5 struct {
	Type  CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type `json:"type"`
	Owner string                                                                          `json:"owner"`
	Slug  string                                                                          `json:"slug"`
	Ref   *string                                                                         `json:"ref,omitempty"`
	Sha   *string                                                                         `json:"sha,omitempty"`
	PrID  *float64                                                                        `json:"prId,omitempty"`
}

func (o *GitSource5) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type("")
	}
	return o.Type
}

func (o *GitSource5) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *GitSource5) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *GitSource5) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *GitSource5) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSource5) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyTypeBitbucket CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType = "bitbucket"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType: %v", v)
	}
}

type GitSource4 struct {
	Type          CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType `json:"type"`
	WorkspaceUUID *string                                                                        `json:"workspaceUuid,omitempty"`
	RepoUUID      string                                                                         `json:"repoUuid"`
	Ref           *string                                                                        `json:"ref,omitempty"`
	Sha           *string                                                                        `json:"sha,omitempty"`
	PrID          *float64                                                                       `json:"prId,omitempty"`
}

func (o *GitSource4) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType("")
	}
	return o.Type
}

func (o *GitSource4) GetWorkspaceUUID() *string {
	if o == nil {
		return nil
	}
	return o.WorkspaceUUID
}

func (o *GitSource4) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

func (o *GitSource4) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *GitSource4) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSource4) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType string

const (
	CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONTypeGitlab CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType = "gitlab"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType: %v", v)
	}
}

type GitSourceProjectIDType string

const (
	GitSourceProjectIDTypeStr    GitSourceProjectIDType = "str"
	GitSourceProjectIDTypeNumber GitSourceProjectIDType = "number"
)

type GitSourceProjectID struct {
	Str    *string
	Number *float64

	Type GitSourceProjectIDType
}

func CreateGitSourceProjectIDStr(str string) GitSourceProjectID {
	typ := GitSourceProjectIDTypeStr

	return GitSourceProjectID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGitSourceProjectIDNumber(number float64) GitSourceProjectID {
	typ := GitSourceProjectIDTypeNumber

	return GitSourceProjectID{
		Number: &number,
		Type:   typ,
	}
}

func (u *GitSourceProjectID) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = GitSourceProjectIDTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = GitSourceProjectIDTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GitSourceProjectID", string(data))
}

func (u GitSourceProjectID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type GitSourceProjectID: all fields are null")
}

type GitSource3 struct {
	Type      CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType `json:"type"`
	ProjectID GitSourceProjectID                                                 `json:"projectId"`
	Ref       *string                                                            `json:"ref,omitempty"`
	Sha       *string                                                            `json:"sha,omitempty"`
	PrID      *float64                                                           `json:"prId,omitempty"`
}

func (o *GitSource3) GetType() CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType("")
	}
	return o.Type
}

func (o *GitSource3) GetProjectID() GitSourceProjectID {
	if o == nil {
		return GitSourceProjectID{}
	}
	return o.ProjectID
}

func (o *GitSource3) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *GitSource3) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSource3) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceDeploymentsResponse200Type string

const (
	CreateDeploymentGitSourceDeploymentsResponse200TypeGithub CreateDeploymentGitSourceDeploymentsResponse200Type = "github"
)

func (e CreateDeploymentGitSourceDeploymentsResponse200Type) ToPointer() *CreateDeploymentGitSourceDeploymentsResponse200Type {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponse200Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = CreateDeploymentGitSourceDeploymentsResponse200Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponse200Type: %v", v)
	}
}

type GitSource2 struct {
	Type CreateDeploymentGitSourceDeploymentsResponse200Type `json:"type"`
	Org  string                                              `json:"org"`
	Repo string                                              `json:"repo"`
	Ref  *string                                             `json:"ref,omitempty"`
	Sha  *string                                             `json:"sha,omitempty"`
	PrID *float64                                            `json:"prId,omitempty"`
}

func (o *GitSource2) GetType() CreateDeploymentGitSourceDeploymentsResponse200Type {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponse200Type("")
	}
	return o.Type
}

func (o *GitSource2) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *GitSource2) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *GitSource2) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *GitSource2) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSource2) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceDeploymentsResponseType string

const (
	CreateDeploymentGitSourceDeploymentsResponseTypeGithub CreateDeploymentGitSourceDeploymentsResponseType = "github"
)

func (e CreateDeploymentGitSourceDeploymentsResponseType) ToPointer() *CreateDeploymentGitSourceDeploymentsResponseType {
	return &e
}
func (e *CreateDeploymentGitSourceDeploymentsResponseType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = CreateDeploymentGitSourceDeploymentsResponseType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceDeploymentsResponseType: %v", v)
	}
}

type GitSourceRepoIDType string

const (
	GitSourceRepoIDTypeStr    GitSourceRepoIDType = "str"
	GitSourceRepoIDTypeNumber GitSourceRepoIDType = "number"
)

type GitSourceRepoID struct {
	Str    *string
	Number *float64

	Type GitSourceRepoIDType
}

func CreateGitSourceRepoIDStr(str string) GitSourceRepoID {
	typ := GitSourceRepoIDTypeStr

	return GitSourceRepoID{
		Str:  &str,
		Type: typ,
	}
}

func CreateGitSourceRepoIDNumber(number float64) GitSourceRepoID {
	typ := GitSourceRepoIDTypeNumber

	return GitSourceRepoID{
		Number: &number,
		Type:   typ,
	}
}

func (u *GitSourceRepoID) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = GitSourceRepoIDTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = GitSourceRepoIDTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GitSourceRepoID", string(data))
}

func (u GitSourceRepoID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type GitSourceRepoID: all fields are null")
}

type GitSource1 struct {
	Type   CreateDeploymentGitSourceDeploymentsResponseType `json:"type"`
	RepoID GitSourceRepoID                                  `json:"repoId"`
	Ref    *string                                          `json:"ref,omitempty"`
	Sha    *string                                          `json:"sha,omitempty"`
	PrID   *float64                                         `json:"prId,omitempty"`
}

func (o *GitSource1) GetType() CreateDeploymentGitSourceDeploymentsResponseType {
	if o == nil {
		return CreateDeploymentGitSourceDeploymentsResponseType("")
	}
	return o.Type
}

func (o *GitSource1) GetRepoID() GitSourceRepoID {
	if o == nil {
		return GitSourceRepoID{}
	}
	return o.RepoID
}

func (o *GitSource1) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *GitSource1) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSource1) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceUnionType string

const (
	CreateDeploymentGitSourceUnionTypeGitSource1                 CreateDeploymentGitSourceUnionType = "gitSource_1"
	CreateDeploymentGitSourceUnionTypeGitSource2                 CreateDeploymentGitSourceUnionType = "gitSource_2"
	CreateDeploymentGitSourceUnionTypeGitSource3                 CreateDeploymentGitSourceUnionType = "gitSource_3"
	CreateDeploymentGitSourceUnionTypeGitSource4                 CreateDeploymentGitSourceUnionType = "gitSource_4"
	CreateDeploymentGitSourceUnionTypeGitSource5                 CreateDeploymentGitSourceUnionType = "gitSource_5"
	CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource6 CreateDeploymentGitSourceUnionType = "createDeployment_gitSource_6"
	CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource7 CreateDeploymentGitSourceUnionType = "createDeployment_gitSource_7"
	CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource8 CreateDeploymentGitSourceUnionType = "createDeployment_gitSource_8"
	CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource9 CreateDeploymentGitSourceUnionType = "createDeployment_gitSource_9"
)

type CreateDeploymentGitSource struct {
	GitSource1                 *GitSource1
	GitSource2                 *GitSource2
	GitSource3                 *GitSource3
	GitSource4                 *GitSource4
	GitSource5                 *GitSource5
	CreateDeploymentGitSource6 *CreateDeploymentGitSource6
	CreateDeploymentGitSource7 *CreateDeploymentGitSource7
	CreateDeploymentGitSource8 *CreateDeploymentGitSource8
	CreateDeploymentGitSource9 *CreateDeploymentGitSource9

	Type CreateDeploymentGitSourceUnionType
}

func CreateCreateDeploymentGitSourceGitSource1(gitSource1 GitSource1) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeGitSource1

	return CreateDeploymentGitSource{
		GitSource1: &gitSource1,
		Type:       typ,
	}
}

func CreateCreateDeploymentGitSourceGitSource2(gitSource2 GitSource2) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeGitSource2

	return CreateDeploymentGitSource{
		GitSource2: &gitSource2,
		Type:       typ,
	}
}

func CreateCreateDeploymentGitSourceGitSource3(gitSource3 GitSource3) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeGitSource3

	return CreateDeploymentGitSource{
		GitSource3: &gitSource3,
		Type:       typ,
	}
}

func CreateCreateDeploymentGitSourceGitSource4(gitSource4 GitSource4) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeGitSource4

	return CreateDeploymentGitSource{
		GitSource4: &gitSource4,
		Type:       typ,
	}
}

func CreateCreateDeploymentGitSourceGitSource5(gitSource5 GitSource5) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeGitSource5

	return CreateDeploymentGitSource{
		GitSource5: &gitSource5,
		Type:       typ,
	}
}

func CreateCreateDeploymentGitSourceCreateDeploymentGitSource6(createDeploymentGitSource6 CreateDeploymentGitSource6) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource6

	return CreateDeploymentGitSource{
		CreateDeploymentGitSource6: &createDeploymentGitSource6,
		Type:                       typ,
	}
}

func CreateCreateDeploymentGitSourceCreateDeploymentGitSource7(createDeploymentGitSource7 CreateDeploymentGitSource7) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource7

	return CreateDeploymentGitSource{
		CreateDeploymentGitSource7: &createDeploymentGitSource7,
		Type:                       typ,
	}
}

func CreateCreateDeploymentGitSourceCreateDeploymentGitSource8(createDeploymentGitSource8 CreateDeploymentGitSource8) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource8

	return CreateDeploymentGitSource{
		CreateDeploymentGitSource8: &createDeploymentGitSource8,
		Type:                       typ,
	}
}

func CreateCreateDeploymentGitSourceCreateDeploymentGitSource9(createDeploymentGitSource9 CreateDeploymentGitSource9) CreateDeploymentGitSource {
	typ := CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource9

	return CreateDeploymentGitSource{
		CreateDeploymentGitSource9: &createDeploymentGitSource9,
		Type:                       typ,
	}
}

func (u *CreateDeploymentGitSource) UnmarshalJSON(data []byte) error {

	var createDeploymentGitSource6 CreateDeploymentGitSource6 = CreateDeploymentGitSource6{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSource6, "", true, true); err == nil {
		u.CreateDeploymentGitSource6 = &createDeploymentGitSource6
		u.Type = CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource6
		return nil
	}

	var createDeploymentGitSource8 CreateDeploymentGitSource8 = CreateDeploymentGitSource8{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSource8, "", true, true); err == nil {
		u.CreateDeploymentGitSource8 = &createDeploymentGitSource8
		u.Type = CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource8
		return nil
	}

	var gitSource1 GitSource1 = GitSource1{}
	if err := utils.UnmarshalJSON(data, &gitSource1, "", true, true); err == nil {
		u.GitSource1 = &gitSource1
		u.Type = CreateDeploymentGitSourceUnionTypeGitSource1
		return nil
	}

	var gitSource3 GitSource3 = GitSource3{}
	if err := utils.UnmarshalJSON(data, &gitSource3, "", true, true); err == nil {
		u.GitSource3 = &gitSource3
		u.Type = CreateDeploymentGitSourceUnionTypeGitSource3
		return nil
	}

	var gitSource2 GitSource2 = GitSource2{}
	if err := utils.UnmarshalJSON(data, &gitSource2, "", true, true); err == nil {
		u.GitSource2 = &gitSource2
		u.Type = CreateDeploymentGitSourceUnionTypeGitSource2
		return nil
	}

	var gitSource4 GitSource4 = GitSource4{}
	if err := utils.UnmarshalJSON(data, &gitSource4, "", true, true); err == nil {
		u.GitSource4 = &gitSource4
		u.Type = CreateDeploymentGitSourceUnionTypeGitSource4
		return nil
	}

	var gitSource5 GitSource5 = GitSource5{}
	if err := utils.UnmarshalJSON(data, &gitSource5, "", true, true); err == nil {
		u.GitSource5 = &gitSource5
		u.Type = CreateDeploymentGitSourceUnionTypeGitSource5
		return nil
	}

	var createDeploymentGitSource7 CreateDeploymentGitSource7 = CreateDeploymentGitSource7{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSource7, "", true, true); err == nil {
		u.CreateDeploymentGitSource7 = &createDeploymentGitSource7
		u.Type = CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource7
		return nil
	}

	var createDeploymentGitSource9 CreateDeploymentGitSource9 = CreateDeploymentGitSource9{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSource9, "", true, true); err == nil {
		u.CreateDeploymentGitSource9 = &createDeploymentGitSource9
		u.Type = CreateDeploymentGitSourceUnionTypeCreateDeploymentGitSource9
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentGitSource", string(data))
}

func (u CreateDeploymentGitSource) MarshalJSON() ([]byte, error) {
	if u.GitSource1 != nil {
		return utils.MarshalJSON(u.GitSource1, "", true)
	}

	if u.GitSource2 != nil {
		return utils.MarshalJSON(u.GitSource2, "", true)
	}

	if u.GitSource3 != nil {
		return utils.MarshalJSON(u.GitSource3, "", true)
	}

	if u.GitSource4 != nil {
		return utils.MarshalJSON(u.GitSource4, "", true)
	}

	if u.GitSource5 != nil {
		return utils.MarshalJSON(u.GitSource5, "", true)
	}

	if u.CreateDeploymentGitSource6 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSource6, "", true)
	}

	if u.CreateDeploymentGitSource7 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSource7, "", true)
	}

	if u.CreateDeploymentGitSource8 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSource8, "", true)
	}

	if u.CreateDeploymentGitSource9 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSource9, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentGitSource: all fields are null")
}

// CreateDeploymentResponseBody - The successfully created deployment
type CreateDeploymentResponseBody struct {
	Build  Build                    `json:"build"`
	Builds []CreateDeploymentBuilds `json:"builds,omitempty"`
	// The flag saying if Vercel Connect configuration is used for builds
	ConnectBuildsEnabled *bool `json:"connectBuildsEnabled,omitempty"`
	// The ID of Vercel Connect configuration used for this deployment
	ConnectConfigurationID *string `json:"connectConfigurationId,omitempty"`
	// The region where the deployment was first created
	CreatedIn string `json:"createdIn"`
	// The cron jobs associated with this deployment. Note that preview deployments are also allowed to have this property, but only production deployments create cron jobs. If a preview deployment is promoted to production, only then they'll take effect.
	Crons []CreateDeploymentCrons `json:"crons,omitempty"`
	// The keys of the environment variables that were assigned during runtime
	Env []string `json:"env"`
	// An object used to configure your Serverless Functions
	Functions map[string]Functions `json:"functions,omitempty"`
	// Vercel URL to inspect the deployment.
	InspectorURL *string `json:"inspectorUrl"`
	// Is the deployment currently queued waiting for a Concurrent Build Slot to be available
	IsInConcurrentBuildsQueue bool `json:"isInConcurrentBuildsQueue"`
	// An object containing the deployment's metadata
	Meta map[string]string `json:"meta"`
	// An monorepo manager that was used for the deployment
	MonorepoManager *string `json:"monorepoManager,omitempty"`
	// The name of the project associated with the deployment at the time that the deployment was created
	Name string `json:"name"`
	// The unique ID of the user or team the deployment belongs to
	OwnerID string `json:"ownerId"`
	// The connect configuration ID used to deploy passive lambdas into for secure compute enabled deployments.
	PassiveConnectConfigurationID *string `json:"passiveConnectConfigurationId,omitempty"`
	// The pricing plan the deployment was made under
	Plan Plan `json:"plan"`
	// The ID of the project the deployment is associated with
	ProjectID string `json:"projectId"`
	// A list of routes objects used to rewrite paths to point towards other internal or external paths
	Routes          []Routes         `json:"routes"`
	GitRepo         *GitRepo         `json:"gitRepo,omitempty"`
	AliasAssignedAt *AliasAssignedAt `json:"aliasAssignedAt,omitempty"`
	Lambdas         []Lambdas        `json:"lambdas,omitempty"`
	// The public project information associated with the deployment.
	ProjectObj *ProjectObj `json:"project,omitempty"`
	// A boolean representing if the deployment is public or not. By default this is `false`
	Public bool `json:"public"`
	// The state of the deployment depending on the process of deploying, or if it is ready or in an error state
	ReadyState CreateDeploymentReadyState `json:"readyState"`
	// The substate of the deployment when the state is "READY"
	ReadySubstate *ReadySubstate `json:"readySubstate,omitempty"`
	// The regions the deployment exists in
	Regions []string `json:"regions"`
	// Where was the deployment created from
	Source *CreateDeploymentSource `json:"source,omitempty"`
	// If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
	Target *CreateDeploymentTarget `json:"target,omitempty"`
	// The team that owns the deployment if any
	Team *Team                `json:"team,omitempty"`
	Type CreateDeploymentType `json:"type"`
	// A string with the unique URL of the deployment
	URL string `json:"url"`
	// An array of domains that were provided by the user when creating the Deployment.
	UserAliases []string `json:"userAliases,omitempty"`
	// The platform version that was used to create the deployment.
	Version float64 `json:"version"`
	// Whether or not preview comments are enabled for the deployment
	PreviewCommentsEnabled *bool `json:"previewCommentsEnabled,omitempty"`
	// A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
	Alias []string `json:"alias"`
	// A boolean that will be true when the aliases from the alias property were assigned successfully
	AliasAssigned bool `json:"aliasAssigned"`
	// An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
	AliasError              *AliasError       `json:"aliasError,omitempty"`
	AliasFinal              *string           `json:"aliasFinal,omitempty"`
	AliasWarning            *AliasWarning     `json:"aliasWarning,omitempty"`
	AutoAssignCustomDomains *bool             `json:"autoAssignCustomDomains,omitempty"`
	AutomaticAliases        []string          `json:"automaticAliases,omitempty"`
	BootedAt                float64           `json:"bootedAt"`
	BuildErrorAt            *float64          `json:"buildErrorAt,omitempty"`
	BuildingAt              float64           `json:"buildingAt"`
	CanceledAt              *float64          `json:"canceledAt,omitempty"`
	ChecksState             *ChecksState      `json:"checksState,omitempty"`
	ChecksConclusion        *ChecksConclusion `json:"checksConclusion,omitempty"`
	// A number containing the date when the deployment was created in milliseconds
	CreatedAt float64 `json:"createdAt"`
	// Information about the deployment creator
	Creator        Creator                    `json:"creator"`
	ErrorCode      *string                    `json:"errorCode,omitempty"`
	ErrorLink      *string                    `json:"errorLink,omitempty"`
	ErrorMessage   *string                    `json:"errorMessage,omitempty"`
	ErrorStep      *string                    `json:"errorStep,omitempty"`
	PassiveRegions []string                   `json:"passiveRegions,omitempty"`
	GitSource      *CreateDeploymentGitSource `json:"gitSource,omitempty"`
	// A string holding the unique ID of the deployment
	ID string `json:"id"`
}

func (o *CreateDeploymentResponseBody) GetBuild() Build {
	if o == nil {
		return Build{}
	}
	return o.Build
}

func (o *CreateDeploymentResponseBody) GetBuilds() []CreateDeploymentBuilds {
	if o == nil {
		return nil
	}
	return o.Builds
}

func (o *CreateDeploymentResponseBody) GetConnectBuildsEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.ConnectBuildsEnabled
}

func (o *CreateDeploymentResponseBody) GetConnectConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.ConnectConfigurationID
}

func (o *CreateDeploymentResponseBody) GetCreatedIn() string {
	if o == nil {
		return ""
	}
	return o.CreatedIn
}

func (o *CreateDeploymentResponseBody) GetCrons() []CreateDeploymentCrons {
	if o == nil {
		return nil
	}
	return o.Crons
}

func (o *CreateDeploymentResponseBody) GetEnv() []string {
	if o == nil {
		return []string{}
	}
	return o.Env
}

func (o *CreateDeploymentResponseBody) GetFunctions() map[string]Functions {
	if o == nil {
		return nil
	}
	return o.Functions
}

func (o *CreateDeploymentResponseBody) GetInspectorURL() *string {
	if o == nil {
		return nil
	}
	return o.InspectorURL
}

func (o *CreateDeploymentResponseBody) GetIsInConcurrentBuildsQueue() bool {
	if o == nil {
		return false
	}
	return o.IsInConcurrentBuildsQueue
}

func (o *CreateDeploymentResponseBody) GetMeta() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Meta
}

func (o *CreateDeploymentResponseBody) GetMonorepoManager() *string {
	if o == nil {
		return nil
	}
	return o.MonorepoManager
}

func (o *CreateDeploymentResponseBody) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateDeploymentResponseBody) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *CreateDeploymentResponseBody) GetPassiveConnectConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.PassiveConnectConfigurationID
}

func (o *CreateDeploymentResponseBody) GetPlan() Plan {
	if o == nil {
		return Plan("")
	}
	return o.Plan
}

func (o *CreateDeploymentResponseBody) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *CreateDeploymentResponseBody) GetRoutes() []Routes {
	if o == nil {
		return nil
	}
	return o.Routes
}

func (o *CreateDeploymentResponseBody) GetGitRepo() *GitRepo {
	if o == nil {
		return nil
	}
	return o.GitRepo
}

func (o *CreateDeploymentResponseBody) GetAliasAssignedAt() *AliasAssignedAt {
	if o == nil {
		return nil
	}
	return o.AliasAssignedAt
}

func (o *CreateDeploymentResponseBody) GetLambdas() []Lambdas {
	if o == nil {
		return nil
	}
	return o.Lambdas
}

func (o *CreateDeploymentResponseBody) GetProjectObj() *ProjectObj {
	if o == nil {
		return nil
	}
	return o.ProjectObj
}

func (o *CreateDeploymentResponseBody) GetPublic() bool {
	if o == nil {
		return false
	}
	return o.Public
}

func (o *CreateDeploymentResponseBody) GetReadyState() CreateDeploymentReadyState {
	if o == nil {
		return CreateDeploymentReadyState("")
	}
	return o.ReadyState
}

func (o *CreateDeploymentResponseBody) GetReadySubstate() *ReadySubstate {
	if o == nil {
		return nil
	}
	return o.ReadySubstate
}

func (o *CreateDeploymentResponseBody) GetRegions() []string {
	if o == nil {
		return []string{}
	}
	return o.Regions
}

func (o *CreateDeploymentResponseBody) GetSource() *CreateDeploymentSource {
	if o == nil {
		return nil
	}
	return o.Source
}

func (o *CreateDeploymentResponseBody) GetTarget() *CreateDeploymentTarget {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *CreateDeploymentResponseBody) GetTeam() *Team {
	if o == nil {
		return nil
	}
	return o.Team
}

func (o *CreateDeploymentResponseBody) GetType() CreateDeploymentType {
	if o == nil {
		return CreateDeploymentType("")
	}
	return o.Type
}

func (o *CreateDeploymentResponseBody) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *CreateDeploymentResponseBody) GetUserAliases() []string {
	if o == nil {
		return nil
	}
	return o.UserAliases
}

func (o *CreateDeploymentResponseBody) GetVersion() float64 {
	if o == nil {
		return 0.0
	}
	return o.Version
}

func (o *CreateDeploymentResponseBody) GetPreviewCommentsEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.PreviewCommentsEnabled
}

func (o *CreateDeploymentResponseBody) GetAlias() []string {
	if o == nil {
		return []string{}
	}
	return o.Alias
}

func (o *CreateDeploymentResponseBody) GetAliasAssigned() bool {
	if o == nil {
		return false
	}
	return o.AliasAssigned
}

func (o *CreateDeploymentResponseBody) GetAliasError() *AliasError {
	if o == nil {
		return nil
	}
	return o.AliasError
}

func (o *CreateDeploymentResponseBody) GetAliasFinal() *string {
	if o == nil {
		return nil
	}
	return o.AliasFinal
}

func (o *CreateDeploymentResponseBody) GetAliasWarning() *AliasWarning {
	if o == nil {
		return nil
	}
	return o.AliasWarning
}

func (o *CreateDeploymentResponseBody) GetAutoAssignCustomDomains() *bool {
	if o == nil {
		return nil
	}
	return o.AutoAssignCustomDomains
}

func (o *CreateDeploymentResponseBody) GetAutomaticAliases() []string {
	if o == nil {
		return nil
	}
	return o.AutomaticAliases
}

func (o *CreateDeploymentResponseBody) GetBootedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.BootedAt
}

func (o *CreateDeploymentResponseBody) GetBuildErrorAt() *float64 {
	if o == nil {
		return nil
	}
	return o.BuildErrorAt
}

func (o *CreateDeploymentResponseBody) GetBuildingAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.BuildingAt
}

func (o *CreateDeploymentResponseBody) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *CreateDeploymentResponseBody) GetChecksState() *ChecksState {
	if o == nil {
		return nil
	}
	return o.ChecksState
}

func (o *CreateDeploymentResponseBody) GetChecksConclusion() *ChecksConclusion {
	if o == nil {
		return nil
	}
	return o.ChecksConclusion
}

func (o *CreateDeploymentResponseBody) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *CreateDeploymentResponseBody) GetCreator() Creator {
	if o == nil {
		return Creator{}
	}
	return o.Creator
}

func (o *CreateDeploymentResponseBody) GetErrorCode() *string {
	if o == nil {
		return nil
	}
	return o.ErrorCode
}

func (o *CreateDeploymentResponseBody) GetErrorLink() *string {
	if o == nil {
		return nil
	}
	return o.ErrorLink
}

func (o *CreateDeploymentResponseBody) GetErrorMessage() *string {
	if o == nil {
		return nil
	}
	return o.ErrorMessage
}

func (o *CreateDeploymentResponseBody) GetErrorStep() *string {
	if o == nil {
		return nil
	}
	return o.ErrorStep
}

func (o *CreateDeploymentResponseBody) GetPassiveRegions() []string {
	if o == nil {
		return nil
	}
	return o.PassiveRegions
}

func (o *CreateDeploymentResponseBody) GetGitSource() *CreateDeploymentGitSource {
	if o == nil {
		return nil
	}
	return o.GitSource
}

func (o *CreateDeploymentResponseBody) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

type CreateDeploymentResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// The successfully created deployment
	Object *CreateDeploymentResponseBody
}

func (o *CreateDeploymentResponse) GetContentType() string {
	if o == nil {
		return ""
	}
	return o.ContentType
}

func (o *CreateDeploymentResponse) GetStatusCode() int {
	if o == nil {
		return 0
	}
	return o.StatusCode
}

func (o *CreateDeploymentResponse) GetRawResponse() *http.Response {
	if o == nil {
		return nil
	}
	return o.RawResponse
}

func (o *CreateDeploymentResponse) GetObject() *CreateDeploymentResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
