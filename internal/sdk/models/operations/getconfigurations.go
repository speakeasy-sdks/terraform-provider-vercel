// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/vercel/terraform-provider-vercel/internal/sdk/internal/utils"
	"net/http"
)

type View string

const (
	ViewAccount View = "account"
	ViewProject View = "project"
)

func (e View) ToPointer() *View {
	return &e
}
func (e *View) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "account":
		fallthrough
	case "project":
		*e = View(v)
		return nil
	default:
		return fmt.Errorf("invalid value for View: %v", v)
	}
}

type GetConfigurationsRequest struct {
	View View `queryParam:"style=form,explode=true,name=view"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string `queryParam:"style=form,explode=true,name=slug"`
}

func (o *GetConfigurationsRequest) GetView() View {
	if o == nil {
		return View("")
	}
	return o.View
}

func (o *GetConfigurationsRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetConfigurationsRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

type Integration struct {
	Name                string   `json:"name"`
	Icon                string   `json:"icon"`
	Category            string   `json:"category"`
	IsLegacy            bool     `json:"isLegacy"`
	Flags               []string `json:"flags,omitempty"`
	AssignedBetaLabelAt *float64 `json:"assignedBetaLabelAt,omitempty"`
}

func (o *Integration) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Integration) GetIcon() string {
	if o == nil {
		return ""
	}
	return o.Icon
}

func (o *Integration) GetCategory() string {
	if o == nil {
		return ""
	}
	return o.Category
}

func (o *Integration) GetIsLegacy() bool {
	if o == nil {
		return false
	}
	return o.IsLegacy
}

func (o *Integration) GetFlags() []string {
	if o == nil {
		return nil
	}
	return o.Flags
}

func (o *Integration) GetAssignedBetaLabelAt() *float64 {
	if o == nil {
		return nil
	}
	return o.AssignedBetaLabelAt
}

// GetConfigurationsResponseBodyIntegrationsSource - Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
type GetConfigurationsResponseBodyIntegrationsSource string

const (
	GetConfigurationsResponseBodyIntegrationsSourceMarketplace  GetConfigurationsResponseBodyIntegrationsSource = "marketplace"
	GetConfigurationsResponseBodyIntegrationsSourceDeployButton GetConfigurationsResponseBodyIntegrationsSource = "deploy-button"
	GetConfigurationsResponseBodyIntegrationsSourceExternal     GetConfigurationsResponseBodyIntegrationsSource = "external"
)

func (e GetConfigurationsResponseBodyIntegrationsSource) ToPointer() *GetConfigurationsResponseBodyIntegrationsSource {
	return &e
}
func (e *GetConfigurationsResponseBodyIntegrationsSource) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "marketplace":
		fallthrough
	case "deploy-button":
		fallthrough
	case "external":
		*e = GetConfigurationsResponseBodyIntegrationsSource(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationsResponseBodyIntegrationsSource: %v", v)
	}
}

type GetConfigurationsResponseBodyIntegrationsType string

const (
	GetConfigurationsResponseBodyIntegrationsTypeIntegrationConfiguration GetConfigurationsResponseBodyIntegrationsType = "integration-configuration"
)

func (e GetConfigurationsResponseBodyIntegrationsType) ToPointer() *GetConfigurationsResponseBodyIntegrationsType {
	return &e
}
func (e *GetConfigurationsResponseBodyIntegrationsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration-configuration":
		*e = GetConfigurationsResponseBodyIntegrationsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationsResponseBodyIntegrationsType: %v", v)
	}
}

type ResponseBodyAdded string

const (
	ResponseBodyAddedReadIntegrationConfiguration      ResponseBodyAdded = "read:integration-configuration"
	ResponseBodyAddedReadWriteIntegrationConfiguration ResponseBodyAdded = "read-write:integration-configuration"
	ResponseBodyAddedReadDeployment                    ResponseBodyAdded = "read:deployment"
	ResponseBodyAddedReadWriteDeployment               ResponseBodyAdded = "read-write:deployment"
	ResponseBodyAddedReadWriteDeploymentCheck          ResponseBodyAdded = "read-write:deployment-check"
	ResponseBodyAddedReadProject                       ResponseBodyAdded = "read:project"
	ResponseBodyAddedReadWriteProject                  ResponseBodyAdded = "read-write:project"
	ResponseBodyAddedReadWriteProjectEnvVars           ResponseBodyAdded = "read-write:project-env-vars"
	ResponseBodyAddedReadWriteGlobalProjectEnvVars     ResponseBodyAdded = "read-write:global-project-env-vars"
	ResponseBodyAddedReadTeam                          ResponseBodyAdded = "read:team"
	ResponseBodyAddedReadUser                          ResponseBodyAdded = "read:user"
	ResponseBodyAddedReadWriteLogDrain                 ResponseBodyAdded = "read-write:log-drain"
	ResponseBodyAddedReadDomain                        ResponseBodyAdded = "read:domain"
	ResponseBodyAddedReadWriteDomain                   ResponseBodyAdded = "read-write:domain"
	ResponseBodyAddedReadWriteEdgeConfig               ResponseBodyAdded = "read-write:edge-config"
	ResponseBodyAddedReadWriteOtelEndpoint             ResponseBodyAdded = "read-write:otel-endpoint"
	ResponseBodyAddedReadMonitoring                    ResponseBodyAdded = "read:monitoring"
	ResponseBodyAddedReadWriteIntegrationResource      ResponseBodyAdded = "read-write:integration-resource"
)

func (e ResponseBodyAdded) ToPointer() *ResponseBodyAdded {
	return &e
}
func (e *ResponseBodyAdded) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "read:integration-configuration":
		fallthrough
	case "read-write:integration-configuration":
		fallthrough
	case "read:deployment":
		fallthrough
	case "read-write:deployment":
		fallthrough
	case "read-write:deployment-check":
		fallthrough
	case "read:project":
		fallthrough
	case "read-write:project":
		fallthrough
	case "read-write:project-env-vars":
		fallthrough
	case "read-write:global-project-env-vars":
		fallthrough
	case "read:team":
		fallthrough
	case "read:user":
		fallthrough
	case "read-write:log-drain":
		fallthrough
	case "read:domain":
		fallthrough
	case "read-write:domain":
		fallthrough
	case "read-write:edge-config":
		fallthrough
	case "read-write:otel-endpoint":
		fallthrough
	case "read:monitoring":
		fallthrough
	case "read-write:integration-resource":
		*e = ResponseBodyAdded(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ResponseBodyAdded: %v", v)
	}
}

type ResponseBodyUpgraded string

const (
	ResponseBodyUpgradedReadIntegrationConfiguration      ResponseBodyUpgraded = "read:integration-configuration"
	ResponseBodyUpgradedReadWriteIntegrationConfiguration ResponseBodyUpgraded = "read-write:integration-configuration"
	ResponseBodyUpgradedReadDeployment                    ResponseBodyUpgraded = "read:deployment"
	ResponseBodyUpgradedReadWriteDeployment               ResponseBodyUpgraded = "read-write:deployment"
	ResponseBodyUpgradedReadWriteDeploymentCheck          ResponseBodyUpgraded = "read-write:deployment-check"
	ResponseBodyUpgradedReadProject                       ResponseBodyUpgraded = "read:project"
	ResponseBodyUpgradedReadWriteProject                  ResponseBodyUpgraded = "read-write:project"
	ResponseBodyUpgradedReadWriteProjectEnvVars           ResponseBodyUpgraded = "read-write:project-env-vars"
	ResponseBodyUpgradedReadWriteGlobalProjectEnvVars     ResponseBodyUpgraded = "read-write:global-project-env-vars"
	ResponseBodyUpgradedReadTeam                          ResponseBodyUpgraded = "read:team"
	ResponseBodyUpgradedReadUser                          ResponseBodyUpgraded = "read:user"
	ResponseBodyUpgradedReadWriteLogDrain                 ResponseBodyUpgraded = "read-write:log-drain"
	ResponseBodyUpgradedReadDomain                        ResponseBodyUpgraded = "read:domain"
	ResponseBodyUpgradedReadWriteDomain                   ResponseBodyUpgraded = "read-write:domain"
	ResponseBodyUpgradedReadWriteEdgeConfig               ResponseBodyUpgraded = "read-write:edge-config"
	ResponseBodyUpgradedReadWriteOtelEndpoint             ResponseBodyUpgraded = "read-write:otel-endpoint"
	ResponseBodyUpgradedReadMonitoring                    ResponseBodyUpgraded = "read:monitoring"
	ResponseBodyUpgradedReadWriteIntegrationResource      ResponseBodyUpgraded = "read-write:integration-resource"
)

func (e ResponseBodyUpgraded) ToPointer() *ResponseBodyUpgraded {
	return &e
}
func (e *ResponseBodyUpgraded) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "read:integration-configuration":
		fallthrough
	case "read-write:integration-configuration":
		fallthrough
	case "read:deployment":
		fallthrough
	case "read-write:deployment":
		fallthrough
	case "read-write:deployment-check":
		fallthrough
	case "read:project":
		fallthrough
	case "read-write:project":
		fallthrough
	case "read-write:project-env-vars":
		fallthrough
	case "read-write:global-project-env-vars":
		fallthrough
	case "read:team":
		fallthrough
	case "read:user":
		fallthrough
	case "read-write:log-drain":
		fallthrough
	case "read:domain":
		fallthrough
	case "read-write:domain":
		fallthrough
	case "read-write:edge-config":
		fallthrough
	case "read-write:otel-endpoint":
		fallthrough
	case "read:monitoring":
		fallthrough
	case "read-write:integration-resource":
		*e = ResponseBodyUpgraded(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ResponseBodyUpgraded: %v", v)
	}
}

type ResponseBodyScopes struct {
	Added    []ResponseBodyAdded    `json:"added"`
	Upgraded []ResponseBodyUpgraded `json:"upgraded"`
}

func (o *ResponseBodyScopes) GetAdded() []ResponseBodyAdded {
	if o == nil {
		return []ResponseBodyAdded{}
	}
	return o.Added
}

func (o *ResponseBodyScopes) GetUpgraded() []ResponseBodyUpgraded {
	if o == nil {
		return []ResponseBodyUpgraded{}
	}
	return o.Upgraded
}

type ResponseBodyScopesQueue struct {
	Scopes      ResponseBodyScopes `json:"scopes"`
	Note        string             `json:"note"`
	RequestedAt float64            `json:"requestedAt"`
	ConfirmedAt *float64           `json:"confirmedAt,omitempty"`
}

func (o *ResponseBodyScopesQueue) GetScopes() ResponseBodyScopes {
	if o == nil {
		return ResponseBodyScopes{}
	}
	return o.Scopes
}

func (o *ResponseBodyScopesQueue) GetNote() string {
	if o == nil {
		return ""
	}
	return o.Note
}

func (o *ResponseBodyScopesQueue) GetRequestedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.RequestedAt
}

func (o *ResponseBodyScopesQueue) GetConfirmedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ConfirmedAt
}

type ResponseBodyDisabledReason string

const (
	ResponseBodyDisabledReasonDisabledByOwner          ResponseBodyDisabledReason = "disabled-by-owner"
	ResponseBodyDisabledReasonFeatureNotAvailable      ResponseBodyDisabledReason = "feature-not-available"
	ResponseBodyDisabledReasonDisabledByAdmin          ResponseBodyDisabledReason = "disabled-by-admin"
	ResponseBodyDisabledReasonOriginalOwnerLeftTheTeam ResponseBodyDisabledReason = "original-owner-left-the-team"
)

func (e ResponseBodyDisabledReason) ToPointer() *ResponseBodyDisabledReason {
	return &e
}
func (e *ResponseBodyDisabledReason) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disabled-by-owner":
		fallthrough
	case "feature-not-available":
		fallthrough
	case "disabled-by-admin":
		fallthrough
	case "original-owner-left-the-team":
		*e = ResponseBodyDisabledReason(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ResponseBodyDisabledReason: %v", v)
	}
}

// ResponseBodyInstallationType - Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
type ResponseBodyInstallationType string

const (
	ResponseBodyInstallationTypeMarketplace ResponseBodyInstallationType = "marketplace"
	ResponseBodyInstallationTypeExternal    ResponseBodyInstallationType = "external"
)

func (e ResponseBodyInstallationType) ToPointer() *ResponseBodyInstallationType {
	return &e
}
func (e *ResponseBodyInstallationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "marketplace":
		fallthrough
	case "external":
		*e = ResponseBodyInstallationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ResponseBodyInstallationType: %v", v)
	}
}

type GetConfigurationsResponseBody2 struct {
	Integration Integration `json:"integration"`
	// A timestamp that tells you when the configuration was installed successfully
	CompletedAt *float64 `json:"completedAt,omitempty"`
	// A timestamp that tells you when the configuration was created
	CreatedAt float64 `json:"createdAt"`
	// The unique identifier of the configuration
	ID string `json:"id"`
	// The unique identifier of the app the configuration was created for
	IntegrationID string `json:"integrationId"`
	// The user or team ID that owns the configuration
	OwnerID string `json:"ownerId"`
	// When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
	Projects []string `json:"projects,omitempty"`
	// Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
	Source               *GetConfigurationsResponseBodyIntegrationsSource `json:"source,omitempty"`
	RemovedLogDrainsAt   *float64                                         `json:"removedLogDrainsAt,omitempty"`
	RemovedProjectEnvsAt *float64                                         `json:"removedProjectEnvsAt,omitempty"`
	RemovedTokensAt      *float64                                         `json:"removedTokensAt,omitempty"`
	RemovedWebhooksAt    *float64                                         `json:"removedWebhooksAt,omitempty"`
	// The slug of the integration the configuration is created for.
	Slug string `json:"slug"`
	// When the configuration was created for a team, this will show the ID of the team.
	TeamID *string                                       `json:"teamId,omitempty"`
	Type   GetConfigurationsResponseBodyIntegrationsType `json:"type"`
	// A timestamp that tells you when the configuration was updated.
	UpdatedAt float64 `json:"updatedAt"`
	// The ID of the user that created the configuration.
	UserID string `json:"userId"`
	// The resources that are allowed to be accessed by the configuration.
	Scopes      []string                  `json:"scopes"`
	ScopesQueue []ResponseBodyScopesQueue `json:"scopesQueue,omitempty"`
	// A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
	DisabledAt *float64 `json:"disabledAt,omitempty"`
	// A timestamp that tells you when the configuration was updated.
	DeletedAt      *float64                    `json:"deletedAt,omitempty"`
	DisabledReason *ResponseBodyDisabledReason `json:"disabledReason,omitempty"`
	// A timestamp that tells you when the configuration was migrated as part of the Northstar migration. In the future, if we allow integration configurations to be transferred between teams, this field should be cleared upon transfer.
	NorthstarMigratedAt *float64 `json:"northstarMigratedAt,omitempty"`
	// Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
	InstallationType *ResponseBodyInstallationType `json:"installationType,omitempty"`
}

func (o *GetConfigurationsResponseBody2) GetIntegration() Integration {
	if o == nil {
		return Integration{}
	}
	return o.Integration
}

func (o *GetConfigurationsResponseBody2) GetCompletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CompletedAt
}

func (o *GetConfigurationsResponseBody2) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetConfigurationsResponseBody2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetConfigurationsResponseBody2) GetIntegrationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationID
}

func (o *GetConfigurationsResponseBody2) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *GetConfigurationsResponseBody2) GetProjects() []string {
	if o == nil {
		return nil
	}
	return o.Projects
}

func (o *GetConfigurationsResponseBody2) GetSource() *GetConfigurationsResponseBodyIntegrationsSource {
	if o == nil {
		return nil
	}
	return o.Source
}

func (o *GetConfigurationsResponseBody2) GetRemovedLogDrainsAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedLogDrainsAt
}

func (o *GetConfigurationsResponseBody2) GetRemovedProjectEnvsAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedProjectEnvsAt
}

func (o *GetConfigurationsResponseBody2) GetRemovedTokensAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedTokensAt
}

func (o *GetConfigurationsResponseBody2) GetRemovedWebhooksAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedWebhooksAt
}

func (o *GetConfigurationsResponseBody2) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *GetConfigurationsResponseBody2) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetConfigurationsResponseBody2) GetType() GetConfigurationsResponseBodyIntegrationsType {
	if o == nil {
		return GetConfigurationsResponseBodyIntegrationsType("")
	}
	return o.Type
}

func (o *GetConfigurationsResponseBody2) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *GetConfigurationsResponseBody2) GetUserID() string {
	if o == nil {
		return ""
	}
	return o.UserID
}

func (o *GetConfigurationsResponseBody2) GetScopes() []string {
	if o == nil {
		return []string{}
	}
	return o.Scopes
}

func (o *GetConfigurationsResponseBody2) GetScopesQueue() []ResponseBodyScopesQueue {
	if o == nil {
		return nil
	}
	return o.ScopesQueue
}

func (o *GetConfigurationsResponseBody2) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *GetConfigurationsResponseBody2) GetDeletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DeletedAt
}

func (o *GetConfigurationsResponseBody2) GetDisabledReason() *ResponseBodyDisabledReason {
	if o == nil {
		return nil
	}
	return o.DisabledReason
}

func (o *GetConfigurationsResponseBody2) GetNorthstarMigratedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.NorthstarMigratedAt
}

func (o *GetConfigurationsResponseBody2) GetInstallationType() *ResponseBodyInstallationType {
	if o == nil {
		return nil
	}
	return o.InstallationType
}

// GetConfigurationsResponseBodySource - Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
type GetConfigurationsResponseBodySource string

const (
	GetConfigurationsResponseBodySourceMarketplace  GetConfigurationsResponseBodySource = "marketplace"
	GetConfigurationsResponseBodySourceDeployButton GetConfigurationsResponseBodySource = "deploy-button"
	GetConfigurationsResponseBodySourceExternal     GetConfigurationsResponseBodySource = "external"
)

func (e GetConfigurationsResponseBodySource) ToPointer() *GetConfigurationsResponseBodySource {
	return &e
}
func (e *GetConfigurationsResponseBodySource) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "marketplace":
		fallthrough
	case "deploy-button":
		fallthrough
	case "external":
		*e = GetConfigurationsResponseBodySource(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationsResponseBodySource: %v", v)
	}
}

type GetConfigurationsResponseBodyType string

const (
	GetConfigurationsResponseBodyTypeIntegrationConfiguration GetConfigurationsResponseBodyType = "integration-configuration"
)

func (e GetConfigurationsResponseBodyType) ToPointer() *GetConfigurationsResponseBodyType {
	return &e
}
func (e *GetConfigurationsResponseBodyType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration-configuration":
		*e = GetConfigurationsResponseBodyType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationsResponseBodyType: %v", v)
	}
}

type Added string

const (
	AddedReadIntegrationConfiguration      Added = "read:integration-configuration"
	AddedReadWriteIntegrationConfiguration Added = "read-write:integration-configuration"
	AddedReadDeployment                    Added = "read:deployment"
	AddedReadWriteDeployment               Added = "read-write:deployment"
	AddedReadWriteDeploymentCheck          Added = "read-write:deployment-check"
	AddedReadProject                       Added = "read:project"
	AddedReadWriteProject                  Added = "read-write:project"
	AddedReadWriteProjectEnvVars           Added = "read-write:project-env-vars"
	AddedReadWriteGlobalProjectEnvVars     Added = "read-write:global-project-env-vars"
	AddedReadTeam                          Added = "read:team"
	AddedReadUser                          Added = "read:user"
	AddedReadWriteLogDrain                 Added = "read-write:log-drain"
	AddedReadDomain                        Added = "read:domain"
	AddedReadWriteDomain                   Added = "read-write:domain"
	AddedReadWriteEdgeConfig               Added = "read-write:edge-config"
	AddedReadWriteOtelEndpoint             Added = "read-write:otel-endpoint"
	AddedReadMonitoring                    Added = "read:monitoring"
	AddedReadWriteIntegrationResource      Added = "read-write:integration-resource"
)

func (e Added) ToPointer() *Added {
	return &e
}
func (e *Added) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "read:integration-configuration":
		fallthrough
	case "read-write:integration-configuration":
		fallthrough
	case "read:deployment":
		fallthrough
	case "read-write:deployment":
		fallthrough
	case "read-write:deployment-check":
		fallthrough
	case "read:project":
		fallthrough
	case "read-write:project":
		fallthrough
	case "read-write:project-env-vars":
		fallthrough
	case "read-write:global-project-env-vars":
		fallthrough
	case "read:team":
		fallthrough
	case "read:user":
		fallthrough
	case "read-write:log-drain":
		fallthrough
	case "read:domain":
		fallthrough
	case "read-write:domain":
		fallthrough
	case "read-write:edge-config":
		fallthrough
	case "read-write:otel-endpoint":
		fallthrough
	case "read:monitoring":
		fallthrough
	case "read-write:integration-resource":
		*e = Added(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Added: %v", v)
	}
}

type Upgraded string

const (
	UpgradedReadIntegrationConfiguration      Upgraded = "read:integration-configuration"
	UpgradedReadWriteIntegrationConfiguration Upgraded = "read-write:integration-configuration"
	UpgradedReadDeployment                    Upgraded = "read:deployment"
	UpgradedReadWriteDeployment               Upgraded = "read-write:deployment"
	UpgradedReadWriteDeploymentCheck          Upgraded = "read-write:deployment-check"
	UpgradedReadProject                       Upgraded = "read:project"
	UpgradedReadWriteProject                  Upgraded = "read-write:project"
	UpgradedReadWriteProjectEnvVars           Upgraded = "read-write:project-env-vars"
	UpgradedReadWriteGlobalProjectEnvVars     Upgraded = "read-write:global-project-env-vars"
	UpgradedReadTeam                          Upgraded = "read:team"
	UpgradedReadUser                          Upgraded = "read:user"
	UpgradedReadWriteLogDrain                 Upgraded = "read-write:log-drain"
	UpgradedReadDomain                        Upgraded = "read:domain"
	UpgradedReadWriteDomain                   Upgraded = "read-write:domain"
	UpgradedReadWriteEdgeConfig               Upgraded = "read-write:edge-config"
	UpgradedReadWriteOtelEndpoint             Upgraded = "read-write:otel-endpoint"
	UpgradedReadMonitoring                    Upgraded = "read:monitoring"
	UpgradedReadWriteIntegrationResource      Upgraded = "read-write:integration-resource"
)

func (e Upgraded) ToPointer() *Upgraded {
	return &e
}
func (e *Upgraded) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "read:integration-configuration":
		fallthrough
	case "read-write:integration-configuration":
		fallthrough
	case "read:deployment":
		fallthrough
	case "read-write:deployment":
		fallthrough
	case "read-write:deployment-check":
		fallthrough
	case "read:project":
		fallthrough
	case "read-write:project":
		fallthrough
	case "read-write:project-env-vars":
		fallthrough
	case "read-write:global-project-env-vars":
		fallthrough
	case "read:team":
		fallthrough
	case "read:user":
		fallthrough
	case "read-write:log-drain":
		fallthrough
	case "read:domain":
		fallthrough
	case "read-write:domain":
		fallthrough
	case "read-write:edge-config":
		fallthrough
	case "read-write:otel-endpoint":
		fallthrough
	case "read:monitoring":
		fallthrough
	case "read-write:integration-resource":
		*e = Upgraded(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Upgraded: %v", v)
	}
}

type Scopes struct {
	Added    []Added    `json:"added"`
	Upgraded []Upgraded `json:"upgraded"`
}

func (o *Scopes) GetAdded() []Added {
	if o == nil {
		return []Added{}
	}
	return o.Added
}

func (o *Scopes) GetUpgraded() []Upgraded {
	if o == nil {
		return []Upgraded{}
	}
	return o.Upgraded
}

type ScopesQueue struct {
	Scopes      Scopes   `json:"scopes"`
	Note        string   `json:"note"`
	RequestedAt float64  `json:"requestedAt"`
	ConfirmedAt *float64 `json:"confirmedAt,omitempty"`
}

func (o *ScopesQueue) GetScopes() Scopes {
	if o == nil {
		return Scopes{}
	}
	return o.Scopes
}

func (o *ScopesQueue) GetNote() string {
	if o == nil {
		return ""
	}
	return o.Note
}

func (o *ScopesQueue) GetRequestedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.RequestedAt
}

func (o *ScopesQueue) GetConfirmedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ConfirmedAt
}

type GetConfigurationsResponseBodyDisabledReason string

const (
	GetConfigurationsResponseBodyDisabledReasonDisabledByOwner          GetConfigurationsResponseBodyDisabledReason = "disabled-by-owner"
	GetConfigurationsResponseBodyDisabledReasonFeatureNotAvailable      GetConfigurationsResponseBodyDisabledReason = "feature-not-available"
	GetConfigurationsResponseBodyDisabledReasonDisabledByAdmin          GetConfigurationsResponseBodyDisabledReason = "disabled-by-admin"
	GetConfigurationsResponseBodyDisabledReasonOriginalOwnerLeftTheTeam GetConfigurationsResponseBodyDisabledReason = "original-owner-left-the-team"
)

func (e GetConfigurationsResponseBodyDisabledReason) ToPointer() *GetConfigurationsResponseBodyDisabledReason {
	return &e
}
func (e *GetConfigurationsResponseBodyDisabledReason) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disabled-by-owner":
		fallthrough
	case "feature-not-available":
		fallthrough
	case "disabled-by-admin":
		fallthrough
	case "original-owner-left-the-team":
		*e = GetConfigurationsResponseBodyDisabledReason(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConfigurationsResponseBodyDisabledReason: %v", v)
	}
}

// InstallationType - Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
type InstallationType string

const (
	InstallationTypeMarketplace InstallationType = "marketplace"
	InstallationTypeExternal    InstallationType = "external"
)

func (e InstallationType) ToPointer() *InstallationType {
	return &e
}
func (e *InstallationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "marketplace":
		fallthrough
	case "external":
		*e = InstallationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InstallationType: %v", v)
	}
}

type GetConfigurationsResponseBody1 struct {
	// A timestamp that tells you when the configuration was installed successfully
	CompletedAt *float64 `json:"completedAt,omitempty"`
	// A timestamp that tells you when the configuration was created
	CreatedAt float64 `json:"createdAt"`
	// The unique identifier of the configuration
	ID string `json:"id"`
	// The unique identifier of the app the configuration was created for
	IntegrationID string `json:"integrationId"`
	// The user or team ID that owns the configuration
	OwnerID string `json:"ownerId"`
	// When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
	Projects []string `json:"projects,omitempty"`
	// Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
	Source               *GetConfigurationsResponseBodySource `json:"source,omitempty"`
	RemovedLogDrainsAt   *float64                             `json:"removedLogDrainsAt,omitempty"`
	RemovedProjectEnvsAt *float64                             `json:"removedProjectEnvsAt,omitempty"`
	RemovedTokensAt      *float64                             `json:"removedTokensAt,omitempty"`
	RemovedWebhooksAt    *float64                             `json:"removedWebhooksAt,omitempty"`
	// The slug of the integration the configuration is created for.
	Slug string `json:"slug"`
	// When the configuration was created for a team, this will show the ID of the team.
	TeamID *string                           `json:"teamId,omitempty"`
	Type   GetConfigurationsResponseBodyType `json:"type"`
	// A timestamp that tells you when the configuration was updated.
	UpdatedAt float64 `json:"updatedAt"`
	// The ID of the user that created the configuration.
	UserID string `json:"userId"`
	// The resources that are allowed to be accessed by the configuration.
	Scopes      []string      `json:"scopes"`
	ScopesQueue []ScopesQueue `json:"scopesQueue,omitempty"`
	// A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
	DisabledAt *float64 `json:"disabledAt,omitempty"`
	// A timestamp that tells you when the configuration was updated.
	DeletedAt      *float64                                     `json:"deletedAt,omitempty"`
	DisabledReason *GetConfigurationsResponseBodyDisabledReason `json:"disabledReason,omitempty"`
	// A timestamp that tells you when the configuration was migrated as part of the Northstar migration. In the future, if we allow integration configurations to be transferred between teams, this field should be cleared upon transfer.
	NorthstarMigratedAt *float64 `json:"northstarMigratedAt,omitempty"`
	// Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
	InstallationType *InstallationType `json:"installationType,omitempty"`
}

func (o *GetConfigurationsResponseBody1) GetCompletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CompletedAt
}

func (o *GetConfigurationsResponseBody1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetConfigurationsResponseBody1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetConfigurationsResponseBody1) GetIntegrationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationID
}

func (o *GetConfigurationsResponseBody1) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *GetConfigurationsResponseBody1) GetProjects() []string {
	if o == nil {
		return nil
	}
	return o.Projects
}

func (o *GetConfigurationsResponseBody1) GetSource() *GetConfigurationsResponseBodySource {
	if o == nil {
		return nil
	}
	return o.Source
}

func (o *GetConfigurationsResponseBody1) GetRemovedLogDrainsAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedLogDrainsAt
}

func (o *GetConfigurationsResponseBody1) GetRemovedProjectEnvsAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedProjectEnvsAt
}

func (o *GetConfigurationsResponseBody1) GetRemovedTokensAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedTokensAt
}

func (o *GetConfigurationsResponseBody1) GetRemovedWebhooksAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RemovedWebhooksAt
}

func (o *GetConfigurationsResponseBody1) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *GetConfigurationsResponseBody1) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetConfigurationsResponseBody1) GetType() GetConfigurationsResponseBodyType {
	if o == nil {
		return GetConfigurationsResponseBodyType("")
	}
	return o.Type
}

func (o *GetConfigurationsResponseBody1) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *GetConfigurationsResponseBody1) GetUserID() string {
	if o == nil {
		return ""
	}
	return o.UserID
}

func (o *GetConfigurationsResponseBody1) GetScopes() []string {
	if o == nil {
		return []string{}
	}
	return o.Scopes
}

func (o *GetConfigurationsResponseBody1) GetScopesQueue() []ScopesQueue {
	if o == nil {
		return nil
	}
	return o.ScopesQueue
}

func (o *GetConfigurationsResponseBody1) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *GetConfigurationsResponseBody1) GetDeletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DeletedAt
}

func (o *GetConfigurationsResponseBody1) GetDisabledReason() *GetConfigurationsResponseBodyDisabledReason {
	if o == nil {
		return nil
	}
	return o.DisabledReason
}

func (o *GetConfigurationsResponseBody1) GetNorthstarMigratedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.NorthstarMigratedAt
}

func (o *GetConfigurationsResponseBody1) GetInstallationType() *InstallationType {
	if o == nil {
		return nil
	}
	return o.InstallationType
}

type GetConfigurationsResponseBodyUnionType string

const (
	GetConfigurationsResponseBodyUnionTypeGetConfigurationsResponseBody1        GetConfigurationsResponseBodyUnionType = "getConfigurations_responseBody_1"
	GetConfigurationsResponseBodyUnionTypeArrayOfGetConfigurationsResponseBody2 GetConfigurationsResponseBodyUnionType = "arrayOfGetConfigurationsResponseBody2"
)

// GetConfigurationsResponseBody - The list of configurations for the authenticated user
type GetConfigurationsResponseBody struct {
	GetConfigurationsResponseBody1        *GetConfigurationsResponseBody1
	ArrayOfGetConfigurationsResponseBody2 []GetConfigurationsResponseBody2

	Type GetConfigurationsResponseBodyUnionType
}

func CreateGetConfigurationsResponseBodyGetConfigurationsResponseBody1(getConfigurationsResponseBody1 GetConfigurationsResponseBody1) GetConfigurationsResponseBody {
	typ := GetConfigurationsResponseBodyUnionTypeGetConfigurationsResponseBody1

	return GetConfigurationsResponseBody{
		GetConfigurationsResponseBody1: &getConfigurationsResponseBody1,
		Type:                           typ,
	}
}

func CreateGetConfigurationsResponseBodyArrayOfGetConfigurationsResponseBody2(arrayOfGetConfigurationsResponseBody2 []GetConfigurationsResponseBody2) GetConfigurationsResponseBody {
	typ := GetConfigurationsResponseBodyUnionTypeArrayOfGetConfigurationsResponseBody2

	return GetConfigurationsResponseBody{
		ArrayOfGetConfigurationsResponseBody2: arrayOfGetConfigurationsResponseBody2,
		Type:                                  typ,
	}
}

func (u *GetConfigurationsResponseBody) UnmarshalJSON(data []byte) error {

	var getConfigurationsResponseBody1 GetConfigurationsResponseBody1 = GetConfigurationsResponseBody1{}
	if err := utils.UnmarshalJSON(data, &getConfigurationsResponseBody1, "", true, true); err == nil {
		u.GetConfigurationsResponseBody1 = &getConfigurationsResponseBody1
		u.Type = GetConfigurationsResponseBodyUnionTypeGetConfigurationsResponseBody1
		return nil
	}

	var arrayOfGetConfigurationsResponseBody2 []GetConfigurationsResponseBody2 = []GetConfigurationsResponseBody2{}
	if err := utils.UnmarshalJSON(data, &arrayOfGetConfigurationsResponseBody2, "", true, true); err == nil {
		u.ArrayOfGetConfigurationsResponseBody2 = arrayOfGetConfigurationsResponseBody2
		u.Type = GetConfigurationsResponseBodyUnionTypeArrayOfGetConfigurationsResponseBody2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetConfigurationsResponseBody", string(data))
}

func (u GetConfigurationsResponseBody) MarshalJSON() ([]byte, error) {
	if u.GetConfigurationsResponseBody1 != nil {
		return utils.MarshalJSON(u.GetConfigurationsResponseBody1, "", true)
	}

	if u.ArrayOfGetConfigurationsResponseBody2 != nil {
		return utils.MarshalJSON(u.ArrayOfGetConfigurationsResponseBody2, "", true)
	}

	return nil, errors.New("could not marshal union type GetConfigurationsResponseBody: all fields are null")
}

type GetConfigurationsResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// The list of configurations for the authenticated user
	OneOf *GetConfigurationsResponseBody
}

func (o *GetConfigurationsResponse) GetContentType() string {
	if o == nil {
		return ""
	}
	return o.ContentType
}

func (o *GetConfigurationsResponse) GetStatusCode() int {
	if o == nil {
		return 0
	}
	return o.StatusCode
}

func (o *GetConfigurationsResponse) GetRawResponse() *http.Response {
	if o == nil {
		return nil
	}
	return o.RawResponse
}

func (o *GetConfigurationsResponse) GetOneOf() *GetConfigurationsResponseBody {
	if o == nil {
		return nil
	}
	return o.OneOf
}
